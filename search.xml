<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何构建一个支持 Windows XP 的 LIB/DLL/EXE</title>
      <link href="/2021-11-07-build-for-windows-xp/"/>
      <url>/2021-11-07-build-for-windows-xp/</url>
      
        <content type="html"><![CDATA[<p>最近把公司的一些大型跨平台 C++ Base 项目从 CMake 构建系统切换到了 Google 的 <a href="https://gn.googlesource.com/gn/" target="_blank" rel="noopener">GN Build</a>。进展都比较顺利，直到有客户需要一个支持 Windows XP 的动态库。。。</p><p>虽然马上就要 2022 年，距离 XP 的诞生已经超过 20 年，距离 XP 的废弃也超过 7 年了，但仍然架不住还是将近有 5% 的计算机运行着 XP （大陆地区甚至有 15% ！），既然客户需要，那还是得支持 🤷‍♂️</p><a id="more"></a><p>实际上这个项目在几年前已经做过一次 XP 的适配，也顺利交付过很多次了，但明显 Google Chromium 的工具链默认并不支持 Windows XP。</p><h2 id="构建支持"><a href="#构建支持" class="headerlink" title="构建支持"></a>构建支持</h2><p>经过一番研究，实际上在构建这块，想要支持 XP 还是比较简单的，难的是代码中如何解决适配那些 XP 没有提供的 Windows API。以下按照不同的 Windows 工程来讨论。</p><h3 id="原生-Visual-Studio-工程"><a href="#原生-Visual-Studio-工程" class="headerlink" title="原生 Visual Studio 工程"></a>原生 Visual Studio 工程</h3><ol><li><p>首先确保你的 Visual Studio 已安装 XP 工具集（例如 VS 2019 的需要安装标注了已废弃的 v141_xp 工具集。</p><p> <img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/visual_studio_installer_xp.png" alt="Visual Studio Installer v141_xp"></p></li><li><p>打开解决方案/项目，在项目属性中找到常规 -&gt; 平台工具集，选择 v141_xp 或其他带有 xp 后缀的工具集。</p><p> <img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/visual_studio_project_properties.png" alt="Visual Studio Project Properties Toolset"></p></li><li><p>改动保存后，注意到此时 Windows SDK 的版本会自动切换到 7.0。然后再次生成项目，就能构建出一个支持 Windows XP 的库/可执行二进制了。</p></li></ol><h3 id="CMake-工程"><a href="#CMake-工程" class="headerlink" title="CMake 工程"></a>CMake 工程</h3><ol><li><p>需要使用 Visual Studio Generator，参考 <a href="https://cmake.org/cmake/help/v3.22/manual/cmake-generators.7.html#visual-studio-generators" target="_blank" rel="noopener">CMake Visual Studio Generator</a></p></li><li><p>通过 <code>-T</code> 参数指定 v141_xp 或 v140_xp 的工具集，参考 <a href="https://cmake.org/cmake/help/v3.22/variable/CMAKE_GENERATOR_TOOLSET.html#variable:CMAKE_GENERATOR_TOOLSET" target="_blank" rel="noopener">CMAKE_GENERATOR_TOOLSET</a></p></li><li><p>例如 <code>cmake -GVisual Studio 15 2017 -Tv141_xp</code></p></li></ol><h3 id="GN-Ninja-工程"><a href="#GN-Ninja-工程" class="headerlink" title="GN (Ninja) 工程"></a>GN (Ninja) 工程</h3><blockquote><p>此方式不仅适用于 GN 工程，也适用于任何直接调用 MSBuild 命令行工具的构建系统。</p></blockquote><ol><li><p>为所有 <code>source_set</code> 添加 <code>_USING_V110_SDK71_</code> 这个 <code>defines</code> （宏定义），即为 <code>cl.exe</code> 添加参数 <code>/D_USING_V110_SDK71_</code> （用于传递给源码中可能出现的 XP 分支宏，这是官方推荐的 XP 专用宏）</p></li><li><p>为你的 <code>shared_library</code> 或 <code>executable</code> Target 添加 <code>/SUBSYSTEM:WINDOWS,&quot;5.02&quot;</code> 这个 <code>ldflags</code> （链接器参数） ，即为 <code>link.exe</code> 指定构建目标为 5.02 (Windows XP SP2)，参考 <a href="https://docs.microsoft.com/en-us/cpp/build/reference/subsystem-specify-subsystem?view=msvc-160" target="_blank" rel="noopener">链接器选项 /SUBSYSTEM（指定子系统）</a></p></li><li><p>如果你使用的是 Google Chromium 的 <a href="https://github.com/chromium/chromium/tree/master/build" target="_blank" rel="noopener"><code>build</code></a> 作为你的 GN 工程的工具链，你可以直接为你的 <code>shared_library</code> 或 <code>executable</code> Target 添加如下 config:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configs += [ &quot;//build/config/win:windowed&quot; ]</span><br></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/chromium_build_win_config_windowed.png" alt="Chromium build win config windowed"></p><p> 参考：<a href="https://github.com/patrick-fu/gn_build/blob/48ac640820/config/win/BUILD.gn#L570" target="_blank" rel="noopener">GN build toolchain, //build/config/win:windowed</a></p></li></ol><h3 id="代码支持"><a href="#代码支持" class="headerlink" title="代码支持"></a>代码支持</h3><p>如果你的项目里依赖了很多 Windows API，可以预见的是链接时找不到符号，因为很多 API 都是在 Windows 7 以后才提供的。</p><p>当然你可以耗费一些时间，把那些用到的新 API 替换掉，不管是找替代品还是干脆就不支持，都可以。</p><p>个人推荐一个便于你适配 XP 的 <a href="https://github.com/Chuyu-Team/YY-Thunks" target="_blank" rel="noopener">开源项目 YY-Thunks</a>，集成到你的工程中，应该就能链接成功了。 :-)</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> GN </tag>
            
            <tag> Ninja </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 移动端屏幕采集方案分享</title>
      <link href="/2020-11-20-flutter-screen-capture/"/>
      <url>/2020-11-20-flutter-screen-capture/</url>
      
        <content type="html"><![CDATA[<p>现如今随着 Flutter 的应用越来越广泛，纯 Flutter 项目也越来越多，本篇内容主要分享的是 Flutter 移动端（iOS + Android）的屏幕采集的实现。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在视频会议、线上课堂、游戏直播等场景，屏幕共享是一个最常见的功能。屏幕共享就是对屏幕画面的实时共享，端到端主要有几个步骤：录屏采集、视频编码及封装、实时传输、视频解封装及解码、视频渲染。</p><p>一般来说，实时屏幕共享时，共享发起端以固定采样频率（一般 8 - 15帧足够）抓取到屏幕中指定源的画面（包括指定屏幕、指定区域、指定程序等），经过视频编码压缩（应选择保持文本/图形边缘信息不失真的方案）后，在实时网络上以相应的帧率分发。</p><p>因此，屏幕采集是实现实时屏幕共享的基础，它的应用场景也是非常广泛的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先我们看看原生系统提供了哪些能力来进行屏幕录制。</p><ol><li><p>iOS 11.0 提供了 <code>ReplayKit 2</code> 用于采集跨 App 的全局屏幕内容，但仅能通过控制中心启动；iOS 12.0 则在此基础上提供了从 App 内启动 ReplayKit 的能力。</p></li><li><p>Android 5.0 系统提供了 <code>MediaProjection</code> 功能，只需弹窗获取用户的同意即可采集到全局屏幕内容。</p></li></ol><p>我们再看一下 Android / iOS 的屏幕采集能力有哪些区别。</p><ol><li><p>iOS 的 <code>ReplayKit</code> 是通过启动一个 <code>Broadcast Upload Extension</code> 子进程来采集屏幕数据，需要解决主 App 进程与屏幕采集子进程之间的通信交互问题，同时，子进程还有诸如运行时内存最大不能超过 50M 的限制。</p></li><li><p>Android 的 <code>MediaProjection</code> 是直接在 App 主进程内运行的，可以很容易获取到屏幕数据的 <code>Surface</code>。</p></li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>虽然无法避免原生代码，但我们可以尽量以最少的原生代码来实现 Flutter 屏幕采集。将两端的屏幕采集能力抽象封装为通用的 Dart 层接口，只需一次部署完成后，就能开心地在 Dart 层启动、停止屏幕采集了。</p><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a><strong>iOS</strong></h4><p>打开 <code>Runner</code> Xcode Project，新建一个 <code>Broadcast Upload Extension</code> Target，在此处理 ReplayKit 子进程的业务逻辑。</p><p>首先需要处理主 App 进程与 ReplayKit 子进程的跨进程通信问题，由于屏幕采集的 audio/video buffer 回调非常频繁，出于性能与 Flutter 插件生态考虑，在原生侧处理音视频 buffer 显然是目前最靠谱的方案，那剩下要解决的就是启动、停止信令以及必要的配置信息的传输了。</p><p>对于启动 <code>ReplayKit</code> 的操作，可以通过 Flutter 的 MethodChannel 在原生侧 new 一个 <code>RPSystemBroadcastPickerView</code>，这是一个系统提供的 View，包含一个点击后直接弹出启动屏幕采集窗口的 Button。通过遍历 Sub View 的方式找到 Button 并触发点击操作，便解决了启动 <code>ReplayKit</code> 的问题。</p><p>然后是配置信息的同步问题。</p><ul><li><p>一是使用 iOS 的 <code>App Group</code> 能力，通过 NSUserDefaults 持久化配置在进程间共享配置信息，分别在 <code>Runner</code> Target 和 <code>Broadcast Upload Extension</code> Target 内开启 App Group 能力并设置同一个 App Group ID，然后就能通过 <code>-[NSUserDefaults initWithSuiteName]</code> 读写此 App Group 内的配置了。</p></li><li><p>二是使用跨进程通知 <code>CFNotificationCenterGetDarwinNotifyCenter</code> 携带配置信息来实现进程间通信。</p></li></ul><p>接下来是停止 ReplayKit 的操作。也是使用上述的 CFNotification 跨进程通知，在 Flutter 主 App 发起结束屏幕采集的通知，ReplayKit 子进程接收到通知后调用 <code>-[RPBroadcastSampleHandler finishBroadcastWithError:]</code> 来结束屏幕采集。</p><center><img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/20201120152638.png" width="80%"></center><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a><strong>Android</strong></h4><p>启动屏幕采集时，直接通过 Flutter 的 MethodChannel 在原生侧通过 <code>MediaProjectionManager</code> 弹出一个向用户请求屏幕采集权限的弹窗，收到确认后即可调用 <code>MediaProjectionManager.getMediaProjection()</code> 函数拿到 <code>MediaProjection</code> 对象。</p><p>然后根据业务场景需求从屏幕采集 buffer 的消费者拿到 <code>Surface</code>，例如，要保存屏幕录制的话，从 <code>MediaRecoder</code> 拿到 Surface，要录屏直播的话，可调用音视频直播 SDK 的接口获取 Surface。</p><p>有了 <code>MediaProjection</code> 和消费者的 <code>Surface</code>，接下来就是调用 <code>MediaProjection.createVirtualDisplay()</code> 函数传入 Surface 来创建 <code>VirtualDisplay</code> 实例，从而获取到屏幕采集 buffer。</p><p>最后是结束屏幕采集，相比 iOS 复杂的操作，Android 仅需要将 <code>VirtualDisplay</code> 和 <code>MediaProjection</code> 实例对象释放即可。</p><h2 id="实战示例"><a href="#实战示例" class="headerlink" title="实战示例"></a>实战示例</h2><p>一个实现了 iOS/Android 屏幕采集并使用 <strong><a href="https://pub.dev/packages/zego_express_engine" target="_blank" rel="noopener">ZEGO Express Audio and Video Flutter SDK</a></strong> 进行推流直播的示例 Demo。</p><p><strong><a href="https://github.com/zegoim/zego-express-example-screen-capture-flutter" target="_blank" rel="noopener">https://github.com/zegoim/zego-express-example-screen-capture-flutter</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Flutter </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 CocoaPods trunk CDN 连接不上的问题</title>
      <link href="/2020-04-10-cocoapods-trunk-cdn-issue/"/>
      <url>/2020-04-10-cocoapods-trunk-cdn-issue/</url>
      
        <content type="html"><![CDATA[<p>CocoaPods 自 1.8 版本开始默认使用 trunk CDN (<a href="https://cdn.cocoapods.org/" target="_blank" rel="noopener">https://cdn.cocoapods.org/</a>) 作为 spec 的源，本意是非常好的，避免了需要本地 clone 一份庞大的 <a href="https://github.com/CocoaPods/Specs.git" target="_blank" rel="noopener">Specs</a> 仓库导致每次 update 都要全量更新的问题。然而不知为何国内连 trunk CDN 都被限制访问了。</p><p>常见的问题是 <code>pod install</code> 时报错 <code>CDN: trunk URL couldn&#39;t be downloaded</code> 以及 <code>pod repo update</code> 时 <code>CDN: trunk Repo update failed</code></p><p>以下是几种解决方案。</p><a id="more"></a><h2 id="安装-CocoaPods"><a href="#安装-CocoaPods" class="headerlink" title="安装 CocoaPods"></a>安装 CocoaPods</h2><p>在执行以下步骤之前，请确保已安装 CocoaPods。</p><blockquote><p>可执行 <code>pod --version</code> 检查是否有安装 CocoaPods 并查看版本号。</p></blockquote><p>安装 CocoaPods：打开终端 Terminal，执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p>请参阅 <a href="https://guides.cocoapods.org/using/getting-started.html#getting-started" target="_blank" rel="noopener">CocoaPods入门</a></p><blockquote><p>注：若根据以上入门指引，因网络问题无法下载安装 CocoaPods，可考虑使用 Ruby Gems 镜像源：</p><ul><li><p>清华 Gems 镜像站: <a href="https://mirror.tuna.tsinghua.edu.cn/help/rubygems/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/rubygems/</a></p></li><li><p>Ruby China 镜像站: <a href="https://gems.ruby-china.com" target="_blank" rel="noopener">https://gems.ruby-china.com</a></p></li></ul></blockquote><h2 id="解决连接不上-trunk-CDN-的问题"><a href="#解决连接不上-trunk-CDN-的问题" class="headerlink" title="解决连接不上 trunk CDN 的问题"></a>解决连接不上 trunk CDN 的问题</h2><h3 id="方案一：使用代理"><a href="#方案一：使用代理" class="headerlink" title="方案一：使用代理"></a>方案一：使用代理</h3><p>不管是使用旧版 CocoaPods 还是使用镜像源，都不是最优解，为了充分使用 CocoaPods 的特性，最推荐的还是使用代理来解决无法连接 trunk CDN 的问题。</p><h3 id="方案二：使用旧版-CocoaPods"><a href="#方案二：使用旧版-CocoaPods" class="headerlink" title="方案二：使用旧版 CocoaPods"></a>方案二：使用旧版 CocoaPods</h3><p>1.7.5 版本的 CocoaPods 默认使用 <a href="https://github.com/CocoaPods/Specs.git" target="_blank" rel="noopener">Specs</a> 作为 repo 源，可以卸载后重新安装旧版 CocoaPods。</p><ul><li>卸载：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem uninstall cocoapods</span><br></pre></td></tr></table></figure><ul><li>安装 CocoaPods 1.7.5：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods -v 1.7.5</span><br></pre></td></tr></table></figure><h3 id="方案三：手动切换使用官方-Git-源-镜像源"><a href="#方案三：手动切换使用官方-Git-源-镜像源" class="headerlink" title="方案三：手动切换使用官方 Git 源 / 镜像源"></a>方案三：手动切换使用官方 Git 源 / 镜像源</h3><blockquote><p>不推荐此方案，比较繁琐。</p></blockquote><ol><li><p>检查当前使用的源</p><p> 先执行 <code>pod repo list</code> 查看本机的源有哪些，如果存在一个 master 源 (<code>URL: https://github.com/CocoaPods/Specs.git</code>) 以及一个 trunk 源 (<code>URL: https://cdn.cocoapods.org/</code>)，则无需操作下面的第二步，可直接执行 <code>pod repo remove trunk</code> 删除 trunk CDN 源。</p><p> 若使用 1.9.1 或以上版本，应该只存在一个 trunk CDN 源，此时需要手动添加 Git 源</p></li><li><p>添加源</p><ul><li><p>添加 <a href="https://github.com/CocoaPods/Specs.git" target="_blank" rel="noopener">官方 CocoaPods Git 源</a></p><p>  执行 <code>pod repo add cocoapods https://github.com/CocoaPods/Specs.git</code></p></li><li><p>添加 <a href="https://mirror.tuna.tsinghua.edu.cn/help/CocoaPods/" target="_blank" rel="noopener">清华 CocoaPods 镜像源</a></p><p>  执行 <code>pod repo add tuna https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git</code></p></li></ul></li><li><p>执行 <code>pod repo update --verbose</code></p></li><li><p>在 iOS 项目根目录下的 <code>Podfile</code> 文件里指定源</p><blockquote><p>若找不到 <code>Podfile</code>，请先 <code>cd</code> 进 iOS 项目的根目录，执行 <code>pod init</code></p></blockquote><p> 往 <code>Podfile</code> 的第一行添加一句 <code>source https://xxxxx.git</code> （其中的 URL 为上一步添加的源的 URL）</p><p> 例：使用清华源</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'MyProject'</span> <span class="keyword">do</span></span><br><span class="line">  use_frameworks!</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p> 如果没有在 Podfile 里指定 source 的话，1.8 版本以上的 CocoaPods 会自动重新添加并使用 trunk CDN 源，因此每个项目的 Podfile 都需要显式指定 source，非常麻烦。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> CocoaPods </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS 使用 QuickLook 预览高亮查看任意代码源文件</title>
      <link href="/2020-04-05-make-mac-quicklook-any-code-source-file/"/>
      <url>/2020-04-05-make-mac-quicklook-any-code-source-file/</url>
      
        <content type="html"><![CDATA[<p>很多源码文件 macOS 默认不支持通过空格快速查看，比如 Flutter 的 <code>.dart</code> 文件、YAML 的 <code>.yaml</code>、<code>.yml</code>、CocoaPods 的 <code>Podfile</code>、<code>Podfile.lock</code> 等等。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/20200405170111.png" alt="dart"></p><p>就算通过右键文件，<code>显示简介</code> -&gt; <code>打开方式</code> 将其设置为全部通过 VSCode、Android Studio 等应用打开，解决了能双击文件打开的问题，也还是不能 QuickLook 快速预览。</p><p><img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/20200405170604.png" alt="vscode_dart"></p><p>普通的 <code>.h</code>、<code>.cpp</code> 等源码文件虽然系统是认识了，但没有代码高亮，看瞎眼。</p><p><img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/20200405170330.png" alt="h_file"></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>幸好有成吨的开源插件做了这些事，不用重复造轮子。</p><p>GitHub 项目链接：<a href="https://github.com/sindresorhus/quick-look-plugins" target="_blank" rel="noopener">https://github.com/sindresorhus/quick-look-plugins</a></p><p>其他关于 QuickLook Plugin 的介绍：</p><ul><li><p><a href="https://sspai.com/post/31927" target="_blank" rel="noopener">https://sspai.com/post/31927</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/57203915" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57203915</a></p></li></ul><p>关于 QuickLook 的介绍参考以上两个链接，就不再啰嗦了。</p><p>对于本文讨论的高亮预览源码文件的需求，我们可以安装 <a href="https://github.com/anthonygelibert/QLColorCode" target="_blank" rel="noopener">QLColorCode</a> 用于代码高亮、<a href="https://github.com/whomwah/qlstephen" target="_blank" rel="noopener">QLStephen</a> 用于预览无后缀名的文件。</p><p>推荐通过 Homebrew 来安装，以便集中管理。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew cask install qlcolorcode</span><br><span class="line"></span><br><span class="line">brew cask install qlstephen</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是如果 macOS 系统版本是 10.15 Catalina 及以上，安装完插件后需要额外执行一下</p><p><code>xattr -r ~/Library/QuickLook</code></p><p><code>xattr -d -r com.apple.quarantine ~/Library/QuickLook</code></p><p>以解决运行不了 QuickLook 插件的问题</p></blockquote><h2 id="添加扩展文件"><a href="#添加扩展文件" class="headerlink" title="添加扩展文件"></a>添加扩展文件</h2><p>然而即便安装了里面的 <a href="https://github.com/anthonygelibert/QLColorCode" target="_blank" rel="noopener">QLColorCode</a> 也还是没法查看这些系统不认识的文件比如 <code>.dart</code>，此时可修改一下这个插件的配置文件使其支持</p><p>打开 <code>~/Library/QuickLook/QLColorCode.qlgenerator/Contents/Info.plist</code> 文件</p><p>找到 <code>Document types &gt; Item 0 &gt; Document Content Type UTIs (CFBundleDocumentTypes &gt; Item 0 &gt; LSItemContentTypes</code></p><p><img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/20200405172403.png" alt="plist"></p><p>点击➕添加一行 <code>.dart</code> 文件格式，如上图所示</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.apple.disk-image-dart</span><br></pre></td></tr></table></figure><p>保存后即生效，其他类型文件也可通过这个方法来快速预览。</p><p>然而如何查看具体某种文件格式的类型呢？</p><p>通过这条命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdls -name kMDItemContentType ./main.dart</span><br></pre></td></tr></table></figure><p>就能得到传入的文件类型了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kMDItemContentType = <span class="string">"com.apple.disk-image-dart"</span></span><br></pre></td></tr></table></figure><p>把常见的源码文件都添加进 <code>~/Library/QuickLook/QLColorCode.qlgenerator/Contents/Info.plist</code>，生产效率大大提高💪</p><p><img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/20200405173836.png" alt="dart"></p><p><img src="https://raw.githubusercontent.com/patrick-fu/personal_blog_image/master/image/20200405173841.png" alt="h"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://medium.com/@claudmarotta/how-to-preview-dart-files-with-macos-quick-look-54779340811f" target="_blank" rel="noopener">https://medium.com/@claudmarotta/how-to-preview-dart-files-with-macos-quick-look-54779340811f</a></p></li><li><p><a href="https://github.com/anthonygelibert/QLColorCode" target="_blank" rel="noopener">https://github.com/anthonygelibert/QLColorCode</a></p></li><li><p><a href="https://github.com/whomwah/qlstephen/issues/81#issuecomment-582365549" target="_blank" rel="noopener">https://github.com/whomwah/qlstephen/issues/81#issuecomment-582365549</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> QuickLook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SwiftUI】解决 NavigationLink 立即加载 destination View 的问题（实现懒加载）</title>
      <link href="/2020-03-23-swiftui-navigationlink-destination-not-lazy/"/>
      <url>/2020-03-23-swiftui-navigationlink-destination-not-lazy/</url>
      
        <content type="html"><![CDATA[<p>在 SwiftUI 中，一般通过 <code>NavigationView</code> 配合 <code>NavigationLinks</code> 来实现页面间的跳转，可类比为 UIKit 中的 <code>UINavigationController</code> 与 <code>segue</code>（或者 push/present 语句）。熟悉 UIKit 的开发者刚接触 SwiftUI 时可能会遇到一个小坑：<code>NavigationLinks</code> 的 <code>destination</code> 并不是懒加载的。</p><a id="more"></a><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><code>NavigationLinks</code> 与 UIKit 中 push/present 之间的行为差异导致刚上手 SwiftUI 时，由于不知道目标 View 会被提前加载，使得目标 View 里的业务逻辑时序上出现问题。</p><p>我们都知道，<code>UINavigationController</code> 的目标 ViewController 只在调用了 push/present 后才会触发常用的加载方法 <code>viewDidLoad()</code>。</p><p>然而在 SwiftUI 中，<code>NavigationLinks</code> 的目标 View 会立即加载，这意味着假设有一个包含 100 个 cell 的 <code>List</code>/<code>ForEach</code>，其中每个 cell 都是用 <code>NavigationLinks</code> 来跳转新页面的话，那当加载显示这个 <code>List</code> 时，内存中会马上创建 100 个对应的 View 结构体。</p><p>如果这些 View 的构造函数中还做了些开销大的操作比如网络请求、加载资源等。。。可以想象将导致什么后果🤣</p><blockquote><p>例：</p></blockquote><p>如下所示，<code>MyRootView</code> 是首页 View，通过 <code>NavigationView</code> 来实现路由导航功能，其中是一个包含了三个 cell 的 <code>List</code>，每个 cell 是一个 <code>NavigationLinks</code>，分别导航至 <code>FirstView</code>、<code>SecondView</code>、<code>ThirdView</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyRootView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> myViews = [</span><br><span class="line">        <span class="string">"FirstView"</span>,</span><br><span class="line">        <span class="string">"SecondView"</span>,</span><br><span class="line">        <span class="string">"ThirdView"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">containedView</span><span class="params">(viewName: String)</span></span> -&gt; <span class="type">AnyView</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> viewName &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"FirstView"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">AnyView</span>(<span class="type">FirstView</span>())</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"SecondView"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">AnyView</span>(<span class="type">SecondView</span>())</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ThirdView"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">AnyView</span>(<span class="type">ThirdView</span>())</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">AnyView</span>(<span class="type">Text</span>(<span class="string">"None"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">List</span>(myViews, id: \.<span class="keyword">self</span>) &#123; viewName <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span>(destination: <span class="keyword">self</span>.containedView(viewName: viewName)) &#123;</span><br><span class="line">                    <span class="type">Text</span>(viewName)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .navigationBarTitle(<span class="type">Text</span>(<span class="string">"ZegoExpressExample"</span>), displayMode: .automatic)</span><br><span class="line">            .onAppear &#123;</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"🚩 MyRootView appear"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在 <code>FirstView</code>、<code>SecondView</code>、<code>ThirdView</code> 的实现中，View 结构体里包含一个 class 实例属性，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FirstView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> firstCoordinator = <span class="type">FirstCoordinator</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"1️⃣ FirstView init 🟢"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"I'm FirstView created by Patrick Fu"</span>)</span><br><span class="line">            .onAppear &#123;</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"---------1️⃣ FirstView appear-------"</span>)</span><br><span class="line">            &#125;.onDisappear &#123;</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"---------1️⃣ FirstView disappear-------"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FirstCoordinator</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"1️⃣ FirstCoordinator init 🟢"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">deinit</span> &#123;</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"1️⃣ FirstCoordinator deinit 🔴"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SecondView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> secondCoordinator = <span class="type">SecondCoordinator</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"2️⃣ SecondView init 🟢"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"I'm SecondView created by Patrick Fu"</span>)</span><br><span class="line">            .onAppear &#123;</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"---------2️⃣ SecondView appear-------"</span>)</span><br><span class="line">            &#125;.onDisappear &#123;</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"---------2️⃣ SecondView disappear-------"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SecondCoordinator</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"2️⃣ SecondCoordinator init 🟢"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">deinit</span> &#123;</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"2️⃣ SecondCoordinator deinit 🔴"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ThirdView 的实现完全一致，就不贴出来了</p></blockquote><p>测试一下，通过日志可以发现，当加载显示 <code>MyRootView</code> 的时候，通过 <code>NavigationLinks</code> 导航的目标 View 全部被提前立即初始化了，并且其属性 Coordinator 类也被实例化了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-03-23 01:10:46.546218+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 🚩 MyRootView appear</span><br><span class="line">2020-03-23 01:10:46.553204+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 1️⃣ FirstCoordinator init 🟢</span><br><span class="line">2020-03-23 01:10:46.553234+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 1️⃣ FirstView init 🟢</span><br><span class="line">2020-03-23 01:10:46.558073+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 2️⃣ SecondCoordinator init 🟢</span><br><span class="line">2020-03-23 01:10:46.558104+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 2️⃣ SecondView init 🟢</span><br><span class="line">2020-03-23 01:10:46.559791+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 3️⃣ ThirdCoordinator init 🟢</span><br><span class="line">2020-03-23 01:10:46.559808+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 3️⃣ ThirdView init 🟢</span><br><span class="line">2020-03-23 01:11:03.746197+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------1️⃣ FirstView appear-------</span><br><span class="line">2020-03-23 01:11:06.641696+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 🚩 MyRootView appear</span><br><span class="line">2020-03-23 01:11:06.892756+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------1️⃣ FirstView disappear-------</span><br><span class="line">2020-03-23 01:11:08.618983+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------2️⃣ SecondView appear-------</span><br><span class="line">2020-03-23 01:11:11.507952+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 🚩 MyRootView appear</span><br><span class="line">2020-03-23 01:11:11.680365+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------2️⃣ SecondView disappear-------</span><br><span class="line">2020-03-23 01:11:13.138151+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------3️⃣ ThirdView appear-------</span><br><span class="line">2020-03-23 01:11:15.317203+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 🚩 MyRootView appear</span><br><span class="line">2020-03-23 01:11:15.488869+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------3️⃣ ThirdView disappear-------</span><br></pre></td></tr></table></figure><p>并且在右滑返回主页面时，View 和其 Coordinator 类实例也并没有被释放，GG~</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>首先，<code>NavigationLinks</code> 立即加载 <code>destination</code> 的现象应该是 SwiftUI 的 Feature。因为在 SwiftUI 中，View 是非常轻量化的结构体，类似于 Flutter 中的 <code>Widget</code>，创建、销毁的开销非常低。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>因此，其中一种解决方案就是充分利用 View 的 <code>onAppear()</code> 和 <code>onDisappear()</code> 作为依赖注入来实现自己的业务逻辑和一些开销大的操作，避免在 View 初始化的时机做业务逻辑。也就是说，把 View 的 <code>onAppear()</code> 当做 UIKit 中的 <code>viewDidLoad()</code> 来使用，并且避免在 View 的属性中直接初始化开销大的对象。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>当然了，作为老 UIKit/AppKit 开发者，大量的对象瞬间全部加载实在难顶，还是得懒加载才行。</p><p>那另一种解决方案就是通过给 <code>destination</code> 的 View 包裹一层自定义的 View 来实现懒加载功能。</p><ul><li>LazyView.swift</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">LazyView</span>&lt;<span class="title">Content</span>: <span class="title">View</span>&gt;: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> build: () -&gt; <span class="type">Content</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> build: <span class="meta">@autoclosure</span> @escaping () -&gt; <span class="type">Content</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.build = build</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> body: <span class="type">Content</span> &#123;</span><br><span class="line">        build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 View 的 body 属性只在这个 View 被显示出来的时候才会被执行，也就是说，当 body 中的 <code>NavigationLinks</code> 的 <code>destination</code> 是另一个 ViewB 时，这个 <code>destination</code> 的 ViewB 会被马上初始化，但是 ViewB 的 body 属性不会被执行。</p><p>换句话说，SwiftUI 会立刻加载<strong>当前层级</strong>以及<strong>下一层级</strong>的 View，但<strong>不会</strong>加载第三层级的 View。</p><p>因此，用一个自定义 View 来包裹住真正想要跳转的目标 View，就可以变相的实现懒加载。</p><p>实际上，此方案只是“懒加载”了目标 View，在一个拥有大量 cell 的 <code>List</code>/<code>ForEach</code> 中，还是会有等同数量的 <code>LazyView</code> 被创建。</p><p>这种方式并不 Swifty，目前看来，最好还是按照 SwiftUI 的设计理念来做业务逻辑，也就是上面的方案一。</p><ul><li>用法示例</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">NavigationLink</span>(destination: <span class="type">LazyView</span>(<span class="type">Text</span>(<span class="string">"My details page"</span>))) &#123;</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Go to details"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的 <code>MyRootView</code> 的 body 如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">NavigationView</span> &#123;</span><br><span class="line">        <span class="type">List</span>(myViews, id: \.<span class="keyword">self</span>) &#123; viewName <span class="keyword">in</span></span><br><span class="line">            <span class="type">NavigationLink</span>(destination: <span class="type">LazyView</span>(<span class="keyword">self</span>.containedView(viewName: viewName))) &#123;</span><br><span class="line">                <span class="type">Text</span>(viewName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .navigationBarTitle(<span class="type">Text</span>(<span class="string">"ZegoExpressExample"</span>), displayMode: .automatic)</span><br><span class="line">        .onAppear &#123;</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"🚩 MyRootView appear"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，当加载显示 <code>MyRootView</code> 时，通过 <code>NavigationLinks</code> 导航的目标 View 都实现了懒加载，并且在返回 <code>MyRootView</code> 并进入其他新的 View 时，上一个老 View 也能被释放，这就非常舒服了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2020-03-23 01:32:12.577138+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 🚩 MyRootView appear</span><br><span class="line">2020-03-23 01:32:26.788288+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 1️⃣ FirstCoordinator init 🟢</span><br><span class="line">2020-03-23 01:32:26.788380+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 1️⃣ FirstView init 🟢</span><br><span class="line">2020-03-23 01:32:26.811396+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------1️⃣ FirstView appear-------</span><br><span class="line">2020-03-23 01:32:57.753106+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 🚩 MyRootView appear</span><br><span class="line">2020-03-23 01:32:57.969867+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------1️⃣ FirstView disappear-------</span><br><span class="line">2020-03-23 01:33:00.826847+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 2️⃣ SecondCoordinator init 🟢</span><br><span class="line">2020-03-23 01:33:00.826983+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 2️⃣ SecondView init 🟢</span><br><span class="line">2020-03-23 01:33:00.831038+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 1️⃣ FirstCoordinator deinit 🔴</span><br><span class="line">2020-03-23 01:33:00.850590+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------2️⃣ SecondView appear-------</span><br><span class="line">2020-03-23 01:33:04.745348+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 🚩 MyRootView appear</span><br><span class="line">2020-03-23 01:33:05.011015+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------2️⃣ SecondView disappear-------</span><br><span class="line">2020-03-23 01:33:06.126583+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 3️⃣ ThirdCoordinator init 🟢</span><br><span class="line">2020-03-23 01:33:06.126716+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 3️⃣ ThirdView init 🟢</span><br><span class="line">2020-03-23 01:33:06.130353+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 2️⃣ SecondCoordinator deinit 🔴</span><br><span class="line">2020-03-23 01:33:06.149465+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------3️⃣ ThirdView appear-------</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://twitter.com/chriseidhof/status/1144242544680849410" target="_blank" rel="noopener">https://twitter.com/chriseidhof/status/1144242544680849410</a></p></li><li><p><a href="https://stackoverflow.com/questions/57594159/swiftui-navigationlink-loads-destination-view-immediately-without-clicking" target="_blank" rel="noopener">https://stackoverflow.com/questions/57594159/swiftui-navigationlink-loads-destination-view-immediately-without-clicking</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解 YUV 格式（I420/YUV420/NV12/NV12/YUV422）</title>
      <link href="/2020-01-26-yuv-pixel-formats/"/>
      <url>/2020-01-26-yuv-pixel-formats/</url>
      
        <content type="html"><![CDATA[<p><code>YUV</code> （<code>Y&#39;CbCr</code>）是一种像素格式，常见于视频编码与静态图像。与 <code>RGB</code> 格式（红-绿-蓝）相反，YUV 分别由一个称为 <code>Y</code>（相当于灰度）的“亮度”分量（Luminance or Luma）和两个称为 <code>U</code>（蓝色投影 <code>Cb</code>）和 <code>V</code>（红色投影 <code>Cr</code>）的“色度”分量（Chrominance or Chroma）表示，由此得名。</p><p>仅有 Y 分量而没有 UV 分量信息，一样可以显示完整的黑白（灰度）图像，解决了模拟信号电视黑白与彩色的兼容问题。</p><a id="more"></a><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>色度通道（UV）的采样率可以低于亮度通道（Y），而不会显着降低感知质量。一种称为 “A:B:C” 的表示法用于描述相对于 Y 采样， U 和 V 的频率：</p><ul><li>4:4:4 表示不降低色度（UV）通道的采样率。每个 Y 分量对应一组 UV 分量。</li><li>4:2:2 表示 2:1 水平下采样，没有垂直下采样。每两个 Y 分量共享一组 UV 分量。</li><li>4:2:0 表示 2:1 水平下采样，同时 2:1 垂直下采样。每四个 Y 分量共享一组 UV 分量。</li><li>4:1:1 表示 4:1 水平下采样，没有垂直下采样。每四个 Y 分量共享一组 UV 分量。4:1:1 采样比其他格式少见，本文不再详细讨论。</li></ul><p>下图显示了如何针对每个下采样率采样色度。亮度样本用十字表示，色度样本用圆圈表示。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212164150.png" alt="YUV Sampling"></p><h2 id="存储格式"><a href="#存储格式" class="headerlink" title="存储格式"></a>存储格式</h2><p>YUV 在存储上通常分为平面格式（<code>Planar</code>），半平面格式（<code>Semi-Planar</code>）以及打包格式（<code>Packed</code>）。</p><h3 id="Planar-平面格式"><a href="#Planar-平面格式" class="headerlink" title="Planar 平面格式"></a>Planar 平面格式</h3><p>平面格式有时也称为三面格式（<code>Triplanar</code>），即 Y, U, V 三个分量各自使用单独的数组保存，这种三平面分离的格式比较方便视频编码。</p><h4 id="YU12-I420"><a href="#YU12-I420" class="headerlink" title="YU12 (I420)"></a>YU12 (I420)</h4><ul><li>4:2:0 Formats, 12 Bits per Pixel, 3 Planars</li></ul><blockquote><p><a href="http://www.fourcc.org/pixel-format/yuv-i420/" target="_blank" rel="noopener">FOURCC I420</a></p></blockquote><p><code>YU12</code> 即 <code>I420</code>，也叫 <code>IYUV</code>，属于 <code>YUV420P</code> 格式。三个平面，分别存储 Y U V 分量。每四个 Y 分量共享一组 UV 分量。U、V 平面的 strides, width 和 height 都是 Y 平面的一半，因此一个像素 12 bits，内存排列如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212182646.png" alt="YU12 Format"></p><p>从图中可看出，U、V 平面的每行字节数（strides）、高（height）都是 Y 平面的一半。</p><p><code>I420</code> 是音视频开发中常用的一种格式。</p><h4 id="YV12"><a href="#YV12" class="headerlink" title="YV12"></a>YV12</h4><ul><li>4:2:0 Formats, 12 Bits per Pixel, 3 Planars</li></ul><blockquote><p><a href="http://www.fourcc.org/pixel-format/yuv-yv12/" target="_blank" rel="noopener">FOURCC YV12</a></p></blockquote><p><code>YV12</code> 与 <code>I420</code> 几乎一样，仅改变了 U, V 平面的顺序。内存排列如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212181507.png" alt="YU12 Format"></p><h4 id="J420"><a href="#J420" class="headerlink" title="J420"></a>J420</h4><ul><li>4:2:0 Formats, 12 Bits per Pixel, 3 Planars</li></ul><p><code>J420</code> 与 <code>I420</code> 完全相同，但具有完整范围（0-255，full range）的亮度（Y）分量，而不是有限范围（16-240，limited range，在 iOS 上也叫做 video range）。色度（UV）分量与 I420 中的完全相同。</p><h4 id="IMC1"><a href="#IMC1" class="headerlink" title="IMC1"></a>IMC1</h4><ul><li>4:2:0 Formats, 16 Bits per Pixel, 3 Planars</li></ul><blockquote><p><a href="http://www.fourcc.org/pixel-format/yuv-imc1/" target="_blank" rel="noopener">FOURCC IMC1</a></p></blockquote><p><code>IMC1</code> 与 <code>I420</code> 类似，U, V 平面的宽（width）、高（height）是 Y 平面的一半，但是每行字节数（strides）与 Y 平面一致，因此 U, V 平面在内存上会有留空（padding），因此一个像素 16 bits，如图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212193133.png" alt="IMC1 Format"></p><h4 id="IMC3"><a href="#IMC3" class="headerlink" title="IMC3"></a>IMC3</h4><ul><li>4:2:0 Formats, 16 Bits per Pixel, 3 Planars</li></ul><p><code>IMC3</code> 与 <code>IMC1</code> 几乎一样，仅改变了 U, V 平面的顺序。内存排列如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212202002.png" alt="IMC3 Format"></p><h4 id="I422"><a href="#I422" class="headerlink" title="I422"></a>I422</h4><ul><li>4:2:2 Formats, 16 Bits per Pixel, 3 Planars</li></ul><p><code>I422</code> 属于 <code>YUV422P</code> 格式。三个平面，分别存储 Y U V 分量。每两个 Y 分量共享一组 UV 分量。U、V 平面的 strides, width 是 Y 平面的一半，但 height 与 Y 平面一致，因此一个像素 16 bits，内存排列如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212232724.png" alt="YUV422P"></p><p>从图中可看出，U、V 平面的每行字节数（strides）是 Y 平面的一半，高（height）与 Y 平面一致。</p><h4 id="J422"><a href="#J422" class="headerlink" title="J422"></a>J422</h4><ul><li>4:2:2 Formats, 16 Bits per Pixel, 3 Planars</li></ul><p><code>J422</code> 与 <code>I422</code> 完全相同，但具有完整范围（0-255，full range）的亮度（Y）分量，而不是有限范围（16-240，limited range，在 iOS 上也叫做 video range）。色度（UV）分量与 I420 中的完全相同。</p><h3 id="Semi-Planar-半平面格式"><a href="#Semi-Planar-半平面格式" class="headerlink" title="Semi-Planar 半平面格式"></a>Semi-Planar 半平面格式</h3><p>半平面格式具有两个平面而不是三个平面，一个平面存储亮度（Y）分量，另一个平面存储两个色度（UV）分量。有时也将它们称为双平面格式（<code>BiPlanar</code>）。</p><h4 id="NV12"><a href="#NV12" class="headerlink" title="NV12"></a>NV12</h4><ul><li>4:2:0 Formats, 12 Bits per Pixel, 2 Planars</li></ul><blockquote><p><a href="http://www.fourcc.org/pixel-format/yuv-nv12/" target="_blank" rel="noopener">FOURCC NV12</a></p></blockquote><p><code>NV12</code> 属于 <code>YUV420SP</code> 格式。两个平面，分别存储 Y 分量 和 UV 分量。其中 UV 分量共用一个平面并且以 U, V, U, V 的顺序交错排列。每四个 Y 分量共享一组 UV 分量。</p><p>UV 平面的 strides, width 与 Y 平面一样长，但 height 仅为 Y 平面的一半。因此一个像素 12 bits，内存排列如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212234845.png" alt="NV12 Format"></p><p>从图中可看出，UV 平面的每行字节数（strides）与 Y 平面一致，高（height）是 Y 平面的一半。</p><p><code>NV12</code> 是 iOS 相机（<code>AVCaptureOutput</code>）可直接输出的两种视频帧格式之一，另外一种是 <code>BGRA32</code>(<code>kCVPixelFormatType_32BGRA</code>)。</p><p>在 iOS 上，<code>NV12</code> 还分为 Full Range (0-255, <code>kCVPixelFormatType_420YpCbCr8BiPlanarFullRange</code>) 和 Video Range (16-240, <code>kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange</code>)，区别仅为亮度（Y）分量的取值范围，一般而言，Full Range 适用于静态图像（拍照），Video Range 适用于视频采集（摄像）。</p><h4 id="NV21"><a href="#NV21" class="headerlink" title="NV21"></a>NV21</h4><ul><li>4:2:0 Formats, 12 Bits per Pixel, 2 Planars</li></ul><blockquote><p><a href="http://www.fourcc.org/pixel-format/yuv-nv21/" target="_blank" rel="noopener">FOURCC NV21</a></p></blockquote><p><code>NV21</code> 属于 <code>YUV420SP</code>，与 <code>NV12</code> 几乎一致，区别是 UV 平面中 U 与 V 的排列顺序颠倒，以 V, U, V, U 的顺序交错排列，内存排列如图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212235436.png" alt="NV21 Format"></p><p><code>NV21</code> 是 Android 相机（<code>Camera</code>）默认的输出格式。</p><h3 id="Packed-打包格式"><a href="#Packed-打包格式" class="headerlink" title="Packed 打包格式"></a>Packed 打包格式</h3><p>打包格式通常只有一个平面，所有亮度（Y）和色度（UV）数据都交织在一起。有点类似于 RGB 格式，只是使用了不同的色彩空间。</p><p>打包格式在网络摄像头中较为常见。硬件设备使用多平面格式效率较低，因为每个像素需要多次内存访问。而打包格式由于仅一个平面，访问内存的开销较小。</p><h4 id="AYUV"><a href="#AYUV" class="headerlink" title="AYUV"></a>AYUV</h4><ul><li>4:4:4 Formats, 32 Bits per Pixel</li></ul><blockquote><p><a href="http://www.fourcc.org/pixel-format/yuv-ayuv/" target="_blank" rel="noopener">FOURCC AYUV</a></p></blockquote><p>AYUV 是 Packed 打包格式，其中每个像素编码为四个连续字节，每个像素在内存中按照 V, U, Y, A 的顺序排列（A 指 alpha 通道），如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212165800.png" alt="AYUV Format"></p><h4 id="YUYV-V422-YUY2-YUNV"><a href="#YUYV-V422-YUY2-YUNV" class="headerlink" title="YUYV (V422 / YUY2 / YUNV)"></a>YUYV (V422 / YUY2 / YUNV)</h4><ul><li>4:2:2 Formats, 16 Bits per Pixel</li></ul><blockquote><p><a href="http://www.fourcc.org/pixel-format/yuv-yuy2/" target="_blank" rel="noopener">FOURCC YUY2</a></p></blockquote><p><code>YUYV</code> 通常也称作 <code>V422</code>、<code>YUY2</code>、<code>YUNV</code></p><p>YUY2 是 Packed 打包格式，其中两个像素共用一组 UV 分量，内存中按照 Y U Y V 的顺序排列，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212171116.png" alt="YUYV Format"></p><h4 id="UYVY-Y422-UYNV"><a href="#UYVY-Y422-UYNV" class="headerlink" title="UYVY (Y422 / UYNV)"></a>UYVY (Y422 / UYNV)</h4><ul><li>4:2:2 Formats, 16 Bits per Pixel</li></ul><blockquote><p><a href="https://www.fourcc.org/pixel-format/yuv-uyvy/" target="_blank" rel="noopener">FOURCC UYVY</a></p></blockquote><p><code>UYVY</code> 通常也称作 <code>Y422</code>、<code>UYNV</code></p><p><code>UYVY</code> 与 <code>YUYV</code> 类似，只是亮度（Y）分量与色度（UV）分量排列顺序颠倒，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20200212172050.png" alt="UYVY Format"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://docs.microsoft.com/en-us/windows/win32/medfound/recommended-8-bit-yuv-formats-for-video-rendering" target="_blank" rel="noopener">Microsoft: Recommended 8-Bit YUV Formats for Video Rendering</a></p></li><li><p><a href="https://wiki.videolan.org/YUV#Semi-planar" target="_blank" rel="noopener">VideoLAN’s Wiki: YUV</a></p></li><li><p><a href="https://www.fourcc.org/yuv.php" target="_blank" rel="noopener">FOURCC: YUV pixel formats</a></p></li><li><p><a href="https://developer.apple.com/videos/play/wwdc2011/419/?time=1527" target="_blank" rel="noopener">WWDC2011: Capturing from the Camera using AV Foundation on iOS 5</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Audio/Video </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈网络协议之种子与P2P</title>
      <link href="/2019-07-07-network-protocol-p2p/"/>
      <url>/2019-07-07-network-protocol-p2p/</url>
      
        <content type="html"><![CDATA[<p>最近学了些P2P协议相关的内容，做了些笔记。</p><a id="more"></a><h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p>P2P 即 peer-to-peer，为了解决 HTTP 或 FTP 下载文件时难以解决单一服务器带宽压力的缺点。P2P 的特点是资源开始并不集中地存储在某些设备上，而是分散地存储在多台设备上，而是分散地存储在多台设备上。这些设备我们姑且称为 peer。</p><p>想要下载一个文件的时候，只需得到那些已经存在了文件的 peer，并和这些 peer 之间，建立点对点的连接，而不需要到中心服务器上，就可以就近下载文件。一旦下载了文件，你也就成为 peer 中的一员，你旁边的那些机器，也可能会选择从你这里下载文件，所以当你使用 P2P 软件的时候，例如 BitTorrent，往往能够看到，既有下载流量，也有上传的流量，也即你自己也加入了这个 P2P 的网络，自己从别人那里下载，同时也提供给其他人下载。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190708180237.png" alt></p><p>美国工程师 Bram Cohen 在 2001 年发布了 BitTorrent 协议，资源不再由一个人或一个中心服务器提供，而是所有人提供给所有人，下载的人越多，速度越快。</p><p>BitTorrent 的核心思想是把文件分成很多个小块，让下载者互相连接。协议需要资源共享者生成一个包含下载信息的种子文件，后缀是 .torrent，即 BT 种子。</p><h2 id="torrent"><a href="#torrent" class="headerlink" title="torrent"></a>torrent</h2><p>.torrent 种子文件由两部分组成，分别是：announce（tracker URL）和文件信息</p><p>文件信息包含文件的名字、大小，分块后每块文件的大小、哈希值等，具体如下：</p><ul><li>info 区：指定的是种子文件数量、文件大小、目录结构、目录和文件的名字</li><li>Name 字段：指定顶层目录名字。</li><li>每个段的大小：BitTorrent 协议把文件分成很多个小段</li><li>段哈希值：整个种子中，每个段的 SHA-1 哈希值拼在一起</li></ul><p>下载时，BT 客户端首先解析.torrent 文件，得到 Tracker 地址，然后连接 Tracker 服务器。</p><p>Tracker 很重要，通过 Tracker 我们才能找到其他下载者的联系方式。当你用下载软件打开种子，就会开始联系种子文件里内置的 Tracker 服务器，告诉 Tracker 我要下载这个文件，服务器会记录下你的 IP，并把其他正在下载或下载完成的人的 IP 返回给你，这样你们就可以愉快的组队下载了。</p><p>Tracker 服务器回应下载者请求，将其他下载者包括发布者的 IP 提供给下载者。下载者再连接其他下载者，根据种子文件，双方互相告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，并分散了单个线路上的数据流量，减轻服务器负担。</p><p>下载者每得到一个块，需要算出下载块的 Hash 验证码，并与.torrent 文件中的对比。如果一样，则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容的准确性问题。</p><p>当然，如果没有找到正在下载的人，资源发布者也不在线，你就只能以 0kb/s 的速度等着了。</p><p>不难发现，Tracker 服务器是 P2P 网络的弱点，如果 Tracker 被关闭或封禁，你就无法找到同伴，也难以完成下载，BT 依然是中心化的协议。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190708180236.png" alt></p><h2 id="DHT-去中心化网络"><a href="#DHT-去中心化网络" class="headerlink" title="DHT 去中心化网络"></a>DHT 去中心化网络</h2><p>为了摆脱对 Tracker 服务器的依赖，彻底去中心化，于是产生了一种叫做 DHT（Distributed Hash Table）的去中心化网络，每个加入 DHT 网络的人，都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190708180234.png" alt></p><p>DHT 的本质是把所有人都变成一个小型 Tracker，每个人都拿着一份动态更新的地址和文件信息。我找与我连接的 10 个人，他们再各自找 10 个人，一传十十传百、千、万，最后我通过N个人的中转，找到应该连上的人。</p><p>有一种著名的 DHT 协议：Kademlia。任何一个 BitTorrent 启动之后，它都有两个角色。一个是 peer，监听一个 TCP 端口，用来上传和下载文件，这个角色表明，我这里有某个文件。另一个角色 DHT node，监听一个 UDP 的端口，通过这个角色，这个节点加入了一个 DHT 的网络。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190708181046.jpg" alt></p><p>在 DHT 网络中，每个 DHT node 都有一个很长的 ID 字符串。每个 DHT node 都有责任掌握一些知识，即文件索引，即它应该知道某些文件是保存在哪些节点上。它只需要有这些知识就行，自己本身不一定就是保存这个文件的节点。node 应该知道哪些知识是通过哈希算法计算出来。</p><p>每个文件都有一串通过 SHA1 哈希算法计算出唯一的文件 ID，可以产生 2 的 (4*40) 即 2 的 160 次方种组合，用只有 0 和 1 的二进制表示就是 160 个 0 和 1。</p><p>而每个节点也有一串 160 位的 0 和 1，作为节点 ID。根据这 160 位数，我们可以计算节点和节点之间，节点和资源之间的距离。</p><p>在 Kademlia 网络中，距离是通过异或（XOR）计算的。以5位举例，01010 与 01000 的距离，就是两个 ID 之间的异或值，为 00010，也即为 2。 01010 与 00010 的距离为 01000，也即为 8。01010 与 00011 的距离为 01001，也即 8+1=9。以此类推，高位不同的，表示距离更远一些；低位不同的，表示距离更近一些，总的距离为所有的不同的位的距离之和。</p><p>有个理论是，社交网络中，任何两个人直接的距离不超过六度，也即你想联系比尔盖茨，也就六个人就能够联系到了。</p><p>假设小明发布了一个文件，就能计算他所知道的节点 ID 与这个文件 ID 的距离，让算出来最距离最短的节点再计算它知道的节点和文件 ID 的距离，重复这个过程，就能找到与文件 ID 的距离最短的一批节点 ID，把小明提供的下载信息存在这里。</p><p>这样，下载者也只要找到和文件 ID 距离接近的节点 ID，就能建立连接，开始下载。</p><h4 id="DHT-网络如何维护"><a href="#DHT-网络如何维护" class="headerlink" title="DHT 网络如何维护"></a>DHT 网络如何维护</h4><p>就像人一样，虽然我们常联系人的只有少数，但是朋友圈里肯定是远近都有。DHT 网络的朋友圈也是一样，远近都有，并且按距离分层。</p><p>假设某个节点的 ID 为 01010，如果一个节点的 ID，前面所有位数都与它相同，只有最后 1 位不同。这样的节点只有 1 个，为 01011。与基础节点的异或值为 00001，即距离为 1；对于 01010 而言，这样的节点归为“k-bucket 1”。</p><p>如果一个节点的 ID，前面所有位数都相同，从倒数第 2 位开始不同，这样的节点只有 2 个，即 01000 和 01001，与基础节点的异或值为 00010 和 00011，即距离范围为 2 和 3；对于 01010 而言，这样的节点归为“k-bucket 2”。</p><p>如果一个节点的 ID，前面所有位数相同，从倒数第 i 位开始不同，这样的节点只有 2^(i-1) 个，与基础节点的距离范围为 [2^(i-1), 2^i)；对于 01010 而言，这样的节点归为“k-bucket i”。</p><p>最终到从倒数 160 位就开始都不同。差距越大，陌生人越多，但是朋友圈不能都放下，所以每一层都只放 K 个，这是参数可以配置。</p><h4 id="DHT-网络节点的查找"><a href="#DHT-网络节点的查找" class="headerlink" title="DHT 网络节点的查找"></a>DHT 网络节点的查找</h4><p>假设，node A 的 ID 为 00110，要找 node B ID 为 10000，异或距离为 10110，距离范围在 [2^4, 2^5)，所以这个目标节点可能在“k-bucket 5”中，这就说明 B 的 ID 与 A 的 ID 从第 5 位开始不同，所以 B 可能在“k-bucket 5”中。</p><p>然后，A 看看自己的 k-bucket 5 有没有 B。如果有就找到了；如果没有，在 k-bucket 5 里随便找一个 C。因为是二进制，C、B 都和 A 的第 5 位不同，那么 C 的 ID 第 5 位肯定与 B 相同，即它与 B 的距离会小于 2^4，相当于比A、B 之间的距离缩短了一半以上。</p><p>再请求 C，在它自己的通讯录里，按同样的查找方式找一下 B。如果 C 知道 B，就告诉 A；如果 C 也不知道 B，那 C 按同样的搜索方法，可以在自己的通讯录里找到一个离 B 更近的 D 朋友（D、B 之间距离小于 2^3），把 D 推荐给 A，A 请求 D 进行下一步查找。</p><p>Kademlia 的这种查询机制，是通过折半查找的方式来收缩范围，对于总的节点数目为 N，最多只需要查询 log2(N) 次，就能够找到。</p><h4 id="DHT-网络节点之间的沟通"><a href="#DHT-网络节点之间的沟通" class="headerlink" title="DHT 网络节点之间的沟通"></a>DHT 网络节点之间的沟通</h4><p>Kademlia 算法中，每个节点只有 4 个指令。</p><ul><li>PING：测试一个节点是否在线。</li><li>STORE：要求一个节点存储一份数据。</li><li>FIND_NODE：根据节点 ID 查找一个节点</li><li>FIND_VALUE：根据 KEY 查找一个数据，与 FIND_NODE 类似</li></ul><h4 id="DHT-网络的更新"><a href="#DHT-网络的更新" class="headerlink" title="DHT 网络的更新"></a>DHT 网络的更新</h4><p>每个 bucket 里的节点，都按最后一次接触的时间倒序排列，这就相当于，朋友圈里面最近联系过的人往往是最熟的。</p><p>每次执行四个指令中的任意一个都会触发更新。</p><p>当一个节点与自己接触时，检查它是否已经在 k-bucket 中，也就是说是否已经在朋友圈。如果在，那么将它挪到 k-bucket 列表的最底，也就是最新的位置，刚联系过，就置顶一下，方便以后多联系；如果不在，新的联系人要不要加到通讯录里面呢？假设通讯录已满的情况，PING 一下列表最上面，也即最旧的一个节点。如果 PING 通了，将旧节点挪到列表最底，并丢弃新节点，老朋友还是留一下；如果 PING 不通，删除旧节点，并将新节点加入列表，这人联系不上了，删了吧。</p><p>这个机制保证了任意节点加入和离开都不影响整体网络。</p><h2 id="磁力链接"><a href="#磁力链接" class="headerlink" title="磁力链接"></a>磁力链接</h2><p>今天最流行的下载方式是磁力链接（Magnet URI scheme）就是基于 DHT 网络的，通常是一串这样的神秘代码：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190708180235.png" alt></p><p>前面都是标准格式，最重要的是这 40 个 16 进制的数字即 160 位 2 进制数字。任何文件丢进 SHA1 哈希算法都能得到一串这样字符，40 位、16 进制、只属于这个文件，它能帮我们找到我们要下载的东西。</p><p>根据上面讲的 DHT，只需要一串文件 ID 和存储在本地的 K 桶数据，你就可以高效的找到要下载的文件。而资源的发布者和传播者也只需要分享 40 个数字就好，足够简单，方便和隐私。</p><p>在真实的 DHT 网络，每个 K 桶至少记录了 8 个节点，任何一个节点下线，都不会影响整个网络的运行。</p><p>作为文件和节点 ID ，2 的 160 次方也足够大，大到全地球 70 亿人每秒下载 10000 个种子，也足够下载百万亿年直到宇宙终结。</p><p>这些天才们的设计，让我们拥有了一个无法被审查和追踪的去中心化网络。这催生了庞大的盗版产业，但也让很多内容有机会避开审查。</p><p>因为网站可以被隔离、被拔线、被禁止访问，但种子不会。只要种子不死，那些不存在的音乐图书和视频就还活在互联网上，没有任何人可以毁掉。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；</p></li><li><p>P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基于分布式的哈希算法，元数据和文件数据全部分散。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NetworkProtocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈网络协议之 TCP/IP</title>
      <link href="/2019-06-06-network-protocol-ip-tcp-udp/"/>
      <url>/2019-06-06-network-protocol-ip-tcp-udp/</url>
      
        <content type="html"><![CDATA[<p>最近学了些TCP/IP相关的内容，做了些笔记。</p><a id="more"></a><p><a href="https://paaatrick.com/2019-06-03-network-protocol-https/">关于HTTP(S)、TLS的内容链接</a></p><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606103501.jpg" alt></p><h4 id="网络分层的原因"><a href="#网络分层的原因" class="headerlink" title="网络分层的原因"></a>网络分层的原因</h4><ul><li><p>复杂的程序都需要分层，各层次之间是独立的</p></li><li><p>某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务，这样能降低问题的复杂度，上层工作不影响下层的工作</p></li><li><p>易与多人协作，易与实现和维护，促进标准化工作</p></li><li><p>只要是在网络上跑的包，都是完整的，可以有下层没上层，绝不可能有上层没下层</p></li><li><p>对于TCP来说，只要想发出去包，就必须要有IP层和MAC层</p></li></ul><h4 id="网络如何分层"><a href="#网络如何分层" class="headerlink" title="网络如何分层"></a>网络如何分层</h4><ul><li>一般有五层模型和七层模型，按个人理解，七层模型只是把五层模型最上层的应用层给细化了<ol><li>物理层(中继器、集线器、HUB、网线)</li><li>数据链路层(MAC)</li><li>网络层(IP) </li><li>传输层(TCP/UDP) </li><li>应用层(HTTP(S))</li></ol></li></ul><h4 id="网络分层运行的过程"><a href="#网络分层运行的过程" class="headerlink" title="网络分层运行的过程"></a>网络分层运行的过程</h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606104044.jpg" alt></p><ol><li>接收过程</li></ol><p>当一个包经过网口时，首先看看要不要请进来处理一下（配置了混杂模式的网口，凡是经过的都拿进来），拿进来以后交给一段程序处理，于是调用<code>process_layer2(buffer)</code>，当然这是假函数，但你知道肯定有类似功能的函数的，这个函数功能是从buffer中摘掉二层（MAC）的头查看。</p><p>假如发现这个包的MAC地址与自己相符，说明是发给你的，于是调用<code>process_layer3(buffer)</code>，摘掉三层（IP）的头查看，如果IP地址不是自己的，就应该转发出去，如果IP地址是自己的，就根据IP头的指示，拿掉三层的头，进程下一层的处理，如果地址是TCP的，调用<code>process_tcp(buffer)</code>，如果是UDP的调用<code>process_udp(buffer)</code>。</p><p>假设是TCP的，调用<code>process_tcp(buffer)</code>，查看四层的头，看是一个发起，还是应答，或者是一个正常的数据包，分别交给不同的逻辑处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。交给谁呢？是不是有 <code>process_http(buffer)</code> 函数呢？</p><p>没有的，如果你是一个网络包处理程序，你不需要有process_http(buffer)，而是应该交给应用去处理。交给哪个应用呢？在四层的头里面有端口号，不同的应用监听不同的端口号。如果发现浏览器应用在监听这个端口，那你发给浏览器就行了。至于浏览器怎么处理，和你没有关系。</p><p>浏览器自然是解析 HTML，显示出页面来。电脑的主人看到页面很开心，就点了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起另一个 HTTP 请求了，于是使用端口号，将请求发给了你。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606103753.jpg" alt></p><ol start="2"><li>发送过程</li></ol><p>收到了一个封装好的HTTP包后，首先调用<code>send_tcp(buffer)</code>，<code>buffer</code>里就是HTTP请求的内容，这个函数里面加一个TCP的头，记录下浏览器给的源端口号，一般是80（HTTPS就443）。</p><p>然后调用<code>send_layer3(buffer)</code>，<code>buffer</code>里面已经有了HTTP的头和内容，以及TCP的头，这个函数里面加一个IP的头，记录下源IP地址和目标IP地址。</p><p>然后调用<code>send_layer2(buffer)</code>，<code>buffer</code>里面已经有了HTTP的头和内容、TCP的头，以及IP的头，这个函数里面加一个MAC的头，记录源MAC地址，得到的就是本机器的 MAC 地址和目标的 MAC 地址。不过，这个还要看当前知道不知道，知道就直接加上；不知道的话，就要通过一定的协议处理过程，找到 MAC 地址。反正要填一个，不能空着。</p><p>只要<code>buffer</code>里面的内容完整，就可以从网口发出去了。</p><h4 id="数据链路层-MAC"><a href="#数据链路层-MAC" class="headerlink" title="数据链路层 MAC"></a>数据链路层 MAC</h4><ul><li><p>MAC的全称是Medium Access Control，即媒体访问控制。</p></li><li><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p></li><li><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p><p> <img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606103751.jpg" alt></p></li><li><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p></li><li><p>一块网卡获取另一块网卡MAC地址的方式：ARP协议，当已知IP时请求MAC地址</p></li><li><p>ARP的工作方式：广播，向同个子网络内所有计算机发送数据包，让每台计算机自己判断自己是否为接收方</p><p> <img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606103754.jpg" alt></p></li></ul><h4 id="网络层-IP"><a href="#网络层-IP" class="headerlink" title="网络层 IP"></a>网络层 IP</h4><ul><li>ARP寻找MAC的广播方式只能在子网络内使用，每个子网络之间通信需要IP协议</li><li>Linux 上查看IP地址的命令：<code>ifconfig</code> 和 <code>ip addr</code>、没有的话自行安装<code>net-tools</code>和<code>iproute2</code></li></ul><ol><li><p>IP地址</p><ul><li>IPv4的网络地址由32个二进制位组成</li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606103750.jpg" alt></p><ul><li>IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码</li></ul></li><li><p>CIDR</p><ul><li>32位的IP地址分成了5类，但因为太浪费了，所以使用<code>CIDR</code></li><li>CIDR代替ABC类分配IP地址段，注意私有IP段，CIDR伴随广播地址和子网掩码</li></ul></li><li><p>IP的作用</p><ul><li>IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</li></ul></li><li><p>从IP得到MAC的方式</p><ul><li>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的，但是我们不知道它的MAC地址。分两种情况</li></ul><ol><li>如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</li><li>如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。</li></ol></li></ol><ul><li>DHCP请求IP地址，DHCP附送PXE协议安装OS</li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606130549.jpg" alt></p><h2 id="ICMP-和-ping"><a href="#ICMP-和-ping" class="headerlink" title="ICMP 和 ping"></a>ICMP 和 ping</h2><ul><li><p>ping 是基于 ICMP 工作的，ICMP全称Internet Control Message Protocol，就是互联网控制报文协议。</p></li><li><p>ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。</p></li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606124731.jpg" alt></p><ol><li><p>查询报文</p><ul><li>ping 就是ICMP的查询报文，是一种主动请求，并获得主动应答的ICMP协议，不过ping在ICMP后面增加了自己的格式</li><li>ping 主动请求的发送：<code>ICMP ECHO REQUEST</code></li><li>ping 主动请求的回复：<code>ICMP ECHO REPLY</code></li><li>比原生ICMP多了两个字段：标识符、序号，以及可选存放请求的时间值，可计算往返时间</li></ul></li><li><p>差错报文</p><ul><li>终点不可达：3，分为网络不可达、主机不可达、协议不可达、端口不可达、需要进行分片但设置了不分片等</li><li>源抑制：4，让源站放慢发送速度</li><li>超时：11，超过网络包的生存时间还没到达目标</li><li>重定向：5，让下次发给另一个路由器</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606124744.jpg" alt></p><ol start="3"><li><p>ping 的发送和接收过程</p><ul><li>可以看出ping是使用了ICMP里的<code>ECHO REQUEST</code>和<code>ECHO REPLY</code></li></ul></li><li><p>TTL (TimeToLive)</p><ul><li>在IPv4中, TTL是IP协议的一个8个二进制位的值(0-255)，这个值可以被认为是数据包在internet系统中可以跳跃的次数上限。</li><li>TTL是由数据包的发送者设置的, 在前往目的地的过程中, 每经过一台主机或设备, 这个值就要减少一点。</li><li>如果在数据包到达目的地前, TTL值被减到了0，那么这个包将作为一个ICMP错误的数据包被丢弃。</li></ul></li><li><p>差错报文的应用<code>Traceroute</code> </p><ul><li>Traceroute 故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器</li><li>对目的IP地址发送UDP包，设置TTL为1，即到达第一个路由就挂掉了，然后返回一个ICMP差错报文包，类型是超时</li><li>然后设置TTL为2，继续到第二个路由就挂了，返回超时，逐步迭代这个过程取得整个路径上的路由IP和延迟</li><li>有些路由不会回复这个ICMP，这就是Traceroute返回内容部分空白的原因</li><li>另外一个作用是故意设置不分片，从而确定路径的MTU</li></ul></li></ol><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ol><li><p>TCP 面向连接，UDP 面向无连接</p></li><li><p>TCP 提供可靠交付，UDP 不可靠</p><ul><li>TCP 连接传输的数据，无差错，不丢失，不重复，按序到达</li><li>UDP 继承 IP 包的特性，不保证不丢失，不保证按顺序到达</li></ul></li><li><p>TCP 基于字节流，UDP 基于数据报</p><ul><li>TCP 发送的时候是一个流，没头没尾</li><li>虽然 IP 包是一个个的 IP 包，TCP 自己维护成了流</li><li>UDP 继承了 IP 的特性，基于数据报，一个个地发，一个个地收</li></ul></li><li><p>TCP 有拥塞控制， UDP 没有</p><ul><li>TCP 意识到包丢失或者网络环境差后，根据情况调整行为，调节发送速度</li><li>UDP 没有意识，应用叫发包就发</li></ul></li><li><p>TCP 是有状态服务，UDP 是无状态服务</p><ul><li>TCP 精确记录了发送、接收状态</li><li>UDP 不记录状态</li></ul></li></ol><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h4 id="UDP-包头格式"><a href="#UDP-包头格式" class="headerlink" title="UDP 包头格式"></a>UDP 包头格式</h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606130750.jpg" alt></p><ul><li>源端口号 | 目的端口号</li><li>16位UDP长度 | 16位UDP校验和</li><li>数据</li></ul><h4 id="UDP-特点"><a href="#UDP-特点" class="headerlink" title="UDP 特点"></a>UDP 特点</h4><ol><li><p>沟通简单，认为网络通路默认就是很容易送达的，不容易被丢弃的</p></li><li><p>轻信他人， 不会建立连接，虽然有端口号，但是监听后任何人都能发数据给他，他也可以发数据给任何、任意多人</p></li><li><p>愣头青，不会根据网络情况进行发包的拥塞控制，无论丢包成什么样还是该怎么发就怎么发</p></li></ol><h4 id="UDP-使用场景"><a href="#UDP-使用场景" class="headerlink" title="UDP 使用场景"></a>UDP 使用场景</h4><ol><li><p>需要资源少，网络环境好的内网，或对丢包不敏感的应用。如 DCHP 和 TFTP 就是基于 UDP 协议的，因为BIOS资源少不适合维护TCP那种复杂的状态机</p></li><li><p>不需要一对一沟通建立连接，而是可以广播的应用。UDP 面向无连接的功能可以承载广播或者多播的协议，基于 UDP 的 DHCP 就是广播的形式</p></li><li><p>需要处理速度快，时延低，可容忍少数丢包，但即便网络拥塞也要不停歇发包的应用。比如网络直播，用户不关心过时数据，老数据丢了也就丢了，但不能因为拥塞而停歇了</p></li></ol><h4 id="UDP-使用例子"><a href="#UDP-使用例子" class="headerlink" title="UDP 使用例子"></a>UDP 使用例子</h4><ol><li><p>网页或者App的访问</p><ul><li>QUIC协议</li><li>移动互联，网络经常变换，TCP会经常重连很耗时，基于UDP的QUIC就比较合适</li></ul></li><li><p>流媒体协议</p><ul><li>TCP 的严格顺序传输不适合直播，用户不在意老数据而是要实时性，宁可丢包也不要卡顿</li><li>很多直播应用基于 UDP 实现自己的视频传输协议</li></ul></li><li><p>实时游戏</p><ul><li>游戏的实时性要求很高，而且服务器需要沟通很多客户端（玩家），在异步IO机制引入之前，UDP是应对海量客户端连接的策略</li><li>TCP的强顺序问题，对战游戏对网络要求简单，如FPS只需传输玩家位置和行为等，客户端解析响应并渲染场景，玩家并不关心过期数据，如果一个数据包丢失导致卡顿，下一秒就被爆头了。用UDP自定义可靠协议，自定义重传策略，能尽量降低延迟，减少网络问题对游戏性能的影响</li></ul></li><li><p>IoT 物联网</p><ul><li>物联网设备终端资源少，维护TCP开销太大</li><li>物联网对实时性要求高，TCP容易导致高延迟</li><li>Google子公司推出的物联网通信协议 Thread 就是基于 UDP 的</li></ul></li><li><p>移动通信领域</p><ul><li>4G 网络的数据协议 GTP-U 是基于 UDP 的</li></ul></li></ol><h4 id="UDP-小结"><a href="#UDP-小结" class="headerlink" title="UDP 小结"></a>UDP 小结</h4><ol><li><p>如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前；</p></li><li><p>UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</p></li></ol><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>TCP的seq是32位的计数器，每4微秒加1，计算可知284分钟即4.73小时重置一次</li></ul><h4 id="TCP-包头格式"><a href="#TCP-包头格式" class="headerlink" title="TCP 包头格式"></a>TCP 包头格式</h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606130901.jpg" alt></p><ul><li>源端口号 | 目标端口号</li><li>包序号:<code>seq</code></li><li>确认序号:<code>ack</code></li><li>首部长度 | 保留 | URG | ACK | PSH | RST | SYN | FIN | 16位窗口大小</li><li>校验和 | 紧急指针</li><li>选项</li><li>数据本体</li></ul><ol><li>首先与UDP一样是源端口和目标端口号，用于确定发给哪个应用</li><li><code>seq</code>序号解决乱序问题，确定每个包的先来后到，是个32位的计数器，每4微秒加1，计算可知284分钟即4.73小时重置一次</li><li><code>ack</code>的值是对方发来的TCP包内<code>seq</code>的值+1，解决不丢包问题</li><li>状态位，<code>SYN</code>是发起连接，<code>ACK</code>是回复，<code>RST</code>是重新连接，<code>FIN</code>是结束连接，这是TCP面向连接的体现，维护连接状态，这些带状态位的包的发送会引起双方的状态变更</li><li>窗口大小，做流量控制，双方各自声明一个窗口，标识自己当前的处理能力，不要发送得太快也别太慢</li></ol><h4 id="TCP-的特征"><a href="#TCP-的特征" class="headerlink" title="TCP 的特征"></a>TCP 的特征</h4><ul><li>顺序问题，稳重不乱；</li><li>丢包问题，承诺靠谱；</li><li>连接维护，有始有终；</li><li>流量控制，把握分寸；</li><li>拥塞控制，知进知退。</li></ul><h4 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h4><ol><li><p>三次握手</p><ul><li>① A：您好，我是 A ② B：您好 A，我是 B ③ A：您好 B</li><li>TCP连接的建立称为三次握手，“请求 -&gt; 应答 -&gt; 应答之应答”，让双方的消息都“有去有回”</li><li>第三次握手，A应答B的应答包，能解决一个问题：B收到了来自很久之前A的多次申请连接的SYN包，如果两次握手，B这时建立了连接就等于单相思，所以需要“应答之应答”</li><li>为什么不四次握手？因为就算40次握手也不能真正保证连接就建立了，只要双方都有去有回就基本认为建立了，并且一般A和B连接建立后就开始发数据，一但A方开始发送数据，问题就解决了</li><li>如果连接建立后A一直不发数据，这个在HTTP有keepalive机制，即使没有真实数据包也有探活包</li><li>B也可以设计对于长时间不发包的A主动关闭连接</li><li>大写<code>ACK</code>与小写<code>ack</code>的区别：大写的是状态位，当为1时表示包是回复包，小写是确认序号，值是对方的序号<code>seq</code>+1</li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606132859.jpg" alt></p></li></ol><p>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送 <code>ACK</code> 的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</p><ol start="2"><li><p>四次挥手</p><ul><li>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</li></ul><ol><li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送</li><li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</li><li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A</li><li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1</li></ol><ul><li>上面2与3的过程中，B可能还有要发给A的数据没发送完，就首先ACK了A的FIN后，等处理完数据后再发送FIN给A，所以一共需要4次挥手。</li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606132901.jpg" alt></p></li><li><p>白话解释四次挥手</p><ul><li><p>① A：B 啊，我不想玩了 ② B：哦，你不想玩了啊，我知道了 ③ B：A 啊，好吧，我也不玩了，拜拜 ④ A：好的，拜拜。</p></li><li><p>A 开始说“不玩了”，B 说“知道了”，这个回合是没什么问题的，因为在此之前，双方还处于合作的状态，如果 A 说“不玩了”，没有收到回复，则 A 会重新发送“不玩了”。但是这个回合结束之后，就有可能出现异常情况了，因为已经有一方率先撕破脸。</p></li><li><p>一种情况是，A 说完“不玩了”之后，直接跑路，是会有问题的，因为 B 还没有发起结束，而如果 A 跑路，B 就算发起结束，也得不到回答，B 就不知道该怎么办了。另一种情况是，A 说完“不玩了”，B 直接跑路，也是有问题的，因为 A 不知道 B 是还有事情要处理，还是过一会儿会发送结束。</p></li><li><p>断开的时候，我们可以看到，当 A 说“不玩了”，就进入 FIN_WAIT_1 的状态，B 收到“A 不玩”的消息后，发送知道了，就进入 CLOSE_WAIT 的状态。</p></li><li><p>A 收到“B 说知道了”，就进入 FIN_WAIT_2 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状态。TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。</p></li><li><p>如果 B 没有跑路，发送了“B 也不玩了”的请求到达 A 时，A 发送“知道 B 也不玩了”的 ACK 后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是最后的这个 ACK 万一 B 收不到呢？则 B 会重新发一个“B 不玩了”，这个时候 A 已经跑路了的话，B 就再也收不到 ACK 了，因而TCP 协议要求 A 最后等待一段时间 TIME_WAIT，这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B。</p></li><li><p>A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来 B 发送的所有的包都死翘翘，再空出端口来。</p></li><li><p>等待的时间设为 2MSL，MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个TTL 域，是 IP 数据报可以经过的最大路由数，每经过一一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。</p></li><li><p>还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。</p></li></ul></li><li><p>TCP 状态机</p></li></ol><ul><li>把上面两个时序图合并起来就是这个TCP状态机图</li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606132904.jpg" alt></p><ul><li>加黑加粗的部分是主要流程，阿拉伯数字的序号是连接建立的顺序，大写中文数字的序号是连接断开的顺序。加粗实线是客户端A的状态变化过程，加粗虚线是服务端B的状态变化过程。细虚线是其他非主流过程。</li></ul><h4 id="TCP-的顺序机制"><a href="#TCP-的顺序机制" class="headerlink" title="TCP 的顺序机制"></a>TCP 的顺序机制</h4><ul><li><p>每个包都有一个ID，按照ID一个个发送</p></li><li><p>累计确认（累计应答）</p><ul><li>发送端和接收端分别有缓存保存记录所有发送和接收的包</li></ul></li></ul><ol><li><p>发送端窗口</p><ul><li><p>发送端的缓存里是按照包ID排列的，有四种类型</p><ol><li>发送了且已确认</li><li>发送了且尚未确认</li><li>还没发送但等待发送</li><li>还没发送且暂时不会发送</li></ol><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606145507.jpg" alt></p></li><li><p>上面3和4的区分是流量控制</p><ol><li>流量控制使用窗口（<code>Advertised Window</code>），窗口大小等于上面2+3部分，即发送未确认和未发送但可发送的</li><li><code>LastByteAcked</code>：第一部分和第二部分的分界线</li><li><code>LastByteSent</code>：第二部分和第三部分的分界线</li><li><code>LastByteAcked + AdvertisedWindow</code>：第三部分和第四部分的分界线</li></ol></li></ul></li><li><p>接收端窗口</p><ul><li>接收端的缓存里是按照包ID排列的，有三种类型<ol><li>接收且确认过</li><li>尚未接收但可接收</li><li>尚未接收且不能接收</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606145846.jpg" alt></p><ul><li><p>流量控制使用窗口（<code>AdvertisedWindow</code>），窗口大小是上面第2部分，需要计算</p><ol><li><code>MaxRcvBuffer</code>：最大缓存的量；</li><li><code>LastByteRead</code> 之后是已经接收了，但是还没被应用层读取的；</li><li><code>NextByteExpected</code> 是第一部分和第二部分的分界线。</li></ol><ul><li><code>NextByteExpected</code> 和 <code>LastByteRead</code> 的差其实是还没被应用层读取的部分占用掉的 <code>MaxRcvBuffer</code> 的量，我们定义为 <code>A</code>。</li><li><code>AdvertisedWindow</code> 其实是 <code>MaxRcvBuffer</code> 减去 <code>A</code>，即第2部分的大小</li><li>也就是：<code>AdvertisedWindow = MaxRcvBuffer - ((NextByteExpected-1) - LastByteRead)</code>。</li><li>第2部分和第3部分的分界线就是 <code>NextByteExpected</code> + <code>AdvertisedWindow</code>，即 <code>LastByteRead</code> + <code>MaxRcvBuffer</code></li></ul></li></ul></li></ol><h4 id="TCP-的丢包重发机制"><a href="#TCP-的丢包重发机制" class="headerlink" title="TCP 的丢包重发机制"></a>TCP 的丢包重发机制</h4><ol><li><p>确认与重发机制</p><ul><li>超时重试，没有<code>ACK</code>的包都有设一个定时器，超过一定时间就重新尝试</li><li>超时时间需要大于往返时间 RTT，也不宜过长</li></ul></li><li><p>自适应重传算法</p><ul><li>TCP 通过采样 RTT 时间和 RTT 的波动范围，进行加权平均，算出一个值，还需要根据新状况不断变化</li><li>超时触发重传的问题是超时周期可能很长</li></ul></li><li><p>快速重传机制</p><ul><li>当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。</li><li>还有一种方式 <code>SACK</code> (Selective Acknowledgment)，在TCP头里加一个SACK，可以把可以将缓存的地图发送给发送方。</li></ul></li></ol><h4 id="TCP-的流量控制机制"><a href="#TCP-的流量控制机制" class="headerlink" title="TCP 的流量控制机制"></a>TCP 的流量控制机制</h4><ul><li><p>如果发送方发送太猛，接收方处理不过来导致缓存中没有空间，可以通过确认信息修改窗口大小，甚至设为0，使发送方暂时停止发送</p></li><li><p>当发送方发现自己窗口被调整到0后，会定时发送窗口探测数据包，看是否有机会调整窗口大小</p></li><li><p>当接收方比较慢时，要防止低能窗口综合征，避免空出一个字节就通知发送方然后又填满窗口。当窗口太小时，可以暂停更新窗口，直到窗口达到一定大小或者缓冲区一半为空，才更新窗口</p></li></ul><h4 id="TCP-的拥塞控制机制"><a href="#TCP-的拥塞控制机制" class="headerlink" title="TCP 的拥塞控制机制"></a>TCP 的拥塞控制机制</h4><ol><li><p>也是通过窗口大小控制，滑动窗口 <code>rwnd</code> 是怕发送方把接收方缓存占满，拥塞窗口 <code>cwnd</code> 是怕把网络塞满</p><ul><li><p><code>LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd}</code>，是拥塞窗口和滑动窗口共同控制发送的速度</p></li><li><p>发送方难以判断网络是否满的方法，在TCP看来网络路径是一个黑盒</p></li><li><p>TCP 发送包常被比喻为往一个水管里面灌水，而 TCP 的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。</p></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606152532.jpg" alt></p><ol start="2"><li><p>TCP 的拥塞控制主要用来避免两种现象：包丢失和超时重传</p><ul><li><p>一旦出现了这些现象就说明，发送速度太快了，要慢一点。但是一开始我怎么知道速度多快呢，我怎么知道应该把窗口调整到多大呢？</p></li><li><p>慢启动：一开始 <code>cwnd</code> 大小为一个报文段，当收到确认时指数型增大<code>cwnd</code>大小</p></li><li><p>指数型涨到一个值为65535字节的 <code>ssthresh</code> 时降为线性增长，每8个确认<code>cwnd</code>增加1，但总有溢出的时候。</p></li><li><p>当出现拥塞即丢包时，需要超时重传，<code>ssthresh</code>设为<code>cwnd/2</code>，<code>cwnd</code>设为1，重新开始慢启动，一夜回到解放前。</p></li></ul></li><li><p>快速重传</p><ul><li><p>当接收端发现丢了一个中间包时，发送三次前一个包的ACK，于是发送端就会快速重传，不必等待超时重传。</p></li><li><p>此时<code>cwnd</code> = <code>cwnd</code> / 2， <code>sshthresh</code> = <code>cwnd</code>，当三个包返回时，<code>cwnd = sshthresh + 3</code></p></li><li><p>也就是不用回到解放前，只是减半而已</p></li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606153531.jpg" alt></p><ul><li><p>这种机制导致延迟高的情况下，反而降低速度，导致本文前面UDP部分里说的TCP的问题</p><ol><li><p>丢包不代表通道满了，可能本身公网就是会丢包的，这时其实并没有拥塞</p></li><li><p>TCP 的拥塞控制要等到将中间设备都填充满了才发生丢包，从而降低发送速度，此时已经晚了，其实TCP只要通道满了就应该开始控制了，而不应该等到连缓存都满了才控制</p></li></ol></li><li><p>解决方法：<code>BBR</code> 拥塞算法，找到一个平衡点，填满管道但是不填满中间设备的缓存，达到高带宽和低时延的平衡</p></li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606153950.jpg" alt></p></li></ol><h4 id="TCP-小结"><a href="#TCP-小结" class="headerlink" title="TCP 小结"></a>TCP 小结</h4><ul><li>TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制</li><li>连接的建立是经过三次握手，断开的时候四次挥手</li><li>顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的</li><li>拥塞控制是通过拥塞窗口来解决的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NetworkProtocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈网络协议之 HTTP、HTTPS 和 TLS</title>
      <link href="/2019-06-03-network-protocol-https/"/>
      <url>/2019-06-03-network-protocol-https/</url>
      
        <content type="html"><![CDATA[<p>最近学了些HTTP相关的内容，做了些笔记，深入了解TLS后感觉密码学挺有意思。</p><a id="more"></a><p><a href="https://paaatrick.com/2019-06-06-network-protocol-ip-tcp-udp/">关于TCP/IP的内容链接</a></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h4><ul><li>这是后来回来定义的版本，这个初始版本采用纯文本格式</li><li>只有GET动作，在响应请求后立即关闭连接，功能非常有限</li></ul><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h4><ul><li>1996年发布，与1.1差不了多少了<ol><li>增加了<code>HEAD</code>、<code>POST</code>等方法</li><li>增加响应状态码，标记可能的错误原因</li><li>引入协议版本号概念</li><li>引入了<code>Header</code>头部的概念</li><li>传输的数据不再仅限于文本</li></ol></li><li>但是1.0并不是一个标准，只相当于一个备忘录（参考文档）</li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><ul><li>1999年，发布RFC文档编号2616，是个正式的标准<ol><li>增加了<code>PUT</code>、<code>DELETE</code>等方法</li><li>增加了缓存管理和控制</li><li>明确了连接管理，允许持久连接</li><li>允许响应数据分块（<code>chunked</code>），利于传输大文件</li><li>强制要求<code>Host</code>头，让互联网主机托管成为可能</li></ol></li></ul><h6 id="HTTP请求报文格式"><a href="#HTTP请求报文格式" class="headerlink" title="HTTP请求报文格式"></a>HTTP请求报文格式</h6><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155246.jpg" alt></p><ul><li>请求方法 | URL | 协议版本</li><li><code>Header</code>头部（一行一个字段，key-value，中间冒号分隔）</li><li>空行</li><li>请求包体(GET没有,POST用)(GET也可以填body,服务端不一定处理)</li></ul><h6 id="HTTP响应报文格式"><a href="#HTTP响应报文格式" class="headerlink" title="HTTP响应报文格式"></a>HTTP响应报文格式</h6><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155333.jpg" alt></p><ul><li>协议版本 | 状态码 | 状态码描述</li><li><code>Header</code>头部（一行一个字段，key-value，中间冒号分隔）</li><li>空行</li><li>响应包体</li></ul><h6 id="常见的Header"><a href="#常见的Header" class="headerlink" title="常见的Header"></a>常见的Header</h6><ol><li>Accept-Charset： 数据编码格式</li><li>Content-Type： 数据的类型</li><li>Cache-control：max-age，客户端的话就是希望多新的缓存，服务端的话就是告诉客户端某个时间段内的数据都是最新的</li><li>If-Modified-Since：如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最最新的资源；如果没有更新，服务端会返回304 Not Modified的响应，那客户端就不用下载了</li><li>Retry-After：告诉客户端应该在多长时间以后再次尝试一下</li><li>Connection：一般是keep-alive，用来保活TCP连接，close的话就是传输完后就关闭TCP连接</li><li>Referer：客户端告诉服务端我是从哪个链接来的，服务端收到后可以做处理，重定向，或者用于支付后的回调（微信支付）</li><li>User-Agent：老生常谈，操作系统和浏览器名称版本，很多骚操作</li></ol><h6 id="一些特点"><a href="#一些特点" class="headerlink" title="一些特点"></a>一些特点</h6><ol><li>一般POST时，先发送header，服务器响应 100 Continue 后，浏览器再发送Data，服务器响应 200 OK，可能分两个TCP包</li><li>header是key-value，中间冒号分隔</li><li>HTTP即超文本传输协议 HyperTextTransferProtocol, 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</li><li>HTTP没有实体，不是互联网，不是语言，不是HTML，不是孤立的协议。</li><li>HTTP是基于TCP的，TCP的重传HTTP不知道</li><li>由于有Keep-Alive机制，每次HTTP连接无需TCP重新握手</li></ol><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h4><ul><li>HTTP2.0通过头压缩、分帧、多路复用等技术提升性能</li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155409.jpg" alt></p><ol><li>SPDY是谷歌推出的，HTTP2.0基于此制定</li><li>HTTP2.0对header压缩，用索引表替代key-value，将一个TCP连接中切分多个流。<ul><li>每个流有自己ID，流是双向的虚拟通道，流有优先级。2.0还将所有信息分割为帧。</li><li>有header帧和data帧，用二进制编码，多个data帧属于同一个流。</li><li>这样可以将多个请求分到不同的流中，将请求内容拆成帧，进行二进制传输。</li><li>帧可以打散乱序发送，然后根据每个帧首部的流标识符重新组装，并根据优先级决定先处理哪个流。</li><li>HTTP2.0其实是将n个请求变成n个流，将数据分成帧，乱序发送到一个TCP连接中。</li><li>这样2.0解决了1.1的队首阻塞问题。1.1通过pipeline用多条TCP实现并发，2.0只用1个TCP实现并发，提高性能。</li><li>但HTTP2.0还是基于TCP的，TCP处理包时有严格顺序，前面流2的帧没收到，后面流1的帧也会阻塞</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155413.jpg" alt></p><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><ul><li>QUIC是谷歌基于UDP改进的应用层，未来HTTP3.0可能基于此实现，解决HTTP2.0的问题，QUIC也是面向连接的。</li><li>QUIC自定义类似TCP的连接、重试、多路复用、流量控制技术，进一步提升性能</li></ul><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155449.jpg" alt></p><ol><li><p>机制1：自定义连接</p><ul><li>一条TCP连接是四元组（源IP和端口,目标IP和端口）标识的，一旦一个元素变化就需要断开重连</li><li>移动互联经常不稳定、切换，都会导致重连，又三次握手，时延高</li><li>而基于UDP的QUIC自己用64位随机数作为标识替代四元组，而且UDP是无连接的</li><li>当前述的四个元素变化时，不用重新建立连接</li></ul></li><li><p>机制2：自定义重传机制</p><ul><li>TCP有通过采样往返时间RTT的自适应重传算法，但是这种采样不准确。</li><li>QUIC也有递增序列号，任何一个包重发序列号都+1，不像TCP重发包还是原来的序号。</li><li>这样超时采样就准了，但是如何知道重发的包内容与前一个一样呢</li><li>QUIC在数据流里定义了<code>offset</code>，可以通过<code>offset</code>查看数据发送到了哪里</li><li>只要某个<code>offset</code>没到就重发，按照<code>offset</code>拼接成一个流，相当于多设一个参数处理流的顺序。</li></ul></li><li><p>机制3：无阻塞的多路复用</p><ul><li>跟2.0一样，同一条QUIC上可以创建多个流来发送HTTP请求</li><li>但因为基于UDP，一个连接上的多个流之间没有依赖</li><li>假如流2丢了一个UDP包，后面跟着流3的一个UDP包，虽然流2的包需要重传，但流3的包无需等待，而TCP就会阻塞</li></ul></li><li><p>机制4：自定义流量控制</p><ul><li>TCP的流量控制是通过滑动窗口协议，QUIC也是通过window_update来告诉对方自己可接受的字节数</li><li>但QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，每个流也有控制窗口</li><li>TCP里接收端的窗口起始点是下一个要接收并且ACK的包，即便后来的包都到了放在缓存里，窗口也不能右移</li><li>只要前面的包没到，后面的到了也不能ACK，就会导致后面的到了也可能超时重传，浪费带宽。</li><li>QUIC的ACK是基于offset的，每个offset的包到了进了缓存就可以应答，应答后就不用重发，再继续等中间的包即可</li><li>QUIC窗口的其实位置为当前收到的最大offset，从这个offset到当前流所能容纳的最大缓存才是真正的窗口</li><li>另外还有整个连接的窗口，需要对所有流的窗口做一个统计</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155516.jpg" alt></p><h4 id="关于HTTP的队首阻塞"><a href="#关于HTTP的队首阻塞" class="headerlink" title="关于HTTP的队首阻塞"></a>关于HTTP的队首阻塞</h4><ol><li><p>HTTP/1.0对于同一个tcp连接，所有的请求放入队列中，只有前一个请求的响应收到了，然后才能发送下一个请求。可见，HTTP/1.0的队首组塞发生在客户端。</p></li><li><p>HTTP/1.1对于同一个tcp连接，HTTP/1.1允许一次发送多个请求，也就是说，不必等前一个响应收到，就可以发送下一个请求，这样就解决了HTTP/1.0的客户端的队首阻塞。但服务端响应的发送要根据请求的顺序排队发送，如果前一个请求的处理时间长就会影响后面的响应发送。可见，HTTP/1.1的队首阻塞发生在服务器端。</p></li><li><p>HTTP/2.0无论在客户端还是在服务器端都不需要排队，在同一个TCP连接上，有多个stream，由各个stream发送和接收请求，各个steam相互独立，互不阻塞。只要TCO没有人在用那么就可以发送已经生成的requst或者reponse的数据，在两端都不用等，从而彻底解决了HTTP协议层面的队首阻塞问题。</p></li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h4 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155548.jpg" alt></p><ol><li>开始连接时，客户端用服务端的公钥加密发送，服务端用客户端的公钥加密回应</li><li>CA证书里有公钥，CA是递归的最后有几个大的rootCA，先用非对称加密获取密钥，然后用对称加密传输数据，TLS/SSL</li><li>HTTPS握手过程：（c是客户端，s是服务端）<ul><li>c发送 <code>Client Hello</code> 给s，明文传输TLS版本、加密套件候选列表、压缩算法候选列表等以及一个随机数A</li><li>s返回 <code>Server Hello</code> 给c，声明选择使用的协议版本、加密套件、压缩算法等以及一个随机数B</li><li>s发送 <code>Server Certificate</code> 给c，然后再发送 Server Hello Done，说明发送信息就这么多了，结束</li><li>c校验前一步s给的证书，从自己信任的CA仓库中拿CA证书的公钥取解密s的证书，过程中可能需要往上追溯CA、CA的CA等</li><li>c发送 <code>Client Key Exchange</code>，内含生成的一个随机数C：<code>Pre-master</code>，用s证书的公钥加密，发送给s，s可以通过自己的私钥解密出来（<code>Pre-master</code>是RSA加密的说法，DH加密需要 <code>DH exponent</code>）</li><li>现在，c和s都有了三个随机数，分别是自己的、对方的、Pre-master，通过这三个随机数，c和s能生成相同的对称密钥</li><li>c发送 <code>Change Cipher Spec</code> 通知s采用协商的通信密钥和加密算法进行对称加密通信</li><li>c发送 <code>Encrypted Handshake Message</code> 将先前商定好的参数采用协商密钥加密，发送给s用于数据与握手验证</li><li>s发送 <code>Change Cipher Spec</code> 回应c采用协商的通信密钥和加密算法进行对称加密通信</li><li>s发送 <code>Encrypted Handshake Message</code> 将先前商定好的参数采用协商密钥加密，发送给c用于数据与握手验证</li><li>双方转而使用对称加密通信，握手完成，除了以上过程，其余过程与HTTP一样</li></ul></li><li>上面是HTTPS单向验证，只是c验证了s的证书，是大部分的场景，也可以在更加严格安全要求的情况下，启用双向验证，互验证书</li><li>重放与篡改攻击：自定义的：通过Timestamp和Nonce随机数联合起来做不可逆签名来保证。</li><li>为什么不直接用非对称加密通信？<ul><li>非对称加密的加密的内容不能超过公钥长度，所以只能用来作密钥交换或者内容签名</li><li>性能问题，对称加密是毫秒级，非对称是秒级，<code>HTTPS</code>握手过程的<code>90%</code>时间都在解密<code>RSA</code></li></ul></li><li>除了<code>Premaster</code>外还需要两个随机数的原因是<code>TLS</code>不信任每个客户端都能产生安全的随机数，所以引入多两个随机数</li></ol><h4 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h4><ol><li>TLS即SSL升级版，18年推出TLS1.3，目前(19年)用TLS1.2和1.3的都不少，SSL早就废弃了</li><li>对称加密算法有：<code>AES</code>、<code>DES</code>、<code>3DES</code>，非对称加密算法有：<code>RSA</code>、<code>ECDHE</code></li><li>TLS中上面将两个随机数和Premaster计算成对称加密主密钥的算法是PRF算法(SHA256)</li><li>TLS是在传输层（TCPUDP层）之上，应用层（HTTP）之下的层，HTTPS其实就是在TCP和HTTP之间加了TLS层</li></ol><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155834.PNG" alt></p><ol start="5"><li>握手的加密套件：例子：<code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>，<code>ECDHE</code>密钥交换、<code>RSA</code>身份验证、<code>AES</code>算法、<code>128</code>加密强度、<code>GCM</code>加密模式、<code>SHA256</code>是MAC或者PRF</li><li>目前主流HTTPS的流量是使用<code>ECDHE</code>进行密钥交换、用<code>RSA</code>进行身份验证</li></ol><h4 id="TLS协议原理"><a href="#TLS协议原理" class="headerlink" title="TLS协议原理"></a>TLS协议原理</h4><ul><li><p>自顶向下、分层抽象，TLS大致在四层</p><ol><li>最底层是基础算法原语的实现如<code>AES</code>、<code>RSA</code>、<code>MD5</code>、<code>SHA256</code>、<code>ECDH</code>等</li><li>第二层是选定参数后，符合密码学里标准分类的算法，包括块加密算法，签名算法，非对称加密算法，MAC算法等，例如： <code>aes-128-cbc-pkcs7</code>，<code>rsaes-oaep</code> ，<code>rsassa-pkcs1-v1_5</code>, <code>hmac-sha256</code>，<code>ecdsa-p256</code>，<code>curve25519</code> 等</li><li>第三层是把多种标准算法组合而成的半成品组件，例如：对称传输组件例如 <code>aes-128-cbc + hmac-sha256，aes-128-gcm</code>，认证密钥协商算法: <code>rsassa-OAEP + ecdh-secp256r1</code>，数字信封：<code>rsaes-oaep + aes-cbc-128 + hmac-sha256</code> ，文件密码加密存储组件：<code>pbkdf2+aes-128-cbc-hmac-sha256</code>，密钥扩展算法 <code>PRF-sha256</code> 等</li><li>第四层是用各种组件拼装而成的各种成品密码学协议/软件，例如：TLS协议，SSH协议，SRP协议，gnupg文件格式，iMessage协议，bitcoin协议等等</li></ol></li><li><p>很多程序员自己造的轮子，往往说白了就是想重复实现第3层的某个组件而已。</p></li></ul><h5 id="TLS加密套件-CipherSuite"><a href="#TLS加密套件-CipherSuite" class="headerlink" title="TLS加密套件 (CipherSuite)"></a>TLS加密套件 (CipherSuite)</h5><ul><li><p>从上述分层的角度看，<code>TLS</code>大致是由三个组件拼成的：</p><ol><li>对称加密传输组件，例如<code>aes-128-gcm</code>;</li><li>认证密钥协商组件，例如<code>rsa-ecdhe</code>;</li><li>密钥扩展组件，例如<code>TLS-PRF-sha256</code></li></ol></li><li><p>这些组件可以再拆分为5类算法，在<code>TLS</code>中，这5类算法组合在一起，称为一个<code>CipherSuite</code>：</p><ol><li>authentication (认证算法)</li><li>encryption (加密算法 )</li><li>message authentication code (消息认证码算法  简称MAC)</li><li>key exchange (密钥交换算法)</li><li>key derivation function （密钥衍生算法)</li></ol></li><li><p>TLS协议设计之初就考虑到了这每一类算法的演变，所以没有定死算法，而是设计了一个算法协商过程，来允许加入新的算法( 简直是软件可扩展性设计的典范！)，协商出的一个算法组合即一个<code>CipherSuite</code></p></li><li><p>常见加密套件<br> <img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190606155835.JPG" alt></p></li></ul><h4 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h4><ul><li><p>上述第二层中的密码学算法常见有下面几类</p><ol><li>块加密算法：<code>AES</code>（AES_128_GCM等）、<code>Serpent</code>等</li><li>流加密算法：<code>RC4</code>、<code>ChaCha20</code>等</li><li>加密用哈希函数：<code>MD5</code>、<code>SHA1</code>、<code>SHA256</code>、<code>POLY1305</code>等</li><li>消息验证码函数：<code>AEAD</code>、<code>HMAC-SHA256</code>等</li><li>密钥交换算法：<code>RSA</code>、<code>DH</code>、<code>ECDH</code>、<code>ECDHE</code></li><li>公钥加密算法：<code>RSA</code></li><li>数字签名算法：<code>RSA</code>、<code>DSA</code>、<code>ECDSA</code></li></ol></li><li><p>设计一个加密通信协议的过程，就是自顶向下，逐步细化，挑选各类组件，拼装成完整协议的过程</p></li></ul><h4 id="AES加密算法"><a href="#AES加密算法" class="headerlink" title="AES加密算法"></a>AES加密算法</h4><ol><li>每个加密数据块大小固定为128位（16个字节），最后一块不满16字节的话需要用填充算法补齐</li><li>最终生成的加密密钥长度有128位、192位、256位三种</li><li>多种工作模式：<code>ECB</code>、<code>CBC</code>、<code>CFB</code>等，这块内容很多，后续补充</li></ol><h4 id="DES、3DES加密算法"><a href="#DES、3DES加密算法" class="headerlink" title="DES、3DES加密算法"></a>DES、3DES加密算法</h4><ol><li><p>DES:</p><ul><li>每个加密数据块大小固定为64位（8个字节）</li><li>生成的密钥长度为64位（其中8位用于校验（每个字节的第8位）），所以AES比DES安全</li></ul></li><li><p>3DES:</p><ul><li>还是64位的加密数据块大小</li><li>简单粗暴的 <code>Triple DES</code>，使用3个<code>DES</code>密钥（所以共192位，其中24位校验），对数据块（还是64位的小块）应用三次<code>DES</code>算法进行三次加密</li><li>使用的3个密钥不是合并成1个密钥，而还是分成3个用，<code>3DES</code>加密时依次使用密钥1、密钥2、密钥3对明文数据块进行加密，解密过程反之亦然。</li><li>每次加解密原理与<code>DES</code>一样</li></ul></li></ol><h4 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h4><p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做<code>RSA</code>算法。从那时直到现在，<code>RSA</code>算法一直是最广为使用的“非对称加密算法”。</p><ol><li><p>公钥与私钥的产生</p><ul><li>假设Alice想要通过一个不可靠的媒体接收Bob的一条私人讯息。</li><li>她可以用以下的方式来产生一个公钥和一个私钥：</li><li>随意选择两个大的质数p和q，p不等于q，计算N=pq。</li><li>根据欧拉函数，求得r =φ(N)=φ(p)φ(q)= (p-1)(q-1)</li><li>选择一个小于 r 的整数 e，求得 e 关于模 r 的模反元素，命名为d。（模反元素存在，当且仅当e与r互质）</li><li>将 p 和 q 的记录销毁。    </li><li>(N,e)是公钥，(N,d)是私钥。Alice将她的公钥(N,e)传给Bob，而将她的私钥(N,d)藏起来。 </li></ul></li><li><p>加密消息</p><ul><li>假设Bob想给Alice送一个消息m，他知道Alice产生的N和e。</li><li>他使用起先与Alice约好的格式将m转换为一个小于N，且与N互质的整数n</li><li>比如他可以将每一个字转换为这个字的Unicode码，然后将这些数字连在一起组成一个数字。</li><li>假如他的信息非常长的话，他可以将这个信息分为几段，然后将每一段转换为n。</li><li>用下面这个公式他可以将n加密为c：</li><li>n^e ≡ c (mod N)</li><li>计算c并不复杂。Bob算出c后就可以将它传递给Alice。</li></ul></li><li><p>解密消息</p><ul><li>Alice得到Bob的消息c后就可以利用她的密钥d来解码。她可以用以下这个公式来将c转换为n：</li><li>c^d ≡ n (mod N)</li><li>得到n后，她可以将原来的信息m重新复原。</li><li>解码的原理是 c^d ≡ n^(e·d)(mod N)</li><li>已知e·d ≡ 1 (mod r)，即e·d =1 +hφ(N)。由欧拉定理可得：</li><li>n ^(e·d) =n^ (1 +hφ(N))=n·((n^φ(N))^h)≡(n(1)^h)(modN) ≡ n (mod N)</li></ul></li><li><p>签名消息</p><ul><li>RSA也可以用来为一个消息署名。</li><li>假如Alice想给Bob传递一个署名的消息的话，那么她可以为她的消息计算一个散列值（Message digest）</li><li>然后用她的私钥加密这个散列值并将这个“署名”加在消息的后面。</li><li>这个消息只有用她的公钥才能被解密。</li><li>Bob获得这个消息后可以用Alice的公钥解密这个散列值</li><li>然后将这个数据与他自己为这个消息计算的散列值相比较。</li><li>假如两者相符的话，那么他就可以知道发信人持有甲的密钥，以及这个消息在传播路径上没有被篡改过。</li></ul></li><li><p>实战例子</p><ul><li>通过一次简单实践更好的了解RSA</li><li>假设p = 2，q = 5（p，q都是素数即可），则N = pq = 10；</li><li>得到：r = (p-1)(q-1) = (2-1)(5-1) = 4；</li><li>根据模反元素公式，可以得出，e·d ≡ 1 (mod 4),即e·d = 4n+1 (n为正整数)；</li><li>假设n=5，则e·d = 21，且e、d为正整数，并且e与r互质，则e = 7，d = 3；</li><li>获得公钥和密钥：公钥为(N, e) = (10, 7)，密钥为(N, d) = (10, 3)；</li><li>假设要传输的数字为2，通过公钥加密后为：(2^7)(mod 10) = 8；</li><li>通过密钥解密：(8^3)(mod 10) = 512(mod 10) = 2，即获得结果；</li></ul></li></ol><h4 id="ECDHE加密算法"><a href="#ECDHE加密算法" class="headerlink" title="ECDHE加密算法"></a>ECDHE加密算法</h4><ul><li>主要用于HTTPS中的密钥交换</li><li><code>ECDHE</code>源自<code>ECDH</code>，<code>ECDH</code>即使用椭圆曲线加密技术（ECC）的 DH密钥交换（Diffie-Hellman）算法.</li><li><code>DH</code>密钥交换算法，可以让交换双方在不共享任何秘密的情况下协商出一个密钥。<code>ECC</code>则是建立在基于椭圆曲线的离散对数问题上的密码体制，在相同的密钥长度下，其安全性比<code>RSA</code>更高。</li><li>而<code>ECDHE</code>则是<code>ECDH</code>的<code>Ephemeral version</code>，它会为每次握手过程分配一个不同的<code>DH key</code>，从而提供前向安全性。实际上，在<code>HTTP/2</code>中允许使用的<code>Cipher Suite</code>必须采用具有前向安全性的密钥交换算法。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>HTTPS实际就是在TCP层与http层之间加入了TLS/SSL来解决安全问题的。</li><li>在进行应用数据传输之前，TLS需要通过握手过程来协商安全通信所需的相关参数。</li><li>整个通信过程中主要用到散列、对称加密、非对称加密和证书等相关技术，来解决客户端与服务器数据传输中各种安全风险问题，从而达到保证整个通信过程的安全。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NetworkProtocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WKWebView获取H5页面里图片地址以及图片相对视图窗口的坐标的方法</title>
      <link href="/2019-06-01-ios-achieve-h5-image-bounding-rect/"/>
      <url>/2019-06-01-ios-achieve-h5-image-bounding-rect/</url>
      
        <content type="html"><![CDATA[<p>WKWebView获取H5页面里图片地址以及图片相对视图窗口的坐标的方法</p><p>最近有个需求是点击放大查看H5内容页面的图片，寻找到一个比较轻量的库<a href="https://github.com/hackxhj/YHPhotoBrowser" target="_blank" rel="noopener"><code>YHPhotoBrowser</code></a>，其中根据图片位置来缩放的动画需要传递一个图片所在屏幕里的位置<code>CGRect</code>，想获取H5的图片坐标那就需要JS注入了</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)handleSingleTap:(<span class="built_in">UITapGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> touchPoint = [recognizer locationInView:<span class="keyword">self</span>.webView];</span><br><span class="line">    <span class="built_in">NSString</span> *jsString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"function getURLandRect()&#123;\</span></span><br><span class="line"><span class="string">                            var ele=document.elementFromPoint(%f, %f);\</span></span><br><span class="line"><span class="string">                            var url=ele.src;\</span></span><br><span class="line"><span class="string">                            var left=ele.getBoundingClientRect().left;\</span></span><br><span class="line"><span class="string">                            var top=ele.getBoundingClientRect().top;\</span></span><br><span class="line"><span class="string">                            var width=ele.getBoundingClientRect().width;\</span></span><br><span class="line"><span class="string">                            var height=ele.getBoundingClientRect().height;\</span></span><br><span class="line"><span class="string">                            var jsonString= `&#123;\"url\":\"$&#123;url&#125;\",\"left\":\"$&#123;left&#125;\",\"top\":\"$&#123;top&#125;\",\"width\":\"$&#123;width&#125;\",\"height\":\"$&#123;height&#125;\"&#125;`;\</span></span><br><span class="line"><span class="string">                            return(jsonString)&#125; getURLandRect()"</span>, touchPoint.x, touchPoint.y];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.webView evaluateJavaScript:jsString completionHandler:^(<span class="keyword">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultDic = [SmallTools convertToDictionary:(<span class="built_in">NSString</span> *)result];</span><br><span class="line">        <span class="built_in">NSString</span> *imageURL = [SmallTools isNullToString:resultDic[<span class="string">@"url"</span>]];</span><br><span class="line">        <span class="keyword">if</span> (imageURL.length == <span class="number">0</span> || [imageURL isEqualToString:<span class="string">@"undefined"</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CGFloat</span> imgX = [resultDic[<span class="string">@"left"</span>] floatValue];</span><br><span class="line">        <span class="built_in">CGFloat</span> imgY = [resultDic[<span class="string">@"top"</span>] floatValue] + NAV_HEIGHT + <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> imgW = [resultDic[<span class="string">@"width"</span>] floatValue];</span><br><span class="line">        <span class="built_in">CGFloat</span> imgH = [resultDic[<span class="string">@"height"</span>] floatValue];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.photoView = [[YHPhotoBrowser alloc]init];</span><br><span class="line">        <span class="keyword">self</span>.photoView.sourceView = <span class="keyword">self</span>.view; <span class="comment">//图片所在的父容器</span></span><br><span class="line">        <span class="keyword">self</span>.photoView.urlImgArr = @[imageURL]; <span class="comment">//网络链接图片的数组</span></span><br><span class="line">        <span class="keyword">if</span> (imgX &amp;&amp; imgY &amp;&amp; imgW &amp;&amp; imgH) &#123; <span class="comment">//原图片所在屏幕位置</span></span><br><span class="line">            <span class="keyword">self</span>.photoView.sourceRect = <span class="built_in">CGRectMake</span>(imgX, imgY, imgW, imgH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.photoView.indexTag = <span class="number">0</span>; <span class="comment">//初始化进去显示的图片下标</span></span><br><span class="line">        [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.photoView]; <span class="comment">//叠加在当前VC上</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个JS方法<code>document.elementFromPoint(%f, %f)</code>根据传入的点返回该点最上层的对象，通过<code>src</code>找到图片的链接，然后<code>getBoundingClientRect()</code>方法能返回对象的八个属性<code>left, top, right, bottom, x, y, width, height</code>，根据需要获取相应属性构造原图的<code>CGRect</code>即可</p><p>这里附带一下判断<code>NSString</code>合法性以及<code>JSON</code>字符串转<code>NSDictionary</code>的工具方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)isNullToString:(<span class="keyword">id</span>)string &#123;</span><br><span class="line">    <span class="keyword">if</span> ([string isEqual:<span class="string">@"NULL"</span>] || [string isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || [string isEqual:[<span class="built_in">NSNull</span> null]] || [string isEqual:<span class="literal">NULL</span>] || [[string <span class="keyword">class</span>] isSubclassOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || string == <span class="literal">nil</span> || string == <span class="literal">NULL</span> || [string isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || [[string stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> whitespaceAndNewlineCharacterSet]] length]==<span class="number">0</span> || [string isEqualToString:<span class="string">@"&lt;null&gt;"</span>] || [string isEqualToString:<span class="string">@"(null)"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">NSString</span> *)string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)convertToDictionary:(<span class="built_in">NSString</span> *)jsonStr &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [jsonStr dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *tempDic = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="number">0</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> tempDic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—并查集相关题目</title>
      <link href="/2019-05-24-leetcode-union-find/"/>
      <url>/2019-05-24-leetcode-union-find/</url>
      
        <content type="html"><![CDATA[<p>有关并查集 Union Find Set 的做题笔记，Python实现</p><a id="more"></a><h2 id="200-岛屿的个数-Number-of-Islands"><a href="#200-岛屿的个数-Number-of-Islands" class="headerlink" title="200. 岛屿的个数 Number of Islands"></a>200. 岛屿的个数 Number of Islands</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">LeetCodeCN 第200题链接</a></p><p>第一种方法：构造一个简单的并查集，将输入的二维数组坐标一维化。</p><p>实例化并查集对象后，遍历二维数组，发现为<code>1</code>时对该节点上下左右都执行一次<code>union()</code>，将这上下左右的<code>1</code> （如果是的话）的<code>parent</code>指向当前节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.parent = [<span class="number">-1</span>] * (n*m)</span><br><span class="line">        <span class="comment"># self.rank = [0] * (n*m)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    self.parent[i*m + j] = i*m + j</span><br><span class="line">                    self.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在查找的同时，也把节点换绑到根节点上了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[i] != i:</span><br><span class="line">            self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        <span class="keyword">return</span> self.parent[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        uf = UnionFind(grid)</span><br><span class="line">        directions = [(<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">-1</span>), (<span class="number">-1</span>,<span class="number">0</span>), (<span class="number">1</span>,<span class="number">0</span>)]</span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    <span class="keyword">for</span> x, y <span class="keyword">in</span> directions:</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= i+x &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= j+y &lt; m <span class="keyword">and</span> grid[i+x][j+y] == <span class="string">'1'</span>:</span><br><span class="line">                            uf.union(i*m+j, (i+x)*m+(j+y))</span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br></pre></td></tr></table></figure><p>第二种方法：染色解法，DFS深度优先搜索清除相邻岛屿，遍历二维数组，发现为<code>1</code>时岛屿数量加1，同时DFS将自身及周边相邻（上下左右）位置递归置<code>0</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.grid, count = grid, <span class="number">0</span></span><br><span class="line">        self.n, self.m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    self.dfs(i, j)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; self.n <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; self.m <span class="keyword">and</span> self.grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">            self.grid[i][j] = <span class="string">'0'</span></span><br><span class="line">            self.dfs(i<span class="number">-1</span>, j)</span><br><span class="line">            self.dfs(i+<span class="number">1</span>, j)</span><br><span class="line">            self.dfs(i, j<span class="number">-1</span>)</span><br><span class="line">            self.dfs(i, j+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>第三种方法：染色解法，BFS广度优先搜索清除相邻岛屿，遍历二维数组，发现为<code>1</code>时岛屿数量加1，同时BFS将自身及周边相邻（上下左右）位置用队列逐个置<code>0</code>，把上面的DFS的递归改成BFS的队列即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.grid, count = grid, <span class="number">0</span></span><br><span class="line">        self.n, self.m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    self.bfs(i, j)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((i, j))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i, j = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; self.n <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; self.m <span class="keyword">and</span> self.grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                self.grid[i][j] = <span class="string">'0'</span></span><br><span class="line">                queue.append((i<span class="number">-1</span>, j))</span><br><span class="line">                queue.append((i+<span class="number">1</span>, j))</span><br><span class="line">                queue.append((i, j<span class="number">-1</span>))</span><br><span class="line">                queue.append((i, j+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="547-朋友圈-Friend-Circles"><a href="#547-朋友圈-Friend-Circles" class="headerlink" title="547. 朋友圈 Friend Circles"></a>547. 朋友圈 Friend Circles</h2><p><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">LeetCodeCN 第547题</a></p><p>第一种方法：构造一个简单的并查集，将输入的二维数组坐标一维化。</p><p>实例化并查集对象后，遍历二维数组，发现为<code>1</code>时对该节点上下左右都执行一次<code>union()</code>，将这上下左右的<code>1</code> （如果是的话）的<code>parent</code>指向当前节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        self.n = len(M)</span><br><span class="line">        self.parent = list(range(self.n))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在查找的同时，也把节点换绑到根节点上了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[i] != i:</span><br><span class="line">            self.parent[i] = self.find(self.parent[i])</span><br><span class="line">        <span class="keyword">return</span> self.parent[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        rootx = self.find(x)</span><br><span class="line">        rooty = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootx != rooty:</span><br><span class="line">            self.parent[rooty] = rootx</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diff_groups</span><span class="params">(self)</span>:</span></span><br><span class="line">        diff_groups = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            diff_groups.add(self.find(i))</span><br><span class="line">        <span class="keyword">return</span> len(diff_groups)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span> -&gt; int:</span></span><br><span class="line">        uf = UnionFind(M)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M)):</span><br><span class="line">                <span class="keyword">if</span> M[i][j]:</span><br><span class="line">                    uf.union(i, j)</span><br><span class="line">        <span class="keyword">return</span> uf.diff_groups()</span><br></pre></td></tr></table></figure><p>第二种方法：DFS， 首先我们进行情景转换，如果把每个同学看作一个城市，同学与同学之间的朋友关系表示两个城市之间存在公路（可互相到达）。那么朋友圈的个数就转换为城市圈的个数。我们每次从整个城市集合中挑选出一个未访问的城市，接着我们访问它所能到达的所有城市（递归，深度优先搜索）。那么我们挑选了几次就是访问到了多少个城市圈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> M:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.M, self.n, self.visited, count = M, len(M), set(), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    self.dfs(i)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(self.n):</span><br><span class="line">            <span class="keyword">if</span> self.M[i][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</span><br><span class="line">                self.visited.add(j)</span><br><span class="line">                self.dfs(j)</span><br></pre></td></tr></table></figure><p>第三种方法：BFS，把上面的DFS的递归写法改成BFS的队列即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> M:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, visited, count, queue = len(M), set(), <span class="number">0</span>, deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                queue.append(i)</span><br><span class="line">                <span class="keyword">while</span> queue:</span><br><span class="line">                    p = queue.popleft()</span><br><span class="line">                    visited.add(p)</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                        <span class="keyword">if</span> M[p][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                            queue.append(j)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粗谈iOS中 weak、self、循环引用的二三事</title>
      <link href="/2019-05-21-ios-weakself-retain-cycle/"/>
      <url>/2019-05-21-ios-weakself-retain-cycle/</url>
      
        <content type="html"><![CDATA[<p>有关weak、self、循环引用的一些问题</p><h2 id="0-什么是循环引用，后果是什么"><a href="#0-什么是循环引用，后果是什么" class="headerlink" title="0. 什么是循环引用，后果是什么"></a>0. 什么是循环引用，后果是什么</h2><a id="more"></a><p>循环引用可以简单理解为<code>A</code>引用了<code>B</code>，而<code>B</code>又引用了<code>A</code>，双方都同时保持对方的一个引用，导致任何时候引用计数都不为<code>0</code>，始终无法释放。若当前对象是一个<code>ViewController</code>，则在<code>dismiss</code>或者<code>pop</code>之后其<code>dealloc</code>无法被调用，在频繁的<code>push</code>或者<code>present</code>之后内存暴增，就会Crash。</p><p><a href="https://paaatrick.com/2019-05-19-ios-arc-gc/">关于ARC的介绍</a></p><h2 id="1-在使用block时，为了避免产生循环引用，通常会使用weakSelf与strongSelf，例如如下代码，那么什么时候在-block里面用self，什么时候不需要使用weakSelf"><a href="#1-在使用block时，为了避免产生循环引用，通常会使用weakSelf与strongSelf，例如如下代码，那么什么时候在-block里面用self，什么时候不需要使用weakSelf" class="headerlink" title="1. 在使用block时，为了避免产生循环引用，通常会使用weakSelf与strongSelf，例如如下代码，那么什么时候在  block里面用self，什么时候不需要使用weakSelf"></a>1. 在使用<code>block</code>时，为了避免产生循环引用，通常会使用<code>weakSelf</code>与<code>strongSelf</code>，例如如下代码，那么什么时候在  <code>block</code>里面用<code>self</code>，什么时候不需要使用<code>weakSelf</code></h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span> doSomeBlockJob:^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当 <code>block</code> 本身不被 <code>self</code> 持有，而被别的对象持有，同时不产生循环引用的时候，就不需要使用 <code>weakSelf</code> 了。最常见的代码就是 <code>UIView</code> 的动画代码，我们在使用 <code>UIView</code> 的 <code>animateWithDuration:animations</code> 方法做动画的时候，并不需要使用 <code>weakSelf</code>，因为引用持有关系是：</p><ul><li><code>UIView</code> 的某个负责动画的对象持有了 <code>block</code></li><li><code>block</code> 持有了 <code>self</code></li></ul><p>因为 <code>self</code> 并不持有 <code>block</code>，所以就没有循环引用产生，因为就不需要使用 <code>weakSelf</code> 了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.2</span> animations:^&#123;</span><br><span class="line">    <span class="keyword">self</span>.alpha = <span class="number">1</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当动画结束时，<code>UIView</code> 会结束持有这个 <code>block</code>，如果没有别的对象持有 <code>block</code> 的话，<code>block</code> 对象就会释放掉，从而 <code>block</code> 会释放掉对于 <code>self</code> 的持有。整个内存引用关系被解除。</p><h2 id="2-block-里面还需要写一个-strongSelf-的原因，如果不写会发生什么"><a href="#2-block-里面还需要写一个-strongSelf-的原因，如果不写会发生什么" class="headerlink" title="2. block 里面还需要写一个 strongSelf 的原因，如果不写会发生什么"></a>2. <code>block</code> 里面还需要写一个 <code>strongSelf</code> 的原因，如果不写会发生什么</h2><p>外部的<code>weakSelf</code>是为了打破环，从而使得没有循环引用，而内部的<code>strongSelf</code>仅仅是个局部变量，存在栈中，会在<code>block</code>执行结束后回收，不会再造成循环引用。</p><p>在 <code>block</code> 中先写一个 <code>strongSelf</code>，其实是为了避免在 <code>block</code> 的执行过程中，突然出现 <code>self</code> 被释放的尴尬情况。通常情况下，如果不这么做的话，还是很容易出现一些奇怪的逻辑，甚至闪退。</p><p>以 <code>AFNetworking</code> 中 <code>AFNetworkReachabilityManager.m</code> 的一段代码举例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    strongSelf.networkReachabilityStatus = status;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">        strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果没有 <code>strongSelf</code> 的那行代码，那么后面的每一行代码执行时，<code>self</code> 都可能被释放掉了，这样很可能造成逻辑异常。</p><p>特别是当我们正在执行 <code>strongSelf.networkReachabilityStatusBlock(status);</code>这个 <code>block</code> 闭包时，如果这个 <code>block</code> 执行到一半时 <code>self</code> 释放，那么多半情况下会 Crash。</p><h2 id="3-有没有这样一个需求场景，block-会产生循环引用，但是业务又需要你不能使用-weakSelf-如果有，请举一个例子并且解释这种情况下如何解决循环引用问题。"><a href="#3-有没有这样一个需求场景，block-会产生循环引用，但是业务又需要你不能使用-weakSelf-如果有，请举一个例子并且解释这种情况下如何解决循环引用问题。" class="headerlink" title="3. 有没有这样一个需求场景，block 会产生循环引用，但是业务又需要你不能使用 weakSelf? 如果有，请举一个例子并且解释这种情况下如何解决循环引用问题。"></a>3. 有没有这样一个需求场景，<code>block</code> 会产生循环引用，但是业务又需要你不能使用 <code>weakSelf</code>? 如果有，请举一个例子并且解释这种情况下如何解决循环引用问题。</h2><p>需要不使用 <code>weakSelf</code> 的场景是：你需要构造一个循环引用，以便保证引用双方都存在。比如你有一个后台的任务，希望任务执行完后，通知另外一个实例。在 <code>YTKNetwork</code> 网络库的源码中，就有这样的场景。</p><p>在 <code>YTKNetwork</code> 库中，我们的每一个网络请求 API 会持有回调的 <code>block</code>，回调的 <code>block</code> 会持有 <code>self</code>，而如果 <code>self</code> 也持有网络请求 API 的话，我们就构造了一个循环引用。虽然我们构造出了循环引用，但是因为在网络请求结束时，网络请求 API 会主动释放对 <code>block</code> 的持有，因此，整个循环链条被解开，循环引用就被打破了，所以不会有内存泄漏问题。代码其实很简单，如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  YTKBaseRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</span><br><span class="line">    <span class="comment">// nil out to break the retain cycle.</span></span><br><span class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，解决循环引用问题主要有两个办法：</p><p>第一个办法是「事前避免」，我们在会产生循环引用的地方使用 <code>weak</code> 弱引用，以避免产生循环引用。</p><p>第二个办法是「事后补救」，我们明确知道会存在循环引用，但是我们在合理的位置主动断开环中的一个引用，使得对象得以回收。</p><h2 id="4-weak-变量在引用计数为0时，会被自动设置成-nil-的这个特性的实现原理"><a href="#4-weak-变量在引用计数为0时，会被自动设置成-nil-的这个特性的实现原理" class="headerlink" title="4. weak 变量在引用计数为0时，会被自动设置成 nil 的这个特性的实现原理"></a>4. weak 变量在引用计数为0时，会被自动设置成 nil 的这个特性的实现原理</h2><blockquote><p>简单来说，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 <code>0</code> 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 <code>nil</code>。<br>所以使用<code>weak</code>会有额外的开销</p></blockquote><p>在 Friday QA 上，<a href="https://mikeash.com/pyblog/friday-qa-2010-07-16-zeroing-weak-references-in-objective-c.html" target="_blank" rel="noopener">有一期专门介绍</a> <code>weak</code> 的实现原理。</p><p>《Objective-C高级编程》一书中也介绍了相关的内容。</p><p>系统有一个全局的 <code>CFMutableDictionary</code> 实例，来保存每个对象的 <code>weak</code> 指针列表，因为每个对象可能有多个 <code>weak</code> 指针，所以这个实例的值是 <code>CFMutableSet</code> 类型。</p><p>剩下我们要做的，就是在引用计数变成 <code>0</code> 的时候，去这个全局的字典里面，找到所有的 <code>weak</code> 指针，将其值设置成 <code>nil</code>。如何做到这一点呢？Friday QA 上介绍了一种类似 <code>KVO</code> 实现的方式。当对象存在 <code>weak</code> 指针时，我们可以将这个实例指向一个新创建的子类，然后修改这个子类的 <code>release</code> 方法，在 <code>release</code> 方法中，去从全局的 <code>CFMutableDictionary</code> 字典中找到所有的 <code>weak</code> 对象，并且设置成 <code>nil</code>。我摘抄了 Friday QA 上的实现的核心代码，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class subclass = objc_allocateClassPair(class, newNameC, 0);</span><br><span class="line">Method release = class_getInstanceMethod(class, @selector(release));</span><br><span class="line">Method dealloc = class_getInstanceMethod(class, @selector(dealloc));</span><br><span class="line">class_addMethod(subclass, @selector(release), (IMP)CustomSubclassRelease, method_getTypeEncoding(release));</span><br><span class="line">class_addMethod(subclass, @selector(dealloc), (IMP)CustomSubclassDealloc, method_getTypeEncoding(dealloc));</span><br><span class="line">objc_registerClassPair(subclass);</span><br></pre></td></tr></table></figure><p>当然，这并不代表苹果官方是这么实现的，因为苹果的这部分代码并没有开源。《Objective-C高级编程》一书中介绍了 <code>GNUStep</code> 项目中的开源代码，思想也是类似的。所以我认为虽然实现细节会有差异，但是大致的实现思路应该差别不大。</p><h2 id="5-如果有一些-UI-控件我们要用代码的方式来创建，那么它应该用-weak-还是-strong"><a href="#5-如果有一些-UI-控件我们要用代码的方式来创建，那么它应该用-weak-还是-strong" class="headerlink" title="5. 如果有一些 UI 控件我们要用代码的方式来创建，那么它应该用 weak 还是 strong"></a>5. 如果有一些 <code>UI</code> 控件我们要用代码的方式来创建，那么它应该用 <code>weak</code> 还是 <code>strong</code></h2><p>我们知道，从 <code>Storyboard</code> 往编译器拖出来的 <code>UI</code> 控件的属性是 <code>weak</code> 的，如下所示</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIButton</span> *myButton;</span><br></pre></td></tr></table></figure><p>那么如果有一些 <code>UI</code> 控件我们要用代码的方式来创建，那么它应该用 <code>weak</code> 还是 <code>strong</code>?</p><blockquote><p>从上面弱引用自动置<code>nil</code>的原理可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 <code>weak</code> 的，这某种程度上与 <code>Xcode</code> 通过 <code>Storyboard</code> 拖拽生成的新变量是一致的。</p></blockquote><p><code>UI</code> 控件用默认用 <code>weak</code>，根源还是苹果希望只有这些 <code>UI</code> 控件的父 <code>View</code> 来强引用它们，而 <code>ViewController</code> 只需要强引用 <code>ViewController.view</code> 成员，则可以间接持有所有的 <code>UI</code> 控件。这样有一个好处是：在以前，当系统收到 <code>Memory Warning</code> 时，会触发 <code>ViewController</code> 的 <code>viewDidUnload</code> 方法，这样的弱引用方式，可以让整个 <code>view</code> 整体都得到释放，也更方便重建时整体重新构造。</p><p>但是首先 <code>viewDidUnload</code> 方法在 <code>iOS 6</code> 开始就被废弃掉了，苹果用了更简单有效地方式来解决内存警告时的视图资源释放，具体如何做的呢？嗯，这个可以当作某一期的面试题展开介绍。总之就是，除非你特殊地操作 <code>view</code> 成员，<code>ViewController.view</code> 的生命期和 <code>ViewController</code> 是一样的了。</p><p>所以在这种情况下，其实 <code>UI</code> 控件是不是 <code>weak</code> 其实关系并不大。当 <code>UI</code> 控件是 <code>weak</code> 时，它的引用计数是 <code>1</code>，持有它的是它的 <code>superview</code>，当 <code>UI</code> 控件是 <code>strong</code> 时，它的引用计数是 <code>2</code>，持有它的有两个地方，一个是它的 <code>superview</code>，另一个是这个 <code>strong</code> 的指针。<code>UI</code> 控件并不会持有别的对象，所以，不管是手写代码还是 <code>Storyboard</code>，<code>UI</code> 控件是 <code>strong</code> 都不会有循环引用的。</p><p>那么回到我们的最初的问题，自己写的 <code>view</code> 成员，应该用 <code>weak</code> 还是 <code>strong</code>？我个人觉得应该用 <code>strong</code>，因为用 <code>weak</code> 并没有什么特别的优势，而且由上面 <code>weak</code>的实现来看，<code>weak</code> 变量会有额外的系统维护开销的，如果你没有使用它的特别的理由，那么用 <code>strong</code> 的话应该更好。</p><p>另外如果要做懒加载，那么你也只能选择用 <code>strong</code>。</p><p>当然，如果你非要用 <code>weak</code>，其实也没什么问题，只需要注意在赋值前，先把这个对象用 <code>addSubView</code> 加到父 <code>view</code> 上，否则可能刚刚创建完，它就被释放了。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—DP动态规划相关题目</title>
      <link href="/2019-05-20-leetcode-dynamic-programming/"/>
      <url>/2019-05-20-leetcode-dynamic-programming/</url>
      
        <content type="html"><![CDATA[<p>有关动态规划 Dynamic Programming 的做题笔记，Python实现</p><a id="more"></a><h2 id="70-爬楼梯-Climbing-Stairs"><a href="#70-爬楼梯-Climbing-Stairs" class="headerlink" title="70. 爬楼梯 Climbing Stairs"></a>70. 爬楼梯 Climbing Stairs</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCodeCN 第70题链接</a></p><p>第一种方法：递归，显然是个斐波那契数列，时间复杂度 $O(2^n)$很高，这样没法通过LeetCode，参考 @wikizero 的解法可以加个LRU缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from functools import lru_cache</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>        </span><br><span class="line">    <span class="comment"># @lru_cache(10**8)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n - <span class="number">1</span>) + self.climbStairs(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>第二种方法：动态规划，用数组记录每个台阶的所有走法个数，时间复杂度降为 $O(n)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        f = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><p>第三种方法：动态规划，由于只需要返回最后一步的所有走法个数，不需要数组记录过程，利用Python的同时赋值特性，只需两个变量就行，空间复杂度降为 $O(1)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        x = y = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            x, y = x+y, x</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="120-三角形最小路径和-Triangle"><a href="#120-三角形最小路径和-Triangle" class="headerlink" title="120. 三角形最小路径和 Triangle"></a>120. 三角形最小路径和 Triangle</h2><p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">LeetCodeCN 第120题链接</a></p><p>第一种方法：递归，时间复杂度<code>O(2^n)</code>，LeetCode会超时过不了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        self.tri = triangle</span><br><span class="line">        self.path = []</span><br><span class="line">        self.helper(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> min(self.path)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, i, j, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= len(self.tri):</span><br><span class="line">            self.path.append(res)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res += self.tri[i][j]</span><br><span class="line">        self.helper(i+<span class="number">1</span>, j, res)</span><br><span class="line">        self.helper(i+<span class="number">1</span>, j+<span class="number">1</span>, res)</span><br></pre></td></tr></table></figure><p>第二种方法：动态规划，新建个二维数组<code>mini</code>，定义<code>mini[i][j]</code>为从三角形底部到<code>[i][j]</code>的最小路径和，递推公式<code>mini[i][j] = triangle[i][j] + min(mini[i+1][j], mini[i+1][j+1])</code>即本身节点的值加上下一层<code>[i+1]</code>里相邻两个节点<code>mini</code>的最小值，首先把三角形最后一层赋值给<code>mini</code>的最后一层，然后两个循环，最后得到<code>mini[0][0]</code>三角形顶部节点，时间复杂度<code>O(n^2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        lens = len(triangle)</span><br><span class="line">        mini = [[<span class="number">0</span>]*lens <span class="keyword">for</span> _ <span class="keyword">in</span> range(lens)]</span><br><span class="line">        mini[lens<span class="number">-1</span>] = triangle[lens<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lens<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                mini[i][j] = triangle[i][j] + min(mini[i+<span class="number">1</span>][j], mini[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> mini[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>第三种方法：在第二种方法的基础上，<code>mini</code>只需一维数组即可，更新自身</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        mini = triangle[len(triangle)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                mini[j] = triangle[i][j] + min(mini[j], mini[j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> mini[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>第四种方法：在第二种方法的基础上，直接修改三角形数组的值，空间复杂度为<code>O(1)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(triangle)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(triangle[i])):</span><br><span class="line">                triangle[i][j] += min(triangle[i+<span class="number">1</span>][j], triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="152-乘积最大子序列-Maximum-Product-Subarray"><a href="#152-乘积最大子序列-Maximum-Product-Subarray" class="headerlink" title="152. 乘积最大子序列 Maximum Product Subarray"></a>152. 乘积最大子序列 Maximum Product Subarray</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LeetCodeCN 第152题链接</a></p><p>第一种方法：DP动态规划，创建二维数组<code>dp</code>，<code>dp[i][0]</code>存放正数最大值, <code>dp[i][1]</code>存放最小值即负数的最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>]*nums[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]*nums[i], nums[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = min(dp[i<span class="number">-1</span>][<span class="number">0</span>]*nums[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]*nums[i], nums[i])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> dp:</span><br><span class="line">            result.append(j[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> max(result)</span><br></pre></td></tr></table></figure><p>第二种方法：在第一种方法的基础上，用一维滚动数组<code>dp</code>，每次循环交替x和y为0和1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> nums <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>], res = nums[<span class="number">0</span>], nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            x, y = i &amp; <span class="number">1</span>, (i - <span class="number">1</span>) &amp; <span class="number">1</span></span><br><span class="line">            dp[x][<span class="number">0</span>] = max(dp[y][<span class="number">0</span>]*nums[i], dp[y][<span class="number">1</span>]*nums[i], nums[i])</span><br><span class="line">            dp[x][<span class="number">1</span>] = min(dp[y][<span class="number">0</span>]*nums[i], dp[y][<span class="number">1</span>]*nums[i], nums[i])</span><br><span class="line">            res = max(res, dp[x][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="300-最长上升子序列-Longest-Increasing-Subsequence"><a href="#300-最长上升子序列-Longest-Increasing-Subsequence" class="headerlink" title="300. 最长上升子序列 Longest Increasing Subsequence"></a>300. 最长上升子序列 Longest Increasing Subsequence</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LeetCodeCN 第300题链接</a></p><p>DP动态规划，定义状态<code>dp[i]</code>为以<code>nums[i]</code>为结尾且必须包含<code>nums[i]</code>本身的最长上升子序列的长度。两个嵌套的循环，状态转移方程<code>dp[i] = max(dp[i], dp[j] + 1)</code>即在内层循环内通过比较<code>dp[j]</code>来不断迭代<code>dp[i]</code>，找到前面最大的一个<code>dp</code>值然后加1。最后<code>dp</code>数组的最大值就是问题的解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换-Coin-Change"><a href="#322-零钱兑换-Coin-Change" class="headerlink" title="322. 零钱兑换 Coin Change"></a>322. 零钱兑换 Coin Change</h2><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LeetCodeCN 第322题链接</a></p><p>第一种方法：DFS深度优先搜索，暴力操作，LeetCode会超时过不去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        self.coins = sorted(coins, reverse=<span class="literal">True</span>)</span><br><span class="line">        self.res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.coins:</span><br><span class="line">            self.dfs(amount, i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.res:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> min(self.res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, amount, num, count)</span>:</span></span><br><span class="line">        last = amount - num</span><br><span class="line">        <span class="keyword">if</span> last &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> last:</span><br><span class="line">            self.res.append(count)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.coins:</span><br><span class="line">            self.dfs(last, i, count + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>第二种方法：DP动态规划，定义状态<code>dp[i]</code>为拼凑数额<code>i</code>最少所需的硬币数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [amount+<span class="number">1</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> i - c &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i] = min(dp[i], dp[i-c] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] &lt;= amount <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>第三种方法：把<code>coins</code>的循环放外层，减少循环次数及一次<code>if</code>判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] + [amount+<span class="number">1</span>]*amount</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(coin, amount+<span class="number">1</span>):</span><br><span class="line">                dp[i] = min(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] != amount+<span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="72-编辑距离-Edit-Distance"><a href="#72-编辑距离-Edit-Distance" class="headerlink" title="72. 编辑距离 Edit Distance"></a>72. 编辑距离 Edit Distance</h2><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCodeCN 第72题链接</a></p><p>第一种方法：BFS暴力求解</p><p>第二种方法：DP动态规划，定义状态<code>dp[i][j]</code> 表示<code>word1</code>的前<code>i</code>个字母和<code>word2</code>的前<code>j</code>个字母之间的编辑距离，即<code>word1</code>的前<code>i</code>个字符要替换到<code>word2</code>的前<code>j</code>个字符所需要的最少操作次数。当<code>word1[i-1] == word2[j-1]</code>时，<code>dp[i][j]</code>的状态就是直接转移<code>dp[i-1][j-1]</code>，无需任何步骤，否则，<code>dp[i][j]</code>的状态来自<code>dp[i-1][j], dp[i][j-1], dp[i-1][j-1]</code>（添加、删除、替换）中的最小值并加操作步骤<code>1</code>次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        n, m = len(word1), len(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 上面的if else逻辑可以压缩成一行</span></span><br><span class="line">                <span class="comment"># dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(0 if word1[i-1] == word2[j-1] else 1))</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure><h2 id="42-接雨水-Trapping-Rain-Water"><a href="#42-接雨水-Trapping-Rain-Water" class="headerlink" title="42. 接雨水 Trapping Rain Water"></a>42. 接雨水 Trapping Rain Water</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LeetCodeCN 第42题链接</a></p><p>第一种方法：DP动态规划，计算出每个点的左边界最大与右边界最大，最后减去自身高度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, res = len(height), <span class="number">0</span></span><br><span class="line">        maxLeft, maxRight = [<span class="number">0</span>]*n, [<span class="number">0</span>]*n</span><br><span class="line">        maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">        maxRight[<span class="number">-1</span>] = height[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            maxLeft[i] = max(height[i], maxLeft[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            maxRight[j] = max(height[j], maxRight[j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            res += min(maxLeft[k], maxRight[k]) - height[k]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>第二种方法：双指针，每次矮边向内推进，如果自身不是该边最大值证明有更大的边，就可以接雨水了，否则更新自己为该边最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, r, left_max, right_max, res = <span class="number">0</span>, len(height)<span class="number">-1</span>, height[<span class="number">0</span>], height[<span class="number">-1</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> height[r] &gt;= height[l]:</span><br><span class="line">                <span class="keyword">if</span> left_max &gt; height[l]:</span><br><span class="line">                    res += left_max - height[l]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left_max = height[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> right_max &gt; height[r]:</span><br><span class="line">                    res += right_max - height[r]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right_max = height[r]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="62-不同路径-Unique-Paths"><a href="#62-不同路径-Unique-Paths" class="headerlink" title="62. 不同路径 Unique Paths"></a>62. 不同路径 Unique Paths</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">LeetCodeCN 第62题链接</a></p><p>标准的动态规划，从右下目标点往左上走，dp储存当前点位共有多少种走法，<code>dp[i][j]的走法数量 = dp[i+1][j] + dp[i][j+1]</code> 底边和最右边格子都是1，所以创建dp数组时顺便把初始化也完成了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> m <span class="keyword">or</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="63-不同路径-II-Unique-Paths-II"><a href="#63-不同路径-II-Unique-Paths-II" class="headerlink" title="63. 不同路径 II Unique Paths II"></a>63. 不同路径 II Unique Paths II</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LeetCodeCN 第63题链接</a></p><p>与上题62题思路一样，从右下目标点往左上走，dp储存当前点位共有多少种走法，<code>dp[i][j]的走法数量 = dp[i+1][j] + dp[i][j+1]</code>，不过因为有障碍物需要额外处理一下，分别初始化底边和最右边。然后迭代时判断一下障碍物即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid <span class="keyword">or</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, m = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">1</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># 处理最右列的初始值</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                dp[i][m<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][m<span class="number">-1</span>]:</span><br><span class="line">                dp[i][m<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 处理最下行的初始值</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                dp[n<span class="number">-1</span>][i] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[n<span class="number">-1</span>][i]:</span><br><span class="line">                dp[n<span class="number">-1</span>][i] = <span class="number">0</span></span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 从右下到左上的DP递推</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j] + dp[i][j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="64-最小路径和-Minimum-Path-Sum"><a href="#64-最小路径和-Minimum-Path-Sum" class="headerlink" title="64. 最小路径和 Minimum Path Sum"></a>64. 最小路径和 Minimum Path Sum</h2><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">LeetCodeCN 第64题链接</a></p><p>动态规划，定义DP二维数组储存的是经过该点位的最小路径和，首先初始化好最右边和底边的初始值，然后从目标右下递推到起始点左上，<code>dp[0][0]</code>即结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">-1</span>][<span class="number">-1</span>] = grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i][m<span class="number">-1</span>] = grid[i][m<span class="number">-1</span>] + dp[i+<span class="number">1</span>][m<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[n<span class="number">-1</span>][i] = grid[n<span class="number">-1</span>][i] + dp[n<span class="number">-1</span>][i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[i][j] = min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>用滚动数组降低空间复杂度，从左上角往右下角迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + grid[<span class="number">0</span>][i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            x, y = i&amp;<span class="number">1</span>, (i<span class="number">-1</span>)&amp;<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[x][j] = dp[y][j] + grid[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[x][j] = min(dp[y][j], dp[x][j<span class="number">-1</span>]) + grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">-1</span>] <span class="keyword">if</span> m&amp;<span class="number">1</span> <span class="keyword">else</span> dp[<span class="number">1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="198-打家劫舍-House-Robber"><a href="#198-打家劫舍-House-Robber" class="headerlink" title="198. 打家劫舍 House Robber"></a>198. 打家劫舍 House Robber</h2><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">LeetCodeCN 第198题链接</a></p><p>第一种方法：动态规划，递推方程<code>f(i) = max(f(i-1), f(i-2)+nums[i])</code>，当前点位最大利润可能来自前一个点位的最大利润（当前点位不偷）或者来自前两个点位的最大利润加上偷当前点位。开一个长度为<code>n</code>的数组记录，取数组末尾即结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*n</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>第二种方法：用滚动数组降低空间复杂度，<code>O(n)→O(1)</code>，无需改动太多代码，适合面试时改进代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        dp = [<span class="number">0</span>]*<span class="number">2</span></span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            x, y = i&amp;<span class="number">1</span>, (i+<span class="number">1</span>)&amp;<span class="number">1</span></span><br><span class="line">            dp[x] = max(dp[y], dp[x]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> max(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串-Longest-Palindromic-Substring"><a href="#5-最长回文子串-Longest-Palindromic-Substring" class="headerlink" title="5. 最长回文子串 Longest Palindromic Substring"></a>5. 最长回文子串 Longest Palindromic Substring</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCodeCN 第5题链接</a></p><p>第一种方法：动态规划，定义<code>dp[i][j]</code>为从位置<code>j</code>到<code>i</code>的字符串是否是回文串，递推式子是<code>if (s[i] == s[j] and dp[i-1][j+1]) then dp[i][j] = 1</code>其中加入一个判断如果子串长度为2就不用看<code>dp</code>了加速计算。然后如果<code>dp[i][j]</code>是回文串了，就跟当前最长的回文串比较，如果新的更长就更新结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        maxLen, res, dp = <span class="number">0</span>, <span class="string">''</span>, [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (i-j&lt;<span class="number">2</span> <span class="keyword">or</span> dp[i<span class="number">-1</span>][j+<span class="number">1</span>]):</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> maxLen &lt; i-j+<span class="number">1</span>:</span><br><span class="line">                    maxLen = i-j+<span class="number">1</span></span><br><span class="line">                    res = s[j:i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h2 id="动态规划——买卖股票最佳时机系列题链接"><a href="#动态规划——买卖股票最佳时机系列题链接" class="headerlink" title="动态规划——买卖股票最佳时机系列题链接"></a><a href="https://paaatrick.com/2019-05-18-leetcode-best-time-to-buy-and-sell-stock-series/">动态规划——买卖股票最佳时机系列题链接</a></h2><hr>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粗谈ARC自动引用计数和GC垃圾回收</title>
      <link href="/2019-05-19-ios-arc-gc/"/>
      <url>/2019-05-19-ios-arc-gc/</url>
      
        <content type="html"><![CDATA[<p>粗谈ARC自动引用计数和GC垃圾回收</p><h2 id="1-ARC-自动引用计数"><a href="#1-ARC-自动引用计数" class="headerlink" title="1. ARC 自动引用计数"></a>1. ARC 自动引用计数</h2><a id="more"></a><p>自动引用计数（<code>Automatic Reference Count</code> 简称 <code>ARC</code>），是苹果在 WWDC 2011 年大会上提出的用于内存管理的技术。虽然 <code>ARC</code> 极大地简化了我们的内存管理工作，但是引用计数这种内存管理方案如果不被理解，那么就无法处理好那些棘手的循环引用问题。</p><p>引用计数（<code>Reference Count</code>）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 <code>1</code>，当有一个新的指针指向这个对象时，我们将其引用计数加 <code>1</code>，当某个指针不再指向这个对象是，我们将其引用计数减 <code>1</code>，当对象的引用计数变为 <code>0</code> 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。由于引用计数简单有效，除了 <code>Objective-C</code> 语言外，微软的 COM（Component Object Model ）、C++11（C++11 提供了基于引用计数的智能指针 share_prt）等语言也提供了基于引用计数的内存管理方式。</p><p>引用计数这种内存管理方式虽然简单，但是手工写大量的操作引用计数的代码不但繁琐，而且容易被遗漏。于是苹果在 2011 年引入了 <code>ARC</code>。<code>ARC</code> 顾名思义，是自动帮我们填写引用计数代码的一项功能。</p><p><code>ARC</code> 的想法来源于苹果在早期设计 <code>Xcode</code> 的 <code>Analyzer</code> 的时候，发现编译器在编译时可以帮助大家发现很多内存管理中的问题。后来苹果就想，能不能干脆编译器在编译的时候，把内存管理的代码都自动补上，带着这种想法，苹果修改了一些内存管理代码的书写方式（例如引入了 <code>@autoreleasepool</code> 关键字）后，在 <code>Xcode</code> 中实现了这个想法。</p><p><code>ARC</code> 的工作原理大致是这样：当我们编译源码的时候，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，来添加相应的引用计数操作代码。所以，<code>ARC</code> 是工作在编译期的一种技术方案，这样的好处是：</p><p>编译之后，<code>ARC</code> 与非 <code>ARC</code> 代码是没有什么差别的，所以二者可以在源码中共存。实际上，你可以通过编译参数 <code>-fno-objc-arc</code> 来关闭部分源代码的 <code>ARC</code> 特性。</p><p>相对于垃圾回收这类内存管理方案，<code>ARC</code> 不会带来运行时的额外开销，所以对于应用的运行效率不会有影响。相反，由于 <code>ARC</code> 能够深度分析每一个对象的生命周期，它能够做到比人工管理引用计数更加高效。例如在一个函数中，对一个对象刚开始有一个引用计数 <code>+1</code> 的操作，之后又紧接着有一个 <code>-1</code> 的操作，那么编译器就可以把这两个操作都优化掉。</p><p>但是也有人认为，<code>ARC</code> 也附带有运行期的一些机制来使 <code>ARC</code> 能够更好的工作，他们主要是指 <code>weak</code> 关键字。<code>weak</code> 变量能够在引用计数为 <code>0</code> 时被自动设置成 <code>nil</code>，显然是有运行时逻辑在工作的。我通常并没有把这个算在 <code>ARC</code> 的概念当中，当然，这更多是一个概念或定义上的分歧，因为除开 <code>weak</code> 逻辑之外，<code>ARC</code> 核心的代码都是在编译期填充的。</p><h2 id="2-GC-垃圾回收"><a href="#2-GC-垃圾回收" class="headerlink" title="2. GC 垃圾回收"></a>2. GC 垃圾回收</h2><p><code>Android</code> 手机通常使用 <code>Java</code> 来开发，而 <code>Java</code> 是使用垃圾回收这种内存管理方式。 那么，<code>ARC</code> 和垃圾回收对比，有什么优点和缺点？</p><p>虽然做 <code>iOS</code> 开发并不需要用到垃圾回收这种内存管理机制。但是垃圾回收被使用得非常普遍，不但有 <code>Java</code>，还包括 <code>JavaScript</code>, <code>C#</code>，<code>Go</code> 等语言。</p><h4 id="垃圾回收简介"><a href="#垃圾回收简介" class="headerlink" title="垃圾回收简介"></a>垃圾回收简介</h4><p>垃圾回收（<code>Garbage Collection</code>，简称 <code>GC</code>）这种内存管理机制最早由图灵奖获得者 John McCarthy 在 1959 年提出，垃圾回收的理论主要基于一个事实：大部分的对象的生命期都很短。</p><p>所以，<code>GC</code> 将内存中的对象主要分成两个区域：<code>Young</code> 区和 <code>Old</code> 区。对象先在 <code>Young</code> 区被创建，然后如果经过一段时间还存活着，则被移动到 <code>Old</code> 区。（其实还有一个 <code>Perm</code> 区，但是内存回收算法通常不涉及这个区域）</p><p><code>Young</code> 区和 <code>Old</code> 区因为对象的特点不一样，所以采用了两种完全不同的内存回收算法。</p><p><code>Young</code> 区的对象因为大部分生命期都很短，每次回收之后只有少部分能够存活，所以采用的算法叫 <code>Copying</code> 算法，简单说来就是直接把活着的对象复制到另一个地方。<code>Young</code> 区内部又分成了三块区域：<code>Eden</code> 区 , <code>From</code> 区 , <code>To</code> 区。每次执行 <code>Copying</code> 算法时，即将存活的对象从 <code>Eden</code> 区和 <code>From</code> 区复制到 <code>To</code> 区，然后交换 <code>From</code> 区和 <code>To</code> 区的名字（即 <code>From</code> 区变成 <code>To</code> 区，<code>To</code> 区变成 <code>From</code> 区）。</p><p><code>Old</code> 区的对象因为都是存活下来的老司机了，所以如果用 <code>Copying</code> 算法的话，很可能 <code>90%</code> 的对象都得复制一遍了，不划算啊！所以 <code>Old</code> 区的回收算法叫 <code>Mark-Sweep</code> 算法。简单来说，就是只是把不用的对象先标记（<code>Mark</code>）出来，然后回收（<code>Sweep</code>），活着的对象就不动它了。因为大部分对象都活着，所以回收下来的对象并不多。但是这个算法会有一个问题：它会产生内存碎片，所以它一般还会带有整理内存碎片的逻辑，在算法中叫做 <code>Compact</code>。如何整理呢？早年用过 <code>Windows</code> 的硬盘碎片整理程序的朋友可能能理解，其实就是把对象插到这些空的位置里。这里面还涉及很多优化的细节，我就不一一展开了。</p><p>讲完主要的算法，接下来 <code>GC</code> 需要解决的问题就只剩下如何找出需要回收的垃圾对象了。为了避免 <code>ARC</code> 解决不了的循环引用问题，<code>GC</code> 引入了一个叫做「可达性」的概念，应用这个概念，即使是有循环引用的垃圾对象，也可以被回收掉。下面就给大家介绍一下这个概念。</p><p>当 <code>GC</code> 工作时，<code>GC</code> 认为当前的一些对象是有效的，这些对象包括：全局变量，栈里面的变量等，然后 <code>GC</code> 从这些变量出发，去标记这些变量「可达」的其它变量，这个标记是一个递归的过程，最后就像从树根的内存对象开始，把所有的树枝和树叶都记成可达的了。那除了这些「可达」的变量，别的变量就都需要被回收了。</p><p>听起来很牛逼对不对？那为什么苹果不用呢？实际上苹果在 OS X 10.5 的时候还真用了，不过在 10.7 的时候把 <code>GC</code> 换成了 <code>ARC</code>。那么，<code>GC</code> 有什么问题让苹果不能忍，这就是：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：<code>Stop the World</code>。所以说，你知道 <code>Android</code> 手机有时候为什么会卡吧，<code>GC</code> 就相当于春运的最后一天返城高峰。当所有的对象都需要一起回收时，那种体验肯定是当时还在世的乔布斯忍受不了的。</p><p>看看下面这幅漫画，真实地展现出 <code>GC</code> 最尴尬的情况（漫画中提到的 <code>Full GC</code>，就是指执行 <code>Old</code> 区的内存回收）：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190603181612.webp" alt></p><p>当然，事实上经过多年的发展，<code>GC</code> 的回收算法一直在被优化，人们想了各种办法来优化暂停的时间，所以情况并没有那么糟糕。</p><h4 id="ARC-相对于-GC-的优点："><a href="#ARC-相对于-GC-的优点：" class="headerlink" title="ARC 相对于 GC 的优点："></a><code>ARC</code> 相对于 <code>GC</code> 的优点：</h4><p><code>ARC</code> 工作在编译期，在运行时没有额外开销。</p><p><code>ARC</code> 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 <code>GC</code> 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。</p><h4 id="ARC-相对于-GC-的缺点："><a href="#ARC-相对于-GC-的缺点：" class="headerlink" title="ARC 相对于 GC 的缺点："></a><code>ARC</code> 相对于 <code>GC</code> 的缺点：</h4><p><code>GC</code> 真的是太简单了，基本上完全不用处理内存管理问题，而 <code>ARC</code> 还是需要处理类似循环引用这种内存管理问题。</p><p><code>GC</code> 一类的语言相对来说学习起来更简单。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—买卖股票的最佳时机系列题目</title>
      <link href="/2019-05-18-leetcode-best-time-to-buy-and-sell-stock-series/"/>
      <url>/2019-05-18-leetcode-best-time-to-buy-and-sell-stock-series/</url>
      
        <content type="html"><![CDATA[<p>这是一套经典的动态规划题目，题目主干都是给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格，在不同的情况下求在什么时候买卖以获取最大利润。</p><a id="more"></a><ul><li>121题是只能买卖一次的情况下求最大利润；</li><li>122题可以买卖任意多次；</li><li>123题可以买卖两次；</li><li>188题是前面三题的泛化版本，给定参数k，求买卖k次情况下的最大利润；</li><li>309题是在122题买卖任意多次的基础上加上冷冻期即T+1才能卖出。</li></ul><p>其中买卖k次的188题是标准的三维动态规划题，用解这题的通用方可以稍加改造就能解决前三题，当然前三题也有单独的特定简单解法，这里为了练习还是重点看动态规划的解决方法。</p><p>在188题的基础上可以再变形出更多题目，比如现在这些题都是最多只能持有1股，如果可以持有n股（每天只能买入或卖出1股），也能用这个188题的三维DP通解来解决。</p><h2 id="121-买卖股票的最佳时机-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-买卖股票的最佳时机-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. 买卖股票的最佳时机 Best Time to Buy and Sell Stock"></a>121. 买卖股票的最佳时机 Best Time to Buy and Sell Stock</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">LeetCodeCN 第121题链接</a></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h3 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h3><p>第一种方法：由于一次交易操作，可以通过记录最小价格，计算最大利润的方式，空间换时间，时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        res, low = <span class="number">0</span>, float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">            low = min(prices[i], low)</span><br><span class="line">            res = max(res, prices[i] - low)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>第二种方法：DP动态规划，与下面122题相比，由于只能一次交易操作，第<code>i</code>天的状态就不止“不持有”和“持有”两种状态，而是“未持有”、“持有”、“卖出”三种，并需要一个变量存储最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 生成数组, 然后给初始状态赋值</span></span><br><span class="line">        dp, res = [[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(prices))], <span class="number">0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="comment"># dp[i][0] 第i天 一直没有股票的利润</span></span><br><span class="line">            <span class="comment"># dp[i][1] 第i天 当前有股票的利润 取 max(前面有股票今天不卖, 前面没股票今天买入)</span></span><br><span class="line">            <span class="comment"># dp[i][2] 第i天 之前买入现在卖了的利润(前面有股票今天卖出)</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">            res = max(res, dp[i][<span class="number">0</span>], dp[i][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-买卖股票的最佳时机-II-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock II"></a>122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock II</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">LeetCodeCN 第122题链接</a></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h3 id="解：-1"><a href="#解：-1" class="headerlink" title="解："></a>解：</h3><p>第一种方法：深度优先搜索，时间复杂度<code>O(2^n)</code>，这个通过不了LeetCode，不过能work，测试了多组测试样例是正确的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.prices = prices</span><br><span class="line">        self.profit = []</span><br><span class="line">        self.helper(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> max(self.profit)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># have 0:未持有  1:持有</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, i, have, profit)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i == len(self.prices):</span><br><span class="line">            self.profit.append(profit)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> have: <span class="comment"># 如果持有中</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">0</span>, profit + self.prices[i]) <span class="comment"># 卖出</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">1</span>, profit) <span class="comment"># 不动</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 如果未持有</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">0</span>, profit) <span class="comment"># 不动</span></span><br><span class="line">            self.helper(i+<span class="number">1</span>, <span class="number">1</span>, profit - self.prices[i]) <span class="comment"># 买入</span></span><br></pre></td></tr></table></figure><p>第二种方法：贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                ans += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>第三种方法：标准二维DP动态规划，第<code>i</code>天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i天不持有股票, dp[i][1]表示第i天持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="123-买卖股票的最佳时机-III-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-买卖股票的最佳时机-III-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123.  买卖股票的最佳时机 III Best Time to Buy and Sell Stock III"></a>123.  买卖股票的最佳时机 III Best Time to Buy and Sell Stock III</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">LeetCodeCN 第123题链接</a></p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h4 id="示例-1-2"><a href="#示例-1-2" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,5,0,0,3,1,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure><h4 id="示例-2-2"><a href="#示例-2-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3:"></a>示例 3:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1] </span><br><span class="line">输出: 0 </span><br><span class="line">解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>第一种方法：标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。与下面188题买卖股票4一样的代码，把交易k次定义为2次。当然也可以把内层的for循环拆出来，分别列出交易0次、1次、2次的状态转移方程即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][j][0]表示第i天交易了j次时不持有股票, dp[i][j][1]表示第i天交易了j次时持有股票</span></span><br><span class="line">        <span class="comment"># 定义卖出股票时交易次数加1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>第二种方法：用变量而不是多维数组保存迭代的值，优点是省内存空间，缺点是不是标准DP，没法泛化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        buy1, sell1, buy2, sell2 = -prices[<span class="number">0</span>], <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            buy1 = max(buy1,-prices[i])<span class="comment">#用负值统一变量</span></span><br><span class="line">            sell1 = max(sell1,buy1 + prices[i])<span class="comment">#sell1为 0~i(含)天股市中买卖一次的最优利润</span></span><br><span class="line">            buy2 = max(buy2,sell1 - prices[i])<span class="comment">#仅当＞0才会更新，保证 第二次买入不会与第一次卖出为同一天。而sell1为历史记录保证第二次买入比第一次卖出晚。</span></span><br><span class="line">            sell2 = max(sell2,buy2 + prices[i])<span class="comment">#若第二轮买卖为同一天，则不会更新。此操作自然保证sell2为买卖至多两次的最优利润。</span></span><br><span class="line">        <span class="keyword">return</span> sell2</span><br></pre></td></tr></table></figure><h2 id="188-买卖股票的最佳时机-IV-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-买卖股票的最佳时机-IV-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV Best Time to Buy and Sell Stock IV"></a>188. 买卖股票的最佳时机 IV Best Time to Buy and Sell Stock IV</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">LeetCodeCN 第188题链接</a></p><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h4 id="示例-1-3"><a href="#示例-1-3" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,4,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure><h4 id="示例-2-3"><a href="#示例-2-3" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,6,5,0,3], k = 2</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><br></pre></td></tr></table></figure><h3 id="解：-2"><a href="#解：-2" class="headerlink" title="解："></a>解：</h3><p>标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。</p><p>首先初始化三维数组，填充第1天操作j次的没买或买了的情况的初始值，没买就是<code>0</code>，第一天就买入即<code>-prices[0]</code>。这里定义卖出操作时交易次数加<code>1</code></p><p>然后是状态转移方程，下面描述的<code>i, j</code>都大于<code>0</code></p><p>「第<code>i</code>天交易次数<code>0</code>不持有股票」的情况只能来自「第<code>i-1</code>天交易次数<code>0</code>不持有股票」；</p><p>「第<code>i</code>天交易<code>j</code>次不持有股票」的状态可以来自「第<code>i-1</code>天交易<code>j</code>次不持有股票」或者「第<code>i-1</code>天交易<code>j-1</code>次持有股票」(即今天卖出股票，然后交易次数+1)；</p><p>「第<code>i</code>天交易<code>j</code>次持有股票」的状态可以来自「第<code>i-1</code>天交易<code>j</code>次持有股票」或者「第<code>i-1</code>天交易<code>j</code>次不持有股票」(即今天买入股票，因为是买入操作所以交易次数不变)</p><p>最后对于这题LeetCode的测试样例里有超大k值的情况，退化成122题不限次数的操作，可以用贪心解决或者直接替换k值为数组长度的一半</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.greedy(prices)</span><br><span class="line">        </span><br><span class="line">        dp, res = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)], []</span><br><span class="line">        <span class="comment"># dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票</span></span><br><span class="line">        <span class="comment"># 设定在卖出时加1次交易次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = dp[i<span class="number">-1</span>][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">0</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="comment"># 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            res.append(dp[n<span class="number">-1</span>][m][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理k过大导致超时的问题，用贪心解决</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><p>一个技巧：之前为了降低空间复杂度，需要改动很多代码来把DP数组降维（比如下面题目的方法二），其实可以在标准的DP解法基础上，把时间（天数）的维度稍加改动，用滚动数组，两个元素即可代替n个元素，有效降低空间复杂度，比如这题原本三维DP数组的空间复杂度是O(n×k×2)即O(n*k),用上滚动数组后就降为O(k×2)即O(k),性能提升比较显著。</p></blockquote><blockquote><p>滚动数组即用两个值 x, y, 在迭代 n 的时候, 赋值为 i&amp;1, (i-1)&amp;1, 利用位运算效果等同于 i%2, 即奇偶判断取1或0, 如此实现 x, y 交替0和1。需要注意一下迭代的起始值是1还是0。下面代码是对上面代码稍加改动的实现。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k: int, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices <span class="keyword">or</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.greedy(prices)</span><br><span class="line">        </span><br><span class="line">        dp, res = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)], []</span><br><span class="line">        <span class="comment"># dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票</span></span><br><span class="line">        <span class="comment"># 设定在卖出时加1次交易次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>], dp[<span class="number">0</span>][i][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            x, y = i&amp;<span class="number">1</span>, (i<span class="number">-1</span>)&amp;<span class="number">1</span></span><br><span class="line">            <span class="comment"># 对 i 与 i-1 取奇偶, 令 x,y 交替 0和1, 实现滚动数组</span></span><br><span class="line">            <span class="comment"># 可以减少一维DP数组, 降低空间复杂度</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> j:</span><br><span class="line">                    dp[x][j][<span class="number">0</span>] = dp[y][j][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[x][j][<span class="number">0</span>] = max(dp[y][j][<span class="number">0</span>], dp[y][j<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">                dp[x][j][<span class="number">1</span>] = max(dp[y][j][<span class="number">1</span>], dp[y][j][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="comment"># 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            res.append(dp[<span class="number">0</span>][m][<span class="number">0</span>])</span><br><span class="line">            res.append(dp[<span class="number">1</span>][m][<span class="number">0</span>])</span><br><span class="line">            <span class="comment"># 这里因为前面用了滚动数组</span></span><br><span class="line">            <span class="comment"># 不知道最后一天的值在哪里</span></span><br><span class="line">            <span class="comment"># 所以都加进去然后取最大值</span></span><br><span class="line">        <span class="keyword">return</span> max(res)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 处理k过大导致超时的问题，用贪心解决</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greedy</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                res += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="309-最佳买卖股票时机含冷冻期-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-最佳买卖股票时机含冷冻期-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. 最佳买卖股票时机含冷冻期 Best Time to Buy and Sell Stock with Cooldown"></a>309. 最佳买卖股票时机含冷冻期 Best Time to Buy and Sell Stock with Cooldown</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">LeetCodeCN 第309题链接</a></p><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><h3 id="解：-3"><a href="#解：-3" class="headerlink" title="解："></a>解：</h3><p>第一种方法：标准DP动态规划，三个维度，第一维表示天，第二维表示是否处于冷冻期，第三维表示是否持有股票</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0][0]第一维表示第i天, 第二维用0,1表示是否处于冷冻期, 第三维用0,1表示是否持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>第二种方法：优化版的动态规划，用两个维度处理，第一维表示天，第二维用0表示未持有，1表示持有股票中，2表示处于冷冻期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i天未持有, dp[i][1]表示持有股票, dp[i][2]表示前一天刚卖出今天处于冷冻期</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>], dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—位运算相关题目</title>
      <link href="/2019-05-13-leetcode-bitwise/"/>
      <url>/2019-05-13-leetcode-bitwise/</url>
      
        <content type="html"><![CDATA[<p>有关位运算的做题笔记，Python实现</p><a id="more"></a><h2 id="191-位1的个数-Number-of-1-Bits"><a href="#191-位1的个数-Number-of-1-Bits" class="headerlink" title="191. 位1的个数 Number of 1 Bits"></a>191. 位1的个数 Number of 1 Bits</h2><p><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCodeCN 第191题链接</a></p><p>第一种方法：遍历所有二进制位，通过取模<code>n%2</code>或者与运算<code>n&amp;1</code>判断尾数是否为1，然后把n右移一位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>第二种方法：通过<code>n &amp; (n - 1)</code>直接摘掉最后一位的1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="231-2的幂-Power-of-Two"><a href="#231-2的幂-Power-of-Two" class="headerlink" title="231. 2的幂 Power of Two"></a>231. 2的幂 Power of Two</h2><p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">LeetCodeCN 第231题链接</a></p><p>先排除负数和0，由于2的幂的二进制只有第一位是1，通过<code>n &amp; (n - 1)</code>直接摘掉最后一位的1，如果摘掉后为0即符合条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> n &amp; (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="338-比特位计数-Counting-Bits"><a href="#338-比特位计数-Counting-Bits" class="headerlink" title="338. 比特位计数 Counting Bits"></a>338. 比特位计数 Counting Bits</h2><p><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">LeetCodeCN 第338题链接</a></p><p>第一种方法：遍历，每次分别计算一次比特位，时间复杂度为n乘以每个数的1位个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num+<span class="number">1</span>):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i = i &amp; (i - <span class="number">1</span>)</span><br><span class="line">            result.append(count)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>第二种方法：用一个递推式子<code>count[i] = count[i&amp;(i-1)] + 1</code>，原理是<code>i&amp;(i-1)</code>的1的个数总是比<code>i</code>少1，同时<code>i&amp;(i-1)</code>这个数肯定比<code>i</code>小，所以预先是算过的，这样时间复杂度为<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        result = [<span class="number">0</span>] * (num+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num+<span class="number">1</span>):</span><br><span class="line">            result[i] = result[i&amp;(i<span class="number">-1</span>)] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—广度优先搜索、深度优先搜索、回溯、剪枝相关题目</title>
      <link href="/2019-05-09-leetcode-bfs-dfs-pruning/"/>
      <url>/2019-05-09-leetcode-bfs-dfs-pruning/</url>
      
        <content type="html"><![CDATA[<p>有关BFS（广度优先搜索）与DFS（深度优先搜索）、回溯、剪枝的做题笔记，Python实现</p><a id="more"></a><h2 id="102-二叉树的层次遍历-Binary-Tree-Level-Order-Traversal"><a href="#102-二叉树的层次遍历-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. 二叉树的层次遍历 Binary Tree Level Order Traversal"></a>102. 二叉树的层次遍历 Binary Tree Level Order Traversal</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCodeCN 第102题链接</a></p><p>第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，注意<code>range(len(queue))</code>使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果不是树而是图的话要记录一下访问过的节点，避免重复访问</span></span><br><span class="line">        <span class="comment"># visited = set(root)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = len(queue)</span><br><span class="line">            current_level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                current_level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            result.append(current_level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>第二种方法：DFS深度优先搜索，利用递归的栈，借助<code>level</code>记号把节点放入对应层，由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        self.result = []</span><br><span class="line">        self._dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, node, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.result) &lt; level + <span class="number">1</span>:</span><br><span class="line">            self.result.append([])</span><br><span class="line">        self.result[level].append(node.val)</span><br><span class="line">        self._dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">        self._dfs(node.right, level + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度-Maximum-Depth-of-Binary-Tree"><a href="#104-二叉树的最大深度-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. 二叉树的最大深度 Maximum Depth of Binary Tree"></a>104. 二叉树的最大深度 Maximum Depth of Binary Tree</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCodeCN 第104题链接</a></p><p>第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，<code>range(len(queue))</code>使只遍历当前的层，每次大循环<code>ans</code>加1。由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>第二种方法：DFS深度优先搜索，利用递归的栈，借助<code>level</code>标记当前层，由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self._dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, node, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.ans &lt; level + <span class="number">1</span>:</span><br><span class="line">            self.ans = level + <span class="number">1</span></span><br><span class="line">        self._dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">        self._dfs(node.right, level + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>第三种方法：DFS+分治，虽然代码简洁但耗时比上面两种方法都久</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure><h2 id="111-二叉树的最小深度-Minimum-Depth-of-Binary-Tree"><a href="#111-二叉树的最小深度-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. 二叉树的最小深度 Minimum Depth of Binary Tree"></a>111. 二叉树的最小深度 Minimum Depth of Binary Tree</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCodeCN 第111题链接</a></p><p>第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，<code>range(len(queue))</code>使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br></pre></td></tr></table></figure><p>第二种方法：DFS深度优先搜索，利用递归的栈，借助<code>level</code>标记当前层，由于每个节点仅访问一次，所以时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.ans = float(<span class="string">'inf'</span>)</span><br><span class="line">        self._dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, node, level)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> self.ans &gt; level + <span class="number">1</span>:</span><br><span class="line">                self.ans = level + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._dfs(node.left, level + <span class="number">1</span>)</span><br><span class="line">        self._dfs(node.right, level + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="22-括号生成-Generate-Parentheses"><a href="#22-括号生成-Generate-Parentheses" class="headerlink" title="22. 括号生成 Generate Parentheses"></a>22. 括号生成 Generate Parentheses</h2><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">LeetCodeCN 第22题链接</a></p><p>DFS+剪枝，利用左括号与右括号分别已用的参数，当两个参数都为<code>n</code>时即填完一个结果添加进结果数组，精髓在于<code>if left_used &gt; right_used</code>，只有在右括号少于左括号时才能填充右括号，保证输出的结果是合法的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.helper(<span class="number">0</span>, <span class="number">0</span>, n, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, left_used: int, right_used: int, n: int, result: str)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left_used == n <span class="keyword">and</span> right_used == n:</span><br><span class="line">            self.ans.append(result)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left_used &lt; n:</span><br><span class="line">            self.helper(left_used + <span class="number">1</span>, right_used, n, result + <span class="string">'('</span>)</span><br><span class="line">        <span class="keyword">if</span> left_used &gt; right_used <span class="keyword">and</span> right_used &lt; n:</span><br><span class="line">            self.helper(left_used, right_used + <span class="number">1</span>, n, result + <span class="string">')'</span>)</span><br></pre></td></tr></table></figure><h2 id="51-N皇后-N-Queens-52-N皇后-II-N-Queens-II"><a href="#51-N皇后-N-Queens-52-N皇后-II-N-Queens-II" class="headerlink" title="51. N皇后 N-Queens / 52. N皇后 II N-Queens II"></a>51. N皇后 N-Queens / 52. N皇后 II N-Queens II</h2><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">LeetCodeCN 第51题链接</a><br><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">LeetCodeCN 第52题链接</a></p><p>用三个<code>set()</code>记录矩阵内因放入皇后而封住的格子，<code>self.col</code>是列，<code>self.sum</code>是<code>row+col</code>表示的 ‘/‘ 方向 <code>self.dif</code>是<code>row-col</code>表示的 ‘\‘ 方向。</p><p>用深度优先搜索方法，逐行递归下去，递归终止条件是行数加到<code>n</code>时，此时即生成了一种解决方案，放入结果数组。</p><p>每次递归内迭代列<code>col</code>检查这个点位是否能放下，能放下的话把自身点位加入三个<code>set</code>内，继续下个递归，参数<code>state</code>数组<code>append</code>这一行的列值 <code>col</code>。</p><p>递归函数后记得清除因放入自己的影响即三个<code>set</code>。</p><p>最后为51题生成结果图的函数<code>_gen</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.col = set()</span><br><span class="line">        self.sum = set()</span><br><span class="line">        self.dif = set()</span><br><span class="line">        self._dfs(n, <span class="number">0</span>, [])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 51题: 输出点阵图</span></span><br><span class="line">        <span class="keyword">return</span> self._gen(n)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 52题: 输出结果数量</span></span><br><span class="line">        <span class="comment"># return len(self.result)</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, n, row, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> row &gt;= n:</span><br><span class="line">            self.result.append(state)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> col <span class="keyword">in</span> self.col <span class="keyword">or</span> row+col <span class="keyword">in</span> self.sum <span class="keyword">or</span> row-col <span class="keyword">in</span> self.dif:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.col.add(col)</span><br><span class="line">            self.sum.add(row + col)</span><br><span class="line">            self.dif.add(row - col)</span><br><span class="line">            </span><br><span class="line">            self._dfs(n, row + <span class="number">1</span>, state + [col])</span><br><span class="line">            </span><br><span class="line">            self.col.remove(col)</span><br><span class="line">            self.sum.remove(row + col)</span><br><span class="line">            self.dif.remove(row - col)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_gen</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> res <span class="keyword">in</span> self.result:</span><br><span class="line">            graph = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">                graph.append(<span class="string">'.'</span>*i + <span class="string">'Q'</span> + <span class="string">'.'</span>*(n-i<span class="number">-1</span>))</span><br><span class="line">            result.append(graph)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="37-解数独-Sudoku-Solver"><a href="#37-解数独-Sudoku-Solver" class="headerlink" title="37. 解数独 Sudoku Solver"></a>37. 解数独 Sudoku Solver</h2><p><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">LeetCodeCN 第37题链接</a></p><p>DFS朴素解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> board <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> len(board):</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.solve(board)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>]:</span><br><span class="line">                        <span class="keyword">if</span> self.isValid(board, i, j, c):</span><br><span class="line">                            board[i][j] = c</span><br><span class="line">                            <span class="keyword">if</span> self.solve(board):</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                board[i][j] = <span class="string">'.'</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, board, row, col, c)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[row][i] != <span class="string">'.'</span> <span class="keyword">and</span> board[row][i] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[i][col] != <span class="string">'.'</span> <span class="keyword">and</span> board[i][col] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">3</span> * (row//<span class="number">3</span>) + i//<span class="number">3</span>][<span class="number">3</span> * (col//<span class="number">3</span>) + i%<span class="number">3</span>] != <span class="string">'.'</span> <span class="keyword">and</span> board[<span class="number">3</span> * (row//<span class="number">3</span>) + i//<span class="number">3</span>][<span class="number">3</span> * (col//<span class="number">3</span>) + i%<span class="number">3</span>] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="36-有效的数独-Valid-Sudoku"><a href="#36-有效的数独-Valid-Sudoku" class="headerlink" title="36. 有效的数独 Valid Sudoku"></a>36. 有效的数独 Valid Sudoku</h2><p>第一种方法：利用<code>collections</code>的<code>defaultdict</code>数据结构记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections <span class="keyword">as</span> cl</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> len(board):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.row, self.col, self.box = cl.defaultdict(set), cl.defaultdict(set), cl.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[r][c] != <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">if</span> board[r][c] <span class="keyword">not</span> <span class="keyword">in</span> self.row[r] <span class="keyword">and</span> board[r][c] <span class="keyword">not</span> <span class="keyword">in</span> self.col[c] <span class="keyword">and</span> board[r][c] <span class="keyword">not</span> <span class="keyword">in</span> self.box[(r//<span class="number">3</span>, c//<span class="number">3</span>)]:</span><br><span class="line">                        self.row[r].add(board[r][c])</span><br><span class="line">                        self.col[c].add(board[r][c])</span><br><span class="line">                        self.box[(r//<span class="number">3</span>, c//<span class="number">3</span>)].add(board[r][c])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>第二种方法：不用额外空间，直接循环检测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> len(board):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[r][c] != <span class="string">'.'</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.isValid(board, r, c, board[r][c]):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, board, row, col, c)</span> -&gt; bool:</span></span><br><span class="line">        board[row][col] = <span class="string">'.'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[row][i] != <span class="string">'.'</span> <span class="keyword">and</span> board[row][i] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[i][col] != <span class="string">'.'</span> <span class="keyword">and</span> board[i][col] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[<span class="number">3</span> * (row//<span class="number">3</span>) + i//<span class="number">3</span>][<span class="number">3</span> * (col//<span class="number">3</span>) + i%<span class="number">3</span>] != <span class="string">'.'</span> <span class="keyword">and</span> board[<span class="number">3</span> * (row//<span class="number">3</span>) + i//<span class="number">3</span>][<span class="number">3</span> * (col//<span class="number">3</span>) + i%<span class="number">3</span>] == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        board[row][col] = c    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="69-x-的平方根-Sqrt-x"><a href="#69-x-的平方根-Sqrt-x" class="headerlink" title="69. x 的平方根  Sqrt(x)"></a>69. x 的平方根  Sqrt(x)</h2><p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">LeetCodeCN 第69题链接</a></p><p>第一种方法：二分查找，题目奇怪要求返回整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span> <span class="keyword">or</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        l, r = <span class="number">1</span>, x</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + (r - l)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid &lt;= x &lt; (mid+<span class="number">1</span>)*(mid+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> mid*mid &lt; x:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br></pre></td></tr></table></figure><p>第二种方法：牛顿迭代法，$X_{n+1} = x_n - \frac{f(x_n)}{f’(x_n)}$，这里的$f(x_n)$是$x^2 - y_0$，即得迭代公式$x_{n+1} = (x_n + \frac{y_0}{x_n}) / 2 $</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span>        </span><br><span class="line">        <span class="keyword">if</span> x &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        r = x</span><br><span class="line">        <span class="keyword">while</span> r &gt; x / r:</span><br><span class="line">            r = (r + x / r)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> int(r)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—递归、分治相关题目</title>
      <link href="/2019-05-07-leetcode-recursion-divide-conquer/"/>
      <url>/2019-05-07-leetcode-recursion-divide-conquer/</url>
      
        <content type="html"><![CDATA[<p>有关递归与分治的做题笔记，Python实现</p><a id="more"></a><h2 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h2><p><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">LeetCodeCN 第50题链接</a></p><p>第一种方法：暴力乘法，时间复杂度<code>O(n)</code>，LeetCode会超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/x</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            res = <span class="number">1</span>/x</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(abs(n)<span class="number">-1</span>):</span><br><span class="line">                res = res*(<span class="number">1</span>/x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = x</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(abs(n)<span class="number">-1</span>):</span><br><span class="line">                res = res*x</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>第二种方法：分治（递归） ，时间复杂度<code>O(logn)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x * self.myPow(x, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.myPow(x * x, n / <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>稍微改成下面这样容易理解一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/self.myPow(x, -n)</span><br><span class="line">        <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.myPow(x, n - <span class="number">1</span>) * x</span><br><span class="line">        res = self.myPow(x, n&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res*res</span><br></pre></td></tr></table></figure><p>第二种方法：循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            x = <span class="number">1</span> / x</span><br><span class="line">            n = -n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="comment"># n&amp;1 是与运算，用来求奇偶，效果与 n%2 一样</span></span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ans *= x</span><br><span class="line">            x = x * x</span><br><span class="line">            <span class="comment"># n&gt;&gt;=1 是位运算，右移一位，效果与 n//=2 一样</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="169-求众数-Majority-Element"><a href="#169-求众数-Majority-Element" class="headerlink" title="169. 求众数 Majority Element"></a>169. 求众数 Majority Element</h2><p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">LeetCodeCN 第169题链接</a></p><p>第一种方法：两重循环暴力求解，时间复杂度<code>O(n^2)</code>，LeetCode会超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] == nums[j]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; len(nums) / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br></pre></td></tr></table></figure><p>第二种方法：哈希表记录每个元素出现次数，发现出现超过<code>n/2</code>的就是众数，时间复杂度<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        leng = len(nums)</span><br><span class="line">        <span class="keyword">if</span> leng == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> dic[i] &gt;= leng / <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>第三种方法：排序后直接返回中间值，因为题目限定条件必然存在众数，时间复杂度<code>O(n*logn)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(nums)[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>第四种方法：用<code>list.count()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 此处如果遍历整个nums会超时</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums[len(nums)//<span class="number">2</span>:]:</span><br><span class="line">        <span class="keyword">if</span> nums.count(i) &gt; len(nums)//<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>第五种方法：分治，时间复杂度<code>O(n*logn)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    a = self.majorityElement(nums[:len(nums)//<span class="number">2</span>])</span><br><span class="line">    b = self.majorityElement(nums[len(nums)//<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">if</span> a == b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> [b, a][nums.count(a) &gt; len(nums)//<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这个 return 的写法等同于下面的 if else</span></span><br><span class="line">    <span class="comment"># 因为若后一个[]里为True即1所以取[b,a][1]=a, False即0取[b,a][0]=b</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    <span class="comment"># if nums.count(a) &gt; len(nums)//2:</span></span><br><span class="line">    <span class="comment">#     return a</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     return b</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考察ObjC对象内存结构与isa指针</title>
      <link href="/2019-05-05-ios-object-struct-isa/"/>
      <url>/2019-05-05-ios-object-struct-isa/</url>
      
        <content type="html"><![CDATA[<p>考察ObjC对象内存结构与isa指针</p><h4 id="1-一个-Objective-C-对象的内存结构是怎样的？"><a href="#1-一个-Objective-C-对象的内存结构是怎样的？" class="headerlink" title="1. 一个 Objective-C 对象的内存结构是怎样的？"></a>1. 一个 Objective-C 对象的内存结构是怎样的？</h4><a id="more"></a><p>如果把类的实例看成一个C语言的结构体（<code>struct</code>），它首先包含的是一个 <code>isa</code> 指针，而类的其它成员变量依次排列在结构体中。排列顺序如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190603171627.png" alt></p><p>为了验证该说法，我们在Xcode中新建一个工程，在main.m中运行如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> _father;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span><span class="class"><span class="keyword">@implementation</span> <span class="title">Father</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Child</span> : <span class="title">Father</span> </span>&#123;    </span><br><span class="line"><span class="keyword">int</span> _child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Child</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  Child * child = [[Child alloc] init];  </span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;      </span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将断点下在 <code>@autoreleasepool</code> 处，然后在<code>Console</code>中输入<code>p *child</code>,则可以看到<code>Xcode</code>输出如下内容，这与我们上面的说法一致。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p *child</span><br><span class="line">(Child) $<span class="number">0</span> = &#123;</span><br><span class="line">  (Father) Father = &#123;</span><br><span class="line">    (<span class="built_in">NSObject</span>) <span class="built_in">NSObject</span> = &#123;</span><br><span class="line">      (Class) isa = Child</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="keyword">int</span>) _father = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="keyword">int</span>) _child = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。</p><blockquote><p>注：需要特别说明一下，通过 <code>objc_setAssociatedObject</code>和 <code>objc_getAssociatedObject</code>方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。</p></blockquote><h4 id="2-Objective-C-对象内存结构中的-isa-指针是用来做什么的，有什么用？"><a href="#2-Objective-C-对象内存结构中的-isa-指针是用来做什么的，有什么用？" class="headerlink" title="2. Objective-C 对象内存结构中的 isa 指针是用来做什么的，有什么用？"></a>2. Objective-C 对象内存结构中的 isa 指针是用来做什么的，有什么用？</h4><p><code>Objective-C</code> 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 <code>Objective-C</code> 语言的内部，每一个对象都有一个名为 <code>isa</code> 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。</p><p>在 <code>Xcode</code> 中按<code>Shift + Command + O</code>, 然后输入 <code>NSObject.h</code> 和 <code>objc.h</code>，可以打开 <code>NSObject</code> 的定义头文件，通过头文件我们可以看到，<code>NSObject</code> 就是一个包含 isa 指针的结构体，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190603171935.png" alt></p><p>按照面向对象语言的设计原则，所有事物都应该是对象（严格来说 <code>Objective-C</code> 并没有完全做到这一点，因为它有象 <code>int</code>, <code>double</code> 这样的简单变量类型，而 <code>Swift</code> 语言，连 <code>int</code> 变量也是对象）。在 <code>Objective-C</code> 语言中，每一个类实际上也是一个对象。每一个类也有一个名为 <code>isa</code> 的指针。每一个类也可以接受消息，例如代码<code>[NSObject alloc]</code>，就是向 <code>NSObject</code> 这个类发送名为alloc消息。</p><p>在 <code>Xcode</code> 中按<code>Shift + Command + O</code>, 然后输入 <code>runtime.h</code>，可以打开 <code>Class</code> 的定义头文件，通过头文件我们可以看到，<code>Class</code> 也是一个包含 <code>isa</code> 指针的结构体，如下图所示。（图中除了 <code>isa</code> 外还有其它成员变量，但那是为了兼容非 2.0 版的 <code>Objective-C</code> 的遗留逻辑，大家可以忽略它。）</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190603172059.png" alt></p><p>因为类也是一个对象，那它也必须是另一个类的实例，这个类就是元类 (<code>metaclass</code>)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。</p><p>元类 (<code>metaclass</code>) 也是一个对象，那么元类的 <code>isa</code> 指针又指向哪里呢？为了设计上的完整，所有的元类的 <code>isa</code> 指针都会指向一个根元类 (<code>root metaclass</code>)。根元类 (<code>root metaclass</code>) 本身的 <code>isa</code> 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 <code>isa</code> 指针在实际上很少用到。不过这么设计保证了面向对象概念在 <code>Objective-C</code> 语言中的完整，即语言中的所有事物都是对象，都有 <code>isa</code> 指针。</p><p>我们再来看看继承关系，由于类方法的定义是保存在元类 (<code>metaclass</code>) 中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。</p><p>我很想把关系说清楚一些，但是这块儿确实有点绕，我们还是来看图吧，很多时候图象比文字表达起来更为直观。下面这张图或许能够让大家对 <code>isa</code> 和继承的关系清楚一些：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190603172152.png" alt></p><p>我们可以从图中看出：</p><p><code>NSObject</code> 的类中定义了实例方法，例如 <code>-(id)init</code> 方法 和 <code>- (void)dealloc</code> 方法。</p><p><code>NSObject</code> 的元类中定义了类方法，例如 <code>+(id)alloc</code> 方法 和 <code>+ (void)load</code> 、<code>+ (void)initialize</code> 方法。</p><p><code>NSObject</code> 的元类继承自 <code>NSObject</code> 类，所以 <code>NSObject</code> 类是所有类的根，因此 <code>NSObject</code> 中定义的实例方法可以被所有对象调用，例如 <code>- (id)init</code> 方法 和 <code>- (void)dealloc</code> 方法。</p><p><code>NSObject</code> 的元类的 <code>isa</code> 指向自己。</p><h4 id="isa-swizzling-的应用"><a href="#isa-swizzling-的应用" class="headerlink" title="isa swizzling 的应用"></a>isa swizzling 的应用</h4><p>系统提供的 <code>KVO</code> 的实现，就利用了动态地修改 <code>isa</code> 指针的值的技术。在 苹果的文档<br>中可以看到如下描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Key-Value Observing Implementation Details</span><br><span class="line"></span><br><span class="line">Automatic key-value observing is implemented using a technique called isa-swizzling.</span><br><span class="line"></span><br><span class="line">The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</span><br><span class="line"></span><br><span class="line">When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</span><br><span class="line"></span><br><span class="line">You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—二叉树相关题目</title>
      <link href="/2019-05-04-leetcode-tree/"/>
      <url>/2019-05-04-leetcode-tree/</url>
      
        <content type="html"><![CDATA[<p>有关二叉树的做题笔记，Python实现</p><a id="more"></a><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="226-翻转二叉树-Invert-Binary-Tree"><a href="#226-翻转二叉树-Invert-Binary-Tree" class="headerlink" title="226. 翻转二叉树 Invert Binary Tree"></a>226. 翻转二叉树 Invert Binary Tree</h2><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">LeetCodeCN 第226题链接</a></p><p>第一种方法：递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>第二种方法：遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树-Validate-Binary-Search-Tree"><a href="#98-验证二叉搜索树-Validate-Binary-Search-Tree" class="headerlink" title="98. 验证二叉搜索树 Validate Binary Search Tree"></a>98. 验证二叉搜索树 Validate Binary Search Tree</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LeetCodeCN 第98题链接</a></p><p>第一种方法：中序遍历二叉树存入数组，与直接升序排序去重后的原二叉树对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        inorder = self.inorder(root)</span><br><span class="line">        <span class="keyword">return</span> inorder == list(sorted(set(inorder)))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root)</span> -&gt; list:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.inorder(root.left) + [root.val] + self.inorder(root.right)</span><br></pre></td></tr></table></figure><p>第二种方法：中序遍历只用比较前一节点的值是否小于当前节点的值即可，不用储存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.helper(root.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.prev <span class="keyword">and</span> self.prev.val &gt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.prev = root</span><br><span class="line">        <span class="keyword">return</span> self.helper(root.right)</span><br></pre></td></tr></table></figure><p>第三种方法：递归验证每个节点左孩子的值是否小于父亲节点的值以及右孩子的值是否大于父亲节点的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        mini, maxi = float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>) </span><br><span class="line">        <span class="keyword">return</span> self.isValid(root, mini, maxi)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, root: TreeNode, mini: int, maxi: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> mini &gt;= root.val <span class="keyword">or</span> maxi &lt;= root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isValid(root.left, mini, root.val) <span class="keyword">and</span> self.isValid(root.right, root.val, maxi)</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. 二叉树的最近公共祖先 Lowest Common Ancestor of a Binary Tree"></a>236. 二叉树的最近公共祖先 Lowest Common Ancestor of a Binary Tree</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">LeetCodeCN 第236题链接</a></p><p>首先如果root为空，返回root，然后如果root就是p或者q，那root就是最近公共祖先。然后分别对左子树和右子树做递归并保存结果，如果两边都能找到，证明本节点就是最近公共祖先，如果一边找得到，一边找不到，则往能找到的那边继续找下去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">or</span> right:</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> right</span><br><span class="line">            <span class="keyword">elif</span> right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="235-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. 二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search Tree"></a>235. 二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search Tree</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">LeetCodeCN 第235题链接</a></p><p>第一种方法：还用上面的方法</p><p>第二种方法：利用二叉搜索树的左子树都小于父亲节点，右子树都大于父亲节点的特性，可以把第一种方法简化一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>第三种方法：跟方法二的思路一样，把递归改成循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">    <span class="keyword">while</span> root:</span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val <span class="keyword">and</span> q.val &lt; root.val:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">elif</span> p.val &gt; root.val <span class="keyword">and</span> q.val &gt; root.val:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="112-路径总和-Path-Sum"><a href="#112-路径总和-Path-Sum" class="headerlink" title="112. 路径总和 Path Sum"></a>112. 路径总和 Path Sum</h2><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">LeetCodeCN 第112题链接</a></p><p>第一种方法：DFS，用一个数组记录每条路线的路径和，最后检查目标值是否在数组内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> sum <span class="keyword">in</span> self.res:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, tmp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            self.res.append(tmp+node.val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            self.dfs(node.left, tmp+node.val)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            self.dfs(node.right, tmp+node.val)</span><br></pre></td></tr></table></figure><p>第二种方法：每次递归时从目标值里扣除自身节点的值，如果到某个叶子节点正好剩余目标值等于叶子节点的值说明存在该路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> sum == root.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        sum -= root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum) <span class="keyword">or</span> self.hasPathSum(root.right, sum)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—哈希表相关题目</title>
      <link href="/2019-05-01-leetcode-hashtable/"/>
      <url>/2019-05-01-leetcode-hashtable/</url>
      
        <content type="html"><![CDATA[<p>有关哈希表的做题笔记，Python实现</p><a id="more"></a><h2 id="242-有效的字母异位词-Valid-Anagram"><a href="#242-有效的字母异位词-Valid-Anagram" class="headerlink" title="242. 有效的字母异位词 Valid Anagram"></a>242. 有效的字母异位词 Valid Anagram</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">LeetCodeCN 第242题链接</a></p><p>第一种方法：对两个字符串排序后对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure><p>第二种方法：用哈希表对字符串内每个字符计数，最后比对哈希表，这里用dict实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        map1, map2 = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            map1[i] = map1.get(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> t:</span><br><span class="line">            map2[j] = map2.get(j, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> map1 == map2</span><br></pre></td></tr></table></figure><p>第三种方法：由于只有26个小写字母元素，可以用数组自己实现一个哈希表，原理与上面一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        map1, map2 = [<span class="number">0</span>]*<span class="number">26</span>, [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            map1[ord(c)-ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> t:</span><br><span class="line">            map2[ord(d)-ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> map1 == map2</span><br></pre></td></tr></table></figure><h2 id="1-两数之和-Two-Sum"><a href="#1-两数之和-Two-Sum" class="headerlink" title="1. 两数之和 Two Sum"></a>1. 两数之和 Two Sum</h2><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCodeCN 第1题链接</a></p><p>第一种方法：用哈希表，时间复杂度是<code>O(n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[nums[i]], i]</span><br><span class="line">            <span class="keyword">else</span>:            </span><br><span class="line">                dic[target - nums[i]] = i</span><br></pre></td></tr></table></figure><p>第二种方法：暴力两重遍历，这样时间复杂度是<code>O(n^2)</code>，在LeetCode里提交会超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure><h2 id="15-三数之和-3Sum"><a href="#15-三数之和-3Sum" class="headerlink" title="15. 三数之和 3Sum"></a>15. 三数之和 3Sum</h2><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCodeCN 第15题链接</a></p><p>第一种方法：三重遍历，时间复杂度为<code>O(n^3)</code></p><p>第二种方法：两重遍历得到前两个数，然后查询第三个数<code>-(a+b)</code>是否存在。用哈希表<code>set()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = set()</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(nums[:<span class="number">-2</span>]) :</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> v == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums[i+<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    d[-(v+x)] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.add((v, -(v+x), x))</span><br><span class="line">        <span class="keyword">return</span> map(list, res)</span><br></pre></td></tr></table></figure><p>第三种方法：先升序排序，一遍遍历，然后在后面的新数组里用双指针检查三个数之和是否为0，大于0则右指针向左走，小于0则左指针向右走。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums[:<span class="number">-2</span>]):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> x == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l, r = i+<span class="number">1</span>, len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                s = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append((nums[i], nums[l], nums[r]))</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l+<span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r<span class="number">-1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="146-LRU缓存机制-LRU-Cache"><a href="#146-LRU缓存机制-LRU-Cache" class="headerlink" title="146. LRU缓存机制 LRU Cache"></a>146. LRU缓存机制 LRU Cache</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LeetCodeCN 第146题链接</a></p><p>利用 Python collections 库内的顺序哈希表 OrderedDict() 类可以很方便地实现</p><blockquote><p>一般LRU缓存是通过哈希表配合双向链表实现的。如图所示，哈希表使访问查找的时间复杂度为O(1)，双向链表可以获得前驱节点使删除操作也是O(1)</p></blockquote><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190611173846.jpg" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.dic = OrderedDict()</span><br><span class="line">        self.remain = capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.dic:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        item = self.dic[key]</span><br><span class="line">        self.dic.pop(key)</span><br><span class="line">        self.dic[key] = item</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            self.dic.pop(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.remain &gt; <span class="number">0</span>:</span><br><span class="line">                self.remain -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.dic.popitem(last=<span class="literal">False</span>)</span><br><span class="line">        self.dic[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—栈、堆、队列相关题目</title>
      <link href="/2019-04-29-leetcode-stack-heap-queue/"/>
      <url>/2019-04-29-leetcode-stack-heap-queue/</url>
      
        <content type="html"><![CDATA[<p>有关栈、堆、队列的做题笔记，Python实现</p><a id="more"></a><h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h1><h2 id="20-有效的括号-Valid-Parentheses"><a href="#20-有效的括号-Valid-Parentheses" class="headerlink" title="20. 有效的括号 Valid Parentheses"></a>20. 有效的括号 Valid Parentheses</h2><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">LeetCodeCN 第20题链接</a></p><p>使用 Stack 栈 来操作，用了一个技巧是先做一个字典，<code>key</code>为右括号，<code>value</code>为左括号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        mapping = &#123;<span class="string">')'</span>:<span class="string">'('</span>, <span class="string">'&#125;'</span>:<span class="string">'&#123;'</span>, <span class="string">']'</span>:<span class="string">'['</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> mapping:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> mapping[c] != stack.pop():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><h2 id="71-简化路径-Simplify-Path"><a href="#71-简化路径-Simplify-Path" class="headerlink" title="71. 简化路径 Simplify Path"></a>71. 简化路径 Simplify Path</h2><p><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">LeetCode 第71题链接</a></p><p>使用栈，遍历用<code>/</code>分割后的字符串数组，此时字符串不存在斜杠了，当字符不是空字符或<code>.</code>、<code>..</code>时即正常路径名压入栈中，当遇到空字符或者<code>.</code>时略过，当遇到<code>..</code>时<code>pop</code>一下即返回上级目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path.split(<span class="string">'/'</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">''</span>, <span class="string">'.'</span>, <span class="string">'..'</span>]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">'..'</span> <span class="keyword">and</span> stack:</span><br><span class="line">                    stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(stack)</span><br></pre></td></tr></table></figure><h1 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆 Heap"></a>堆 Heap</h1><h2 id="703-数据流中的第K大元素-Kth-Largest-Element-in-a-Stream"><a href="#703-数据流中的第K大元素-Kth-Largest-Element-in-a-Stream" class="headerlink" title="703. 数据流中的第K大元素 Kth Largest Element in a Stream"></a>703. 数据流中的第K大元素 Kth Largest Element in a Stream</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">LeetCodeCN 第703题链接</a></p><p>第一种方法：直接对整个<code>nums</code>降序排序，然后取第k个元素返回，<code>add</code>时每次都再加入进<code>nums</code>然后排序一次，这样<code>add</code>操作的时间复杂度为<code>O(n*logn)</code>，<code>n</code>是<code>nums</code>的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: List[int])</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        self.k = k</span><br><span class="line">        self.nums.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">while</span> len(self.nums) &gt; k:</span><br><span class="line">            self.nums.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        self.nums.append(val)</span><br><span class="line">        self.nums.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> len(self.nums) &gt; self.k:</span><br><span class="line">            self.nums.pop()</span><br><span class="line">        <span class="keyword">return</span> self.nums[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>第二种方法：维护一个长度为<code>k</code>的数组，初始化时赋值为降序排序后的<code>nums</code>的前<code>k</code>个元素，<code>add</code>操作时先看如果数组长度小于<code>k</code>的话就直接加进去然后排序一次，否则就判断如果<code>val</code>大于数组末尾的元素就将末尾元素剔除并加入<code>val</code>然后排序一次，如果<code>val</code>小于等于数组末尾的元素就不操作，这样<code>add</code>操作的时间复杂度为<code>O(k*logk)</code>，<code>k</code>是数组<code>k</code>的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: List[int])</span>:</span></span><br><span class="line">        self.kl = sorted(nums, reverse=<span class="literal">True</span>)[:k]</span><br><span class="line">        self.k = k</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.kl) &lt; self.k:</span><br><span class="line">            self.kl.append(val)</span><br><span class="line">            self.kl.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.kl[<span class="number">-1</span>]:</span><br><span class="line">            self.kl.pop()</span><br><span class="line">            self.kl.append(val)</span><br><span class="line">            self.kl.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> self.kl[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>第三种方法：使用小顶堆实现的优先队列，Python 中标准库 heapq 就是小顶堆，首先将<code>nums</code>堆化，然后<code>pop</code>元素直到堆的长度为<code>k</code>，<code>add</code>操作时如果堆中元素不满<code>k</code>个就直接把值<code>push</code>进堆，如果值大于堆顶元素则更新堆，时间复杂度降低为<code>O(logk)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int, nums: List[int])</span>:</span></span><br><span class="line">        self.pool, self.k = nums, k</span><br><span class="line">        heapq.heapify(self.pool)</span><br><span class="line">        <span class="keyword">while</span> len(self.pool) &gt; k:</span><br><span class="line">            heapq.heappop(self.pool)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.pool) &lt; self.k:</span><br><span class="line">            heapq.heappush(self.pool, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.pool[<span class="number">0</span>]:</span><br><span class="line">            heapq.heapreplace(self.pool, val)</span><br><span class="line">        <span class="keyword">return</span> self.pool[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your KthLargest object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = KthLargest(k, nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.add(val)</span></span><br></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素-Kth-Largest-Element-in-an-Array"><a href="#215-数组中的第K个最大元素-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. 数组中的第K个最大元素 Kth Largest Element in an Array"></a>215. 数组中的第K个最大元素 Kth Largest Element in an Array</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">LeetCodeCN 第215题链接</a></p><p>第一种方法：用库函数排序直接返回第<code>k</code>大的元素，时间复杂度<code>O(n*logn)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(nums, reverse=<span class="literal">True</span>)[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>第二种方法：与上题一样，使用小顶堆实现的优先队列，一般情况下时间复杂度为<code>O(k + (n-k)*logk)</code>，当<code>n</code>极大时，时间复杂度为<code>O(n*logk)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        heap = nums[:k]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> i &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heapreplace(heap, i)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值-Sliding-Window-Maximum"><a href="#239-滑动窗口最大值-Sliding-Window-Maximum" class="headerlink" title="239. 滑动窗口最大值 Sliding Window Maximum"></a>239. 滑动窗口最大值 Sliding Window Maximum</h2><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">LeetCodeCN 第239题链接</a></p><p>第一种方法：用优先队列：大顶堆</p><p>第二种方法：因为窗口大小固定，只需要一个双端队列即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        window, res = [], []</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k <span class="keyword">and</span> window[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                window.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> window <span class="keyword">and</span> nums[window[<span class="number">-1</span>]] &lt;= x:</span><br><span class="line">                window.pop()</span><br><span class="line">            window.append(i)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">                res.append(nums[window[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode做题笔记—链表相关题目</title>
      <link href="/2019-04-28-leetcode-linklist/"/>
      <url>/2019-04-28-leetcode-linklist/</url>
      
        <content type="html"><![CDATA[<p>有关链表的做题笔记，Python实现</p><a id="more"></a><h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="206-反转链表-Reverse-Linked-List"><a href="#206-反转链表-Reverse-Linked-List" class="headerlink" title="206. 反转链表 Reverse Linked List"></a>206. 反转链表 Reverse Linked List</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCodeCN 第206题链接</a></p><p>遍历链表，迭代前节点prev，缓存当前节点current的下一节点，然后把当前节点的next指针指向前节点prev</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        current = head</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            tmp = current.next</span><br><span class="line">            current.next = prev</span><br><span class="line">            prev = current</span><br><span class="line">            current = tmp</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p>用Python三元交换能同时赋值不需要缓存的特性可以一行完成交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        current = head</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            current.next, prev, current = prev, current, current.next</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h2 id="24-两两交换链表中的节点-Swap-Nodes-in-Pairs"><a href="#24-两两交换链表中的节点-Swap-Nodes-in-Pairs" class="headerlink" title="24. 两两交换链表中的节点 Swap Nodes in Pairs"></a>24. 两两交换链表中的节点 Swap Nodes in Pairs</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">LeetCodeCN 第24题链接</a></p><p>记录当前节点的前一个节点，当当前节点和下一节点都存在时，三元交换三个节点的next指针<br>返回交换完后的首节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        prev, prev.next = self, head</span><br><span class="line">        <span class="keyword">while</span> prev.next <span class="keyword">and</span> prev.next.next:</span><br><span class="line">            l, r = prev.next, prev.next.next</span><br><span class="line">            prev.next, l.next, r.next = r, r.next, l</span><br><span class="line">            prev = l</span><br><span class="line">        <span class="keyword">return</span> self.next</span><br></pre></td></tr></table></figure><blockquote><p>看到好多小伙伴在问，我来尝试解释一下“链表交换相邻元素”中 self 是怎么回事。<br>1.首先看到最后 return self.next ，可以看到作者是想把 self 当做链表的头指针使用的（注意：头指针 pHead 与传入的参数 head 是不同的，head 是第一个结点，而 pHead.next == next ）。用头指针有什么好处呢？因为我们让头指针的 next 域（pHead.next）永远指向第一个结点，就是避免最后返回的时候找不到第一个结点了。<br>2.那么作者为什么可以 pre, pre.next = self, head 这样写呢？因为 self 是这个类的一个对象，所以在类定义的时候可以在任何地方，给 self 增加新的属性。相信大家都知道在 <strong>init</strong>(self, attr) 里面可以定义通过 self.myattr = attr 来定义一个 myattr 属性。其实这个语句写在任意一个类的方法里都可以，所以在原文 swapPairs() 里面当然也可以定义新的属性。所以这行代码应该理解为，pre 指向 self（虽然 self 不是一个 ListNode 类型的对象，但它只要有一个 next 就可以了），同时为 pre（同时也是为 self，它们是一样的现在）增加一个 next 属性，这个 next 属性指向第一个结点 head。<br>3.明白上面之后，这里就好办了。在第一次 while 循环的时候，pre.next 被赋值为 b（也就是原来第二个结点，转换为变成了第一个，也就成为了新链表的第一个结点。如果原来是[1,2,3,4]，那么现在就是[2,1,3,4]，这个 self.next 就是指向 2 这个结点）。所以最后只要返回 self.next 就得到了答案。<br>其实换个写法大家就好理解很多了：<br>pHead = ListNode(None)<br>pre, pre.next = pHead, head<br>也就是说不用 self 也可以，只是原作者秀了一把小技巧而已。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pHead = ListNode(<span class="literal">None</span>)</span><br><span class="line">        prev, prev.next = pHead, head</span><br><span class="line">        <span class="keyword">while</span> prev.next <span class="keyword">and</span> prev.next.next:</span><br><span class="line">            l, r = prev.next, prev.next.next</span><br><span class="line">            prev.next, l.next, r.next = r, r.next, l</span><br><span class="line">            prev = l</span><br><span class="line">        <span class="keyword">return</span> pHead.next</span><br></pre></td></tr></table></figure><h2 id="141-环形链表-Linked-List-Cycle"><a href="#141-环形链表-Linked-List-Cycle" class="headerlink" title="141. 环形链表 Linked List Cycle"></a>141. 环形链表 Linked List Cycle</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCodeCN 第141题链接</a></p><p>三种方法<br>1.硬做，可以设置超时或者固定循环次数，不靠谱<br>2.做记号，使用set来储存遍历过的节点，需要额外内存空间<br>3.快慢指针，慢指针每次前移一个节点，快指针每次前移两个节点，如果链表存在循环那快慢指针肯定会相遇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 1.硬做</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle1</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">            curr = curr.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> curr:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2.set记录</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle2</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rec = set()</span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr <span class="keyword">in</span> rec:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            rec.add(curr)</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3.快慢指针</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle3</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="142-环形链表-II-Linked-List-Cycle-II"><a href="#142-环形链表-II-Linked-List-Cycle-II" class="headerlink" title="142. 环形链表 II Linked List Cycle II"></a>142. 环形链表 II Linked List Cycle II</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCodeCN 第142题链接</a></p><p>第一种方法还是上面的用哈希表set来记录，占用空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        curr, rec = head, set()</span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="keyword">if</span> curr <span class="keyword">in</span> rec:</span><br><span class="line">                <span class="keyword">return</span> curr</span><br><span class="line">            rec.add(curr)</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>第二种方法用快慢指针，先如上题一样检测是否有环，有的话设置一个新的检测节点从头(head)开始迭代，同时slow节点也继续迭代，直到二者相遇的点就是环的入口节点。</p><blockquote><p>原理：<br>首先，头结点到入环结点的距离为a，入环结点到相遇结点的距离为b，相遇结点到入环结点的距离为c。然后，当f以s的两倍速度前进并和s相遇时，f走过的距离是s的两倍，即有等式：a+b+c+b = 2(a+b) ，可以得出 a = c ，所以说，让fast和slow分别从相遇结点和头结点同时同步长出发，他们的相遇结点就是入环结点。<br>当快、慢指针同时从入环点出发，那么一定会在入环点相遇。如果快、慢指针同时从入环点前一节点出发，那么快慢、指针则会在入环点的前一节点相遇，以此类推。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                detection = head</span><br><span class="line">                <span class="keyword">while</span> slow != detection:</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                    detection = detection.next</span><br><span class="line">                <span class="keyword">return</span> detection</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="25-k个一组翻转链表-Reverse-Nodes-in-k-Group"><a href="#25-k个一组翻转链表-Reverse-Nodes-in-k-Group" class="headerlink" title="25. k个一组翻转链表 Reverse Nodes in k-Group"></a>25. k个一组翻转链表 Reverse Nodes in k-Group</h2><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LeetCodeCN 第25题链接</a></p><p>第一种方法：利用数组来实现k个一组的翻转，然后重新连接成链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        arr, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            arr.append(head)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">while</span> i &lt;= len(arr) - k:</span><br><span class="line">            arr[i:i+k] = arr[i:i+k][::<span class="number">-1</span>]</span><br><span class="line">            i += k</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr) - <span class="number">1</span>):</span><br><span class="line">            arr[j].next = arr[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> arr:</span><br><span class="line">            arr[<span class="number">-1</span>].next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>第二种方法：用栈，我们把 k 个数压入栈中，然后弹出来的顺序就是翻转的。这里要注意几个问题：1.剩下的链表个数够不够 k 个（因为不够 k 个不用翻转）；2.已经翻转的部分要与剩下链表连接起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            count = k </span><br><span class="line">            stack = []</span><br><span class="line">            tmp = head</span><br><span class="line">            <span class="keyword">while</span> count <span class="keyword">and</span> tmp:</span><br><span class="line">                stack.append(tmp)</span><br><span class="line">                tmp = tmp.next</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 注意,目前tmp所在k+1位置</span></span><br><span class="line">            <span class="comment"># 说明剩下的链表不够k个,跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> count : </span><br><span class="line">                p.next = head</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 翻转操作</span></span><br><span class="line">            <span class="keyword">while</span> stack:</span><br><span class="line">                p.next = stack.pop()</span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="comment">#与剩下链表连接起来 </span></span><br><span class="line">            p.next = tmp</span><br><span class="line">            head = tmp</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><p>第三种方法：递归，利用206题反转链表的函数稍加改造，添加一个count参数提前结束反转。每次递归主函数时即处理当前k个的反转然后链表尾端接上下一个递归的值，注意其中第12行的<code>head.next</code>，因为经过上一行的反转后，<code>head</code>就成了本次处理k个的末尾节点，<code>prev</code>成了本次的头节点，而<code>new_head</code>为<code>head</code>的下一个节点也即下一个递归的头节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p, count = head, k</span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> count:</span><br><span class="line">            p = p.next</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        prev, new_head = self.reverse(head, k)</span><br><span class="line">        head.next = self.reverseKGroup(new_head, k)</span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, node, count)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        prev, curr = <span class="literal">None</span>, node</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> count:</span><br><span class="line">            curr.next, prev, curr = prev, curr, curr.next</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (prev, curr)</span><br></pre></td></tr></table></figure><h2 id="2-两数相加-Add-Two-Numbers"><a href="#2-两数相加-Add-Two-Numbers" class="headerlink" title="2. 两数相加 Add Two Numbers"></a>2. 两数相加 Add Two Numbers</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">LeetCodeCN 第2题链接</a></p><p>解法很容易想到，但是代码实现不容易，需要小心处理进位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        node = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            x = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            y = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            s = carry + x + y</span><br><span class="line">            carry = s//<span class="number">10</span></span><br><span class="line">            node.next = ListNode(s%<span class="number">10</span>)</span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        <span class="keyword">if</span> carry:</span><br><span class="line">            node.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="21-合并两个有序链表-Merge-Two-Sorted-Lists"><a href="#21-合并两个有序链表-Merge-Two-Sorted-Lists" class="headerlink" title="21. 合并两个有序链表 Merge Two Sorted Lists"></a>21. 合并两个有序链表 Merge Two Sorted Lists</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCodeCN 第21题</a></p><p>第一种方法：迭代，执行逻辑比较直观，由于每个节点仅访问一次，时间复杂度为<code>O(n+m)</code>，<code>n</code>、<code>m</code>分别为两个链表的长度，然后因为仅用到几个辅助变量，空间复杂度为<code>O(1)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">and</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p = dummy = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><p>第二种方法：递归，需要递归<code>n</code>+<code>m</code>次，递归调用栈占用空间，空间复杂度为<code>O(n+m)</code>，因为每个节点也只访问一次，时间复杂度<code>O(n+m)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><h2 id="23-合并K个排序链表-Merge-k-Sorted-Lists"><a href="#23-合并K个排序链表-Merge-k-Sorted-Lists" class="headerlink" title="23. 合并K个排序链表 Merge k Sorted Lists"></a>23. 合并K个排序链表 Merge k Sorted Lists</h2><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">LeetCodeCN 第23题链接</a></p><p>第一种方法：分而治之，利用第21题合并两个有序链表的算法，逐个合并k个链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.lists = lists</span><br><span class="line">        <span class="keyword">return</span> self.divide(<span class="number">0</span>, len(lists)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> self.lists[l]</span><br><span class="line">        mid = r + (l - r) // <span class="number">2</span></span><br><span class="line">        l1 = self.divide(l, mid)</span><br><span class="line">        l2 = self.divide(mid+<span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(l1, l2)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">and</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p = dummy = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><p>第二种方法：优先级队列（小顶堆），<code>Python3</code>中<code>heapq</code>存储对象二元组会导致不可比较的错误，所以用存储三元组，中间用一个数值隔开</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        heap = []</span><br><span class="line">        p = dummy = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i]:</span><br><span class="line">                heapq.heappush(heap, (lists[i].val, i, lists[i]))</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            node = heapq.heappop(heap)</span><br><span class="line">            i = node[<span class="number">1</span>]</span><br><span class="line">            p.next = node[<span class="number">2</span>]</span><br><span class="line">            p = p.next</span><br><span class="line">            <span class="keyword">if</span> p.next:</span><br><span class="line">                heapq.heappush(heap, (p.next.val, i, p.next))</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 NSUserDefaults setBool 的值取出后if判断不了的问题</title>
      <link href="/2019-04-23-nsuserdefaults-setbool-forkey/"/>
      <url>/2019-04-23-nsuserdefaults-setbool-forkey/</url>
      
        <content type="html"><![CDATA[<p>使用  <code>[[NSUserDefaults standardUserDefaults] setBool:(BOOL)value forKey:(NSString *)defaultName]</code> 设置的值，如果用普通的<code>objectForKey:</code>取出的值是<code>__NSCFBoolean</code>类型，<code>if</code>语句无法判断，即使后加<code>== YES</code>也没用，还会出问题。</p><a id="more"></a><p>要用 <code>[[NSUserDefaults standardUserDefaults] boolForKey:(NSString *)defaultName]</code> 来取值，</p><p>同理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setInteger:(<span class="built_in">NSInteger</span>)value forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">void</span>)setFloat:(<span class="keyword">float</span>)value forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">void</span>)setDouble:(<span class="keyword">double</span>)value forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">void</span>)setBool:(<span class="built_in">BOOL</span>)value forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">void</span>)setURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url forKey:(<span class="built_in">NSString</span> *)defaultName;</span><br></pre></td></tr></table></figure><p>如上所示等入值方法，都用对应配套的取值方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)integerForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">float</span>)floatForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">double</span>)doubleForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="built_in">BOOL</span>)boolForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)URLForKey:(<span class="built_in">NSString</span> *)defaultName;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何面试一个 iOS 工程师</title>
      <link href="/2019-04-09-how-to-interview-an-ios-developer/"/>
      <url>/2019-04-09-how-to-interview-an-ios-developer/</url>
      
        <content type="html"><![CDATA[<h2 id="推荐序"><a href="#推荐序" class="headerlink" title="推荐序"></a>推荐序</h2><p>私下和很多朋友交流过这个话题，大部分求职者认为，我能做基本的 iOS 开发工作，就达到公司的要求了，殊不知公司招聘员工，更希望的是这个人能够在关键时候能够发挥一般人做不到的能力。</p><p>这篇文章是来自微信读书的 bang ，我完全同意他的观点。除了他的这些面试方法外，我还认为做比说更重要，所以我更喜欢在面试的时候，拿出一张白纸，让求职者写一段富有逻辑性的代码，看看他的思维是否严谨，对于一些常见的数据结构和算法基础有了解。</p><p>作者介绍：bang，iOS 开发者，推特中文圈 / JSPatch作者，博客 <a href="http://cnbang.net" target="_blank" rel="noopener">http://cnbang.net</a> ， 目前就职于广州腾讯。</p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/ml4EWoEiKUaM1H-WTrDbuw" target="_blank" rel="noopener">本文转载自唐巧的公众号</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>参加了内部面委会的一个分享，结合我自己的方式，说说怎样面试一个普通的 iOS 工程师。</p><p>一般我倾向的考察分两个主要的部分，第一是在简历里提到的项目经历中找挖掘点，第二是基础知识考察。另外也会看情况做一些软实力的考察和性格特征的判断。</p><h3 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h3><p>如果顺利的话这第一步占的比例会很大，因为每个程序员都不会方方面面知识都熟悉，但至少他写在简历上的做过的项目是熟悉的，讲自己熟悉的东西容易让他进入状态，展示好的一面。这里主要考察两方面，一是有没有在某些点上有过深入研究。二是对项目整体了解如何。</p><h3 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h3><p>在中大型的公司里比较注重工程师有深入研究的能力，如果能把一个功能讲得很清晰是比较好的加分项，这里会问实现的思路，通过追问去了解候选人在这块深入的程度，从思路到方法，从上层 API 调用到框架流程再到底层实现。如果候选人在讲述时有一条逻辑主线，例如讲述业界普遍是怎么做的，自己在业界方案基础上做了什么改进，怎样做到更好，进一步改进的思路是怎样，这是最好的。如果还能把解决问题的方法归纳起来运用在其他地方，能举一反三，包装成通用解决方案，或者做开源贡献，就更好了。</p><p>一般会问候选人哪一个项目技术点最能体现自己的技术，然后不停追问技术细节，例如做了一个相册项目，觉得列表优化是最能体现技术点的，会问这里优化的思路是什么，怎样评估，遇到过什么困难，怎么解决的，如果用到图片缓存开源项目，说说它具体做了什么事，缓存策略是什么，从下载到显示的整个流程是怎样的，还有没有更好的方案，追问到一定程度后也会发散去问跟这个话题相关联的问题，例如如果有部分用户反馈图片显示不了，你会怎样排查问题，排查修复后怎样监控，就会过度到一些网络和运营监控方面的内容，也会顺便问到一些基础知识。</p><h3 id="整体了解"><a href="#整体了解" class="headerlink" title="整体了解"></a>整体了解</h3><p>问完自己职责范围内的功能技术点后，还会看看对项目里其他的实现有没有了解，特别是项目的大致架构和核心功能，最好能画出项目大致结构，看情况问问网络层和数据层是怎样实现的，为什么这样实现，项目最核心功能是怎样实现的，例如做读书的至少要知道项目里的排版引擎的大致实现方式，做 QQ 的要知道消息收发的机制，如果不知道，也可以说说如果自己实现会怎么做。这里主要看看有没有技术好奇心，会不会积极主动了解项目里已有的非职责范围内的技术点，主动和好学这两点是很重要的。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>如果项目经历里能问出大部分东西，这部分比例就会比较少了，这是比较好的情况，否则就按套路去多考察一些基础知识，包括 iOS 开发的基础和计算机基础，像内存 / 网络 / 存储 / 线程等，例如 ARC 是怎样做到自动管理内存的，跟 java/js 的垃圾回收的区别，网络 http 协议是怎样的，用过什么数据库框架，db 索引是什么，多线程开发要注意什么，跟 runloop 的关系是什么等等，这类问题在网上都有很多，就不多说了。数据结构和算法在笔试时会涉及，面试会比较少，如果问算法的话只会问问思路，一般我觉得如果项目经历方面不太好，才会考虑考考算法作为辅助判断。</p><h3 id="软实力"><a href="#软实力" class="headerlink" title="软实力"></a>软实力</h3><p>一些通用能力像逻辑思维能力，沟通能力，自我驱动能力等都可以在上面那些问题的交流中表现出来，另外像团队协作能力、抗压能力和性格特征这些也会看情况考察一下，例如问问如果产品让你做个需求，你觉得不靠谱，会怎样做，设计让你做个很难实现的效果，你会怎样评估？或者问个低级问题，故意说个错误的答案，看看他的反应是怎样，是表现出嘲笑和攻击性，还是怀疑自己，还是细心求证。抗压能力的考察有些人比较喜欢，我是觉得面试还是轻松一点好。软实力方面的考察在一面会比较少，或者不会涉及，实际上这方面我也没太多经验，也在摸索中。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>作为程序员，如果有 GitHub 开源项目是最好的，直接可以看到代码风格，代码质量，处理 issue 和 PR 的方式，如果有技术博客也是很好的，可以提前看到平时的一些技术积累，省了很多事。但如果 GitHub 内容是培训班的那种仿写 APP，博客内容是摘抄文章什么的就是负分了。</p><p>以上是正常套路，若候选人有特殊经历或技能，例如牛 X 大学毕业，ACM 冠军，通读 linux 源码，php 源码贡献者之类，会另当别论，针对性进行面试，这不是唯一的标准。另外针对不同的工作年限也有不同的问法和要求，工作年限越高要求越高。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实面试就是想低成本找到合适在团队里一起工作的人，因为如果通过一起工作一段时间去判断是否合适成本太高。这种低成本的代价就是会误判，有些工程师是理论型，有些是实践型，面试的方式会对实践型的人不利，尽管他们如果招进来会是适合的人，而且人会在不同环境下会有不同的表现，只根据过去的经历去判断有时是不准确的。只能尽量采取一些措施去减少误判的概率，例如提高面试官的判断能力，或多几轮面试。一般如果不是急招，策略都会是宁杀错不放过，所以其实就算面试被否了，也不一定代表能力不行。</p><p>另外每个面试官可能都有自己摸索出来的一种判断方式，并随着面试经验的丰富不断改进，达到更准的判断概率，这只是我个人在目前有限的经验里的一点小总结，仅供参考。</p><p><a href="https://mp.weixin.qq.com/s/ml4EWoEiKUaM1H-WTrDbuw" target="_blank" rel="noopener">本文转载自唐巧的公众号</a></p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS集成支付宝H5支付实现跳转与回调的解决方案</title>
      <link href="/2019-03-22-ios-alipay-h5-solution/"/>
      <url>/2019-03-22-ios-alipay-h5-solution/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。</p><p>这篇讲的是支付宝H5支付如何从App跳转支付宝以及如何从支付宝跳转回App，微信支付的见这篇：</p><blockquote><p> <a href="https://paaatrick.com/2019-03-22-ios-wxpay-h5-solution/">iOS集成H5微信支付实现跳转与回调的解决方案</a></p></blockquote><p>实现的效果是：App→支付宝→支付(成功失败或取消)→App</p><a id="more"></a><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>本项目使用WKWebView，前置动作是后端小伙伴已经处理好支付宝H5支付下单链接，客户端接收到下单链接后的操作。</p><p>下单链接即为<a href="https://docs.open.alipay.com/203/107090/" target="_blank" rel="noopener">支付宝H5支付文档-参数说明-公共参数</a>中构造的<code>https://openapi.alipay.com/gateway.do</code>开头的的链接，构造链接的操作交由后端处理。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322204641.png" alt></p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-添加-URL-Scheme-并把支付宝加入白名单"><a href="#1-添加-URL-Scheme-并把支付宝加入白名单" class="headerlink" title="1. 添加 URL Scheme 并把支付宝加入白名单"></a>1. 添加 URL Scheme 并把支付宝加入白名单</h2><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322175421.png" alt></p><p>添加 URL Scheme。在 <code>xcodeproj</code> 文件 <code>Info</code> 选项卡最下面的 <code>URL Types</code>内设置。 该 URL Scheme 不像微信支付因为要校验必须设置商户后台填的一级域名，支付宝的这个可以任意设置。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322175420.png" alt></p><p>把支付宝的 URL Scheme <code>alipay</code> 和 <code>alipays</code> 填入项目的白名单。在 <code>xcodeproj</code> 文件 <code>Info</code> 选项卡内的 <code>Custom iOS Target Properties</code> 的 <code>LSApplicationQueriesSchemes</code> 里添加上述两个字符串，若没有 <code>LSApplicationQueriesSchemes</code> 就手动输入添加，类型为数组 Array。</p><h2 id="2-WKWebView加载链接"><a href="#2-WKWebView加载链接" class="headerlink" title="2. WKWebView加载链接"></a>2. WKWebView加载链接</h2><p>添加协议 <code>WKNavigationDelegate</code>和<code>WKUIDelegate</code>。</p><p>创建一个WKWebView，并加载统一下单链接。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)buildWKWebView &#123;</span><br><span class="line">    <span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:webView];</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    webView.UIDelegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *payURL = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.payString];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:payURL];</span><br><span class="line">    [webView loadRequest:request];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处self.payString就是后台传来的支付宝5支付统一下单链接，格式为：</p><p><code>https://openapi.alipay.com/gateway.do?app_id=2015081808011180&amp;biz_content={&quot;body&quot;%3A&quot;支付宝充值&quot;%2C&quot;subject&quot;%3A&quot;10000宝石&quot;%2C&quot;out_trade_no&quot;%3A&quot;30677&quot;%2C&quot;total_amount&quot;%3A&quot;1.00&quot;%2C&quot;seller_id&quot;%3A&quot;2088721584425035&quot;%2C&quot;product_code&quot;%3A&quot;QUICK_WAP_PAY&quot;%2C&quot;goods_type&quot;%3A&quot;1&quot;%2C&quot;passback_params&quot;%3A&quot;20190322083556lkkzmwT2wi0bAaFL1W&quot;%2C&quot;store_id&quot;%3A&quot;company&quot;%2C&quot;timeout_express&quot;%3A&quot;3m&quot;}&amp;charset=UTF-8&amp;format=JSON&amp;method=alipay.trade.wap.pay&amp;notify_url=https%3A%2F%2Fsttv3-api.company.com%2FaliNotify&amp;return_url=https%3A%2F%2Fwww.company.com&amp;sign_type=RSA2&amp;timestamp=2019-03-22+20%3A35%3A56&amp;version=1.0&amp;sign=rmnKUOsZBYi%2BWzDELY%2B5ixnSFn0b0S38K0NR45SRZBAvmzr0qaXm7mnKaXm7OrvmnKUOsZRYiaJ2LNAaFL1K0hvJ3L3hZqH5HifNCIJ0hfTr1OkA5Lgyn1SCx74SrSWVfXdMXqiLurpN0Mj%2B2zs7vDee%2B8vxwzhRG3a5EaZbOHDQFN1%2OrvvVcdv%2F%2FBJCwISBhoXhBelvfZRYiaJ2LNAaFL1KdrJvjlo2lR%2BEzvda0ppMKFzjMLxRZBAvmzr0qNwxyTMfAuxjAT2%2BXAaF3hZqH5Hlo2lRiaJ2LNE</code></p><p>不像微信支付还要加个请求头，支付宝的简单的多，直接访问即可。</p><h2 id="3-实现代理方法拦截链接并跳转支付宝"><a href="#3-实现代理方法拦截链接并跳转支付宝" class="headerlink" title="3. 实现代理方法拦截链接并跳转支付宝"></a>3. 实现代理方法拦截链接并跳转支付宝</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([navigationAction.request.URL.scheme isEqualToString:<span class="string">@"alipay"</span>]) &#123;</span><br><span class="line">        <span class="comment">//  1.以？号来切割字符串</span></span><br><span class="line">        <span class="built_in">NSArray</span> *urlBaseArr = [navigationAction.request.URL.absoluteString componentsSeparatedByString:<span class="string">@"?"</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *urlBaseStr = urlBaseArr.firstObject;</span><br><span class="line">        <span class="built_in">NSString</span> *urlNeedDecode = urlBaseArr.lastObject;</span><br><span class="line">        <span class="comment">//  2.将截取以后的Str，做一下URLDecode，方便我们处理数据</span></span><br><span class="line">        <span class="built_in">NSMutableString</span> *afterDecodeStr = [<span class="built_in">NSMutableString</span> stringWithString:[SmallTools decoderUrlEncodeStr:urlNeedDecode]];</span><br><span class="line">        <span class="comment">//  3.替换里面的默认Scheme为自己的Scheme</span></span><br><span class="line">        <span class="built_in">NSString</span> *afterHandleStr = [afterDecodeStr stringByReplacingOccurrencesOfString:<span class="string">@"alipays"</span> withString:<span class="string">@"alipayreturn.company.com"</span>];</span><br><span class="line">        <span class="comment">//  4.然后把处理后的，和最开始切割的做下拼接，就得到了最终的字符串</span></span><br><span class="line">        <span class="built_in">NSString</span> *finalStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@?%@"</span>,urlBaseStr, [SmallTools urlEncodeStr:afterHandleStr]];</span><br><span class="line">        </span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="comment">//  判断一下，是否安装了支付宝APP（也就是看看能不能打开这个URL）</span></span><br><span class="line">            <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:[<span class="built_in">NSURL</span> URLWithString:finalStr]]) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] openURL:[<span class="built_in">NSURL</span> URLWithString:finalStr]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//未安装支付宝, 自行处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便附带一下 URL 的 Encode 和 Decode 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//urlEncode编码</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)urlEncodeStr:(<span class="built_in">NSString</span> *)input &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *charactersToEscape = <span class="string">@"?!@#$^&amp;%*+,:;='\"`&lt;&gt;()[]&#123;&#125;/\\| "</span>;</span><br><span class="line">    <span class="built_in">NSCharacterSet</span> *allowedCharacters = [[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:charactersToEscape] invertedSet];</span><br><span class="line">    <span class="built_in">NSString</span> *upSign = [input stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters];</span><br><span class="line">    <span class="keyword">return</span> upSign;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//urlEncode解码</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)decoderUrlEncodeStr: (<span class="built_in">NSString</span> *) input &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *outputStr = [<span class="built_in">NSMutableString</span> stringWithString:input];</span><br><span class="line">    [outputStr replaceOccurrencesOfString:<span class="string">@"+"</span> withString:<span class="string">@""</span> options:<span class="built_in">NSLiteralSearch</span> range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>,[outputStr length])];</span><br><span class="line">    <span class="keyword">return</span> [outputStr stringByRemovingPercentEncoding];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-AppDelegate-中接收跳转动作"><a href="#4-AppDelegate-中接收跳转动作" class="headerlink" title="4. AppDelegate 中接收跳转动作"></a>4. AppDelegate 中接收跳转动作</h2><p>当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。</p><p>以下是AppDelegate接收返回动作的示例。</p><p>其中支付宝回调的 host 是固定的 safepay，而微信支付的 host 随意定义。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)options&#123;</span><br><span class="line">    <span class="comment">//safepay是支付宝H5支付的回调host, </span></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@"wxpaycallback"</span>] || [url.host isEqualToString:<span class="string">@"safepay"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等</span></span><br><span class="line">        <span class="built_in">UITabBarController</span> *tabBarVC = (<span class="built_in">UITabBarController</span> *)topRootViewController;</span><br><span class="line">        <span class="built_in">UINavigationController</span> *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex];</span><br><span class="line">        [navVC popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *orderId = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"PayOrderId"</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *payFee = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"PayFee"</span>];</span><br><span class="line">            <span class="comment">//以及更多参数</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultDict = @&#123;<span class="string">@"order_id"</span>:orderId, <span class="string">@"payFee"</span>:payFee&#125;;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"htmlPaymentNotification"</span> object:<span class="keyword">self</span> userInfo:resultDict];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS集成H5微信支付实现跳转与回调的解决方案</title>
      <link href="/2019-03-22-ios-wxpay-h5-solution/"/>
      <url>/2019-03-22-ios-wxpay-h5-solution/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。</p><p>这篇讲的是H5微信支付如何从App跳转微信以及如何从微信跳转回App，支付宝的见这篇：</p><blockquote><p> <a href="https://paaatrick.com/2019-03-22-ios-alipay-h5-solution/">iOS集成支付宝H5支付实现跳转与回调的解决方案</a></p></blockquote><p>实现的效果是：App→微信→支付(成功失败或取消)→App</p><a id="more"></a><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><p>本项目使用WKWebView，前置动作是后端小伙伴已经处理好微信H5支付下单链接，客户端接收到下单链接后的操作。</p><p>下单链接即为<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=9_20&index=1" target="_blank" rel="noopener">微信支付文档-统一下单API</a>中返回的 <code>mweb_url</code>，格式为 <code>https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458241</code>。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322180048.png" alt></p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="1-添加-URL-Scheme-并把微信加入白名单"><a href="#1-添加-URL-Scheme-并把微信加入白名单" class="headerlink" title="1. 添加 URL Scheme 并把微信加入白名单"></a>1. 添加 URL Scheme 并把微信加入白名单</h2><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322175422.png" alt></p><p>添加 URL Scheme。在 <code>xcodeproj</code> 文件 <code>Info</code> 选项卡最下面的 <code>URL Types</code>内设置。 注意此URL的一级域名需要与微信商户后台(微信商户平台-产品中心-开发配置-H5支付)设置的的一级域名一致，比如微信商户里设置的是<code>company.com</code>，那 URL Schemes 可以设为 <code>a1.company.com</code>，此特性使得一套H5支付可以方便得集成到多个App。只有一个App需要H5支付的话也可以直接填与微信后台的一致的 <code>company.com</code> 。</p><blockquote><p>2019年4月10日更新<br>如果像上图那样填的是 <code>www.company.com</code>，那 URL Scheme 只能设为其三级域名如 <code>a2.www.company.com</code> 或同样的 <code>www.company.com</code></p></blockquote><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190322175420.png" alt></p><p>把微信的 URL Scheme <code>weixin</code> 和 <code>wechat</code> 填入项目的白名单。在 <code>xcodeproj</code> 文件 <code>Info</code> 选项卡内的 <code>Custom iOS Target Properties</code> 的 <code>LSApplicationQueriesSchemes</code> 里添加上述两个字符串，若没有 <code>LSApplicationQueriesSchemes</code> 就手动输入添加，类型为数组 Array。</p><h2 id="2-WKWebView加载链接"><a href="#2-WKWebView加载链接" class="headerlink" title="2. WKWebView加载链接"></a>2. WKWebView加载链接</h2><p>添加协议 <code>WKNavigationDelegate</code>和<code>WKUIDelegate</code>。</p><p>创建一个WKWebView，并加载统一下单链接。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)buildWKWebView &#123;</span><br><span class="line">    <span class="built_in">WKWebView</span> *webView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:webView];</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    webView.UIDelegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *payURL = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.payString];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:payURL];</span><br><span class="line">    [request setValue:<span class="string">@"a1.company.com://wxpaycallback/"</span> forHTTPHeaderField:<span class="string">@"Referer"</span>];</span><br><span class="line">    [webView loadRequest:request];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处self.payString就是后台传来的微信H5支付统一下单链接，格式为 <code>https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458041</code>。</p><p>我们需要做的处理是根据文档给这个请求添加请求头 <code>Referer</code>，关键在于这个 <code>a1.company.com://wxpaycallback/</code> 既满足了微信检测到有商户后台设置好的一级域名，同时把这个链接做成了 URL Scheme 使得可以在跳转微信客户端后（不管支付成功还是失败）能顺利跳转回自己的App。其中的 host <code>wxpaycallback/</code> 可以任意设置，方便在 <code>AppDelegate</code> 里处理跳转回来后部署业务逻辑。当然如果你不需要在 <code>AppDelegate</code> 里接收动作而是直接跳回支付界面自行后续处理的话就只用设为前一步在 URL Scheme <code>a1.company.com://</code> 即可。</p><blockquote><p>2019.4.10 更新 </p><p>经过测试，对于App内的H5支付而言，实际上是下面步骤里<br><code>@&quot;https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb&quot;</code><br>后接的参数 <code>redirect_url</code> 对支付后跳回App起作用，<code>Referer</code>只起到给微信校验的作用。</p><p>所以 <code>Referer</code> 只需要设置成微信H5支付登记的域名的子域名即可，如<br><code>[request setValue:@&quot;a1.company.com&quot; forHTTPHeaderField:@&quot;Referer&quot;];</code></p></blockquote><h2 id="3-实现代理方法拦截链接并跳转微信"><a href="#3-实现代理方法拦截链接并跳转微信" class="headerlink" title="3. 实现代理方法拦截链接并跳转微信"></a>3. 实现代理方法拦截链接并跳转微信</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = navigationAction.request;</span><br><span class="line">    <span class="built_in">NSString</span> *absoluteString = [navigationAction.request.URL.absoluteString stringByRemovingPercentEncoding];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拦截WKWebView加载的微信支付统一下单链接, 将redirect_url参数修改为唤起自己App的URLScheme</span></span><br><span class="line">    <span class="keyword">if</span> ([absoluteString hasPrefix:<span class="string">@"https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb"</span>] &amp;&amp; ![absoluteString hasSuffix:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"redirect_url=a1.company.com://wxpaycallback/"</span>]]) &#123;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="built_in">NSString</span> *redirectUrl = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> ([absoluteString containsString:<span class="string">@"redirect_url="</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSRange</span> redirectRange = [absoluteString rangeOfString:<span class="string">@"redirect_url"</span>];</span><br><span class="line">            redirectUrl = [[absoluteString substringToIndex:redirectRange.location] stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"redirect_url=a1.company.com://wxpaycallback/"</span>]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redirectUrl = [absoluteString stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"redirect_url=a1.company.com://wxpaycallback/"</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSMutableURLRequest</span> *newRequest = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:redirectUrl] cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">30</span>];</span><br><span class="line">        newRequest.allHTTPHeaderFields = request.allHTTPHeaderFields;</span><br><span class="line">        newRequest.URL = [<span class="built_in">NSURL</span> URLWithString:redirectUrl];</span><br><span class="line">        [webView loadRequest:newRequest];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拦截重定向的跳转微信的 URL Scheme, 打开微信</span></span><br><span class="line">    <span class="keyword">if</span> ([absoluteString hasPrefix:<span class="string">@"weixin://"</span>]) &#123;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> ([[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:navigationAction.request.URL]) &#123;</span><br><span class="line">                [[<span class="built_in">UIApplication</span> sharedApplication] openURL:navigationAction.request.URL];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//未安装微信, 自行处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-AppDelegate-中接收跳转动作"><a href="#4-AppDelegate-中接收跳转动作" class="headerlink" title="4. AppDelegate 中接收跳转动作"></a>4. AppDelegate 中接收跳转动作</h2><p>当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。</p><p>以下是AppDelegate接收返回动作的示例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)options&#123;</span><br><span class="line">    <span class="comment">//safepay是支付宝H5支付的回调host</span></span><br><span class="line">    <span class="keyword">if</span> ([url.host isEqualToString:<span class="string">@"wxpaycallback"</span>] || [url.host isEqualToString:<span class="string">@"safepay"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等</span></span><br><span class="line">        <span class="built_in">UITabBarController</span> *tabBarVC = (<span class="built_in">UITabBarController</span> *)topRootViewController;</span><br><span class="line">        <span class="built_in">UINavigationController</span> *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex];</span><br><span class="line">        [navVC popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *orderId = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"PayOrderId"</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *payFee = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:<span class="string">@"PayFee"</span>];</span><br><span class="line">            <span class="comment">//以及更多参数</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultDict = @&#123;<span class="string">@"order_id"</span>:orderId, <span class="string">@"payFee"</span>:payFee&#125;;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"htmlPaymentNotification"</span> object:<span class="keyword">self</span> userInfo:resultDict];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-关于微信H5支付域名设置"><a href="#5-关于微信H5支付域名设置" class="headerlink" title="5. 关于微信H5支付域名设置"></a>5. 关于微信H5支付域名设置</h2><blockquote><p>2019年4月10日更新</p></blockquote><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190410183635.png" alt></p><p>这里额外提一下，截止到2019年4月，微信支付设置页面明确说了</p><blockquote><p>添加域名后，其所属的子域名将都有权限</p></blockquote><p>也就是说只需要填一个一级域名比如 <code>company.com</code> ，就可以有无限多个二级域名可供不同App使用，绕过微信H5支付只能添加5个域名的限制。如果填的是二级域名比如 <code>www.company.com</code>，那么只能往下使用三级域名比如 <code>a1.www.company.com</code></p><p>以微信H5支付域名填了 <code>company.com</code> 为例，那可以这样操作</p><table><thead><tr><th align="center">App</th><th align="center">Alpha</th><th align="center">Beta-A1</th><th align="center">Beta-A2</th><th>Gamma</th></tr></thead><tbody><tr><td align="center">添加的Referer</td><td align="center">alpha.company.com</td><td align="center">a1.beta.company.com</td><td align="center">a2.beta.company.com</td><td>gamma.company.com</td></tr><tr><td align="center">要替换的redirect_url</td><td align="center">alpha.company.com://optional</td><td align="center">a1.beta.company.com://</td><td align="center">a2.beta.company.com://optional</td><td>gamma.company.com://</td></tr><tr><td align="center">URL Scheme</td><td align="center">alpha.company.com</td><td align="center">a1.beta.company.com</td><td align="center">a2.beta.company.com</td><td>gamma.company.com</td></tr></tbody></table><p><a href="https://www.cnblogs.com/Life-Record/p/8472319.html" target="_blank" rel="noopener"><strong>参考博客链接</strong></a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一个 NSArray 是否为空</title>
      <link href="/2019-03-12-if-nsarray-null/"/>
      <url>/2019-03-12-if-nsarray-null/</url>
      
        <content type="html"><![CDATA[<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([array isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] &amp;&amp; array.count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"这是一个非空数组"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iPhone屏幕各种尺寸分辨率（更新至XS）</title>
      <link href="/2019-03-05-iphone-pixel-point-size-scale/"/>
      <url>/2019-03-05-iphone-pixel-point-size-scale/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>Device</th><th>Logic Point</th><th>Logic Pixel</th><th>Size</th><th>Scale</th></tr></thead><tbody><tr><td>iPhone 2G</td><td>480 × 320</td><td>480 × 320</td><td>3.5</td><td>1x</td></tr><tr><td>iPhone 3</td><td>480 × 320</td><td>480 × 320</td><td>3.5</td><td>1x</td></tr><tr><td>iPhone 3GS</td><td>480 × 320</td><td>480 × 320</td><td>3.5</td><td>1x</td></tr><tr><td>iPhone 4</td><td>480 × 320</td><td>960 × 640</td><td>3.5</td><td>2x</td></tr><tr><td>iPhone 4S</td><td>480 × 320</td><td>960 × 640</td><td>3.5</td><td>2x</td></tr><tr><td>iPhone 5</td><td>568 × 320</td><td>1136 × 640</td><td>4.0</td><td>2x</td></tr><tr><td>iPhone 5S</td><td>568 × 320</td><td>1136 × 640</td><td>4.0</td><td>2x</td></tr><tr><td>iPhone 5C</td><td>568 × 320</td><td>1136 × 640</td><td>4.0</td><td>2x</td></tr><tr><td>iPhone 6</td><td>667 × 375</td><td>1334 × 750</td><td>4.7</td><td>2x</td></tr><tr><td>iPhone 6 Plus</td><td>736 × 414</td><td>2208 × 1242</td><td>5.5</td><td>3x</td></tr><tr><td>iPhone 6S</td><td>667 × 375</td><td>1334 × 750</td><td>4.7</td><td>2x</td></tr><tr><td>iPhone 6S Plus</td><td>736 × 414</td><td>2208 × 1242</td><td>5.5</td><td>3x</td></tr><tr><td>iPhone SE</td><td>568 × 320</td><td>1136 × 640</td><td>4.0</td><td>2x</td></tr><tr><td>iPhone 7</td><td>667 × 375</td><td>1334 × 750</td><td>4.7</td><td>2x</td></tr><tr><td>iPhone 7 Plus</td><td>736 × 414</td><td>2208 × 1242</td><td>5.5</td><td>3x</td></tr><tr><td>iPhone 8</td><td>667 × 375</td><td>1334 × 750</td><td>4.7</td><td>2x</td></tr><tr><td>iPhone 8 Plus</td><td>736 × 414</td><td>2208 × 1242</td><td>5.5</td><td>3x</td></tr><tr><td>iPhone X</td><td>812 × 375</td><td>2436 × 1125</td><td>5.8</td><td>3x</td></tr><tr><td>iPhone XS</td><td>812 × 375</td><td>2436 × 1125</td><td>5.8</td><td>3x</td></tr><tr><td>iPhone XR</td><td>896 × 414</td><td>1792 × 828</td><td>6.1</td><td>2x</td></tr><tr><td>iPhone XS Max</td><td>896 × 414</td><td>2688 × 1242</td><td>6.5</td><td>3x</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些iOS面试基础题总结</title>
      <link href="/2019-03-01-ios-interview-thing/"/>
      <url>/2019-03-01-ios-interview-thing/</url>
      
        <content type="html"><![CDATA[<p>一些iOS面试基础题总结</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>多线程</li><li>AutoLayout</li><li>objc_msgSend</li><li>Runtime</li><li>消息转发</li><li>Category</li><li>NSObject 与 objc_class</li><li>Runloop</li><li>AutoreleasePool</li><li>iOS系统架构</li><li>App启动过程和优化</li><li>UIScrollView 的代理方法</li><li>响应链和事件传递</li><li>UIView 和 CALayer 的区别和联系</li><li>轮播图朴素实现的几种方法</li><li>TableView 和 CollectionView 必选的代理方法</li><li>UITableView 的优化思路</li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="线程之间同步"><a href="#线程之间同步" class="headerlink" title="线程之间同步"></a>线程之间同步</h4><ol><li>原子操作 Atomic</li><li>加锁（互斥锁、递归锁、读写锁）NSLock，OSSpinLock</li></ol><h4 id="多线程之间通信"><a href="#多线程之间通信" class="headerlink" title="多线程之间通信"></a>多线程之间通信</h4><ul><li>performSelectorOnMainThread:withObject:waitUntilDone:</li></ul><h4 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h4><ol><li>OSSpinLock 自旋锁</li><li>dispatch_semaphore</li><li>NSLock 等各种锁</li><li>@synchronized</li></ol><h4 id="多线程的坑"><a href="#多线程的坑" class="headerlink" title="多线程的坑"></a>多线程的坑</h4><ol><li>常驻线程</li></ol><p>常驻线程多了影响CPU效率</p><p>AFNetworking2.0因为用的NSURLConnection有缺陷，需要所在线程一直存活，所以保持了个常驻线程，3.0用了NSURLSession，可以指定回调的delegateQueue于是弃用常驻线程。</p><p>[runloop run]是常驻线程，[runloop runUntilDate]指定保活时长</p><ol start="2"><li>并发</li></ol><p>GCD本着最大化CPU效率的原则会多创建线程，但如果是IO类操作，需要等待数据的空档会继续创建新线程导致内存失控。类似数据库操作尽量用串行队列避免多线程并发导致问题。因为创建线程需要堆栈内存，切换线程也消耗CPU。</p><ol start="3"><li>死锁</li></ol><p>串行队列（如主队列）同步操作</p><h2 id="AutoLayout"><a href="#AutoLayout" class="headerlink" title="AutoLayout"></a>AutoLayout</h2><p>更新屏幕时，Layout Engine从上到下调用layoutSubviews()通过 Cassowary 算法计算各个子视图的位置，算出来后将子视图的 frame 从 Layout Engine 里拷贝出来，接下来的过程就跟手写frame是一样的了。iOS12优化了性能，以前元素多了会导致性能下降，现正不会了</p><h2 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h2><ol><li>检查这个selector是不是要忽略的</li><li>检查target是不是nil<ul><li>如果有相应处理nil的函数就跳转到该函数</li><li>如果没有就自动清理现场并返回，这就是OC中给nil发消息不会崩溃的原因</li></ul></li><li>确定不是给nil发消息后，在该class的缓存中查找方法对应的IMP实现<ul><li>如果找到就跳转进去</li><li>如果没找到就在方法分发表里继续查找，直到找到NSObject为止</li></ul></li><li>如果还没找到就开始消息转发，上述过程就是通过SEL快速查找IMP的过程</li></ol><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>C语言中，编译期函数的调用就决定调用哪个函数，而OC只有在真正运行时才根据函数名称找到对应函数来调用。需要一个运行时系统来动态地创建类和对象、消息传递和转发</p><ol><li><p>讲一下 OC 的消息机制</p><ul><li>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）</li><li>objc_msgSend底层有3大阶段:消息发送（当前类、父类中查找）、动态方法解析、消息转发</li><li>当递归地找不到selector时，启动消息转发：resolveInstanceMethod、resolveClassMethod、forwardingTargetForSelector</li></ul></li><li><p>什么是Runtime？平时项目中有用过么？</p><ul><li>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行</li><li>OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数</li><li>平时编写的OC代码，底层都是转换成了Runtime API进行调用</li></ul></li><li><p>Runtime 的应用（优点）：</p><ul><li>实现多继承 Multiple Inheritance</li><li>Method Swizzling -&gt; 无侵入埋点 -&gt; 使用Category进行</li><li>Aspect Oriented Prigramming 面向切面编程AOP -&gt; 如日志、身份验证、缓存等模块</li><li>isa Swizzling -&gt; KVO的实现</li><li>Associated Object关联对象(给Category添加属性) objc_set(get)AssociatedObject </li><li>动态地增加方法</li><li>NSCoding 的自动归档和自动解档</li><li>字典和模型相互转换！</li><li>异常保护（保护数组越界问题）</li></ul></li><li><p>Runtime 的缺点</p><ul><li>Method Swizzling 不是原子操作，放在+load里没问题，放在+initialize里就有问题了</li><li>重写方法而不调用super方法可能有问题</li></ul></li><li><p>Runtime 注意事项</p><ul><li>Swizzling应该总在+load中执行</li><li>Swizzling应该总在dispatch_once中执行 -&gt; 因为会改变全局状态所以应该只执行一次</li><li>+load中执行Swizzling时，不要调用[super load] -&gt; 避免偶数次执行Swizzling</li></ul></li></ol><ul><li>SEL其本身是一个Int类型的地址，地址中存放着方法的名字。</li></ul><h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><h4 id="几个常见方法"><a href="#几个常见方法" class="headerlink" title="几个常见方法"></a>几个常见方法</h4><ol><li>method_setImplementation</li></ol><p>为一个方法名设置IMP(实现)</p><ol start="2"><li>method_exchangeImplementations</li></ol><p>交换两个方法名的实现，即执行两次 method_setImplementation</p><ol start="3"><li>class_addMethod</li></ol><p>根据官方注释解释，这个方法用于给指定的类增加方法名和IMP(实现)，如果该已经存在这个方法名，不做事，返回NO，如果该类不存在这个方法名（即使父类存在），添加这个方法，返回YES</p><ol start="4"><li>class_replaceMethod</li></ol><p>根据官方注释解释，它有两种不同的行为。当类中没有想替换的原方法时，该方法会调用 class_addMethod 来为该类增加一个新方法。若已存在，则等同于 method_setImplementation 为该方法名替换IMP(实现)</p><h4 id="Swizzling-模板"><a href="#Swizzling-模板" class="headerlink" title="Swizzling 模板"></a>Swizzling 模板</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)hookClass:(Class)classObject fromSelector:(SEL)fromSelector toSelector:(SEL)toSelector &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = classObject;</span><br><span class="line">    Method fromMethod = class_getInstanceMethod(<span class="keyword">class</span>, fromSelector); <span class="comment">// 得到被交换类的实例方法</span></span><br><span class="line">    Method toMethod = class_getInstanceMethod(<span class="keyword">class</span>, toSelector); <span class="comment">// 得到交换类的实例方法</span></span><br><span class="line">    <span class="keyword">if</span>(class_addMethod(<span class="keyword">class</span>, fromSelector, method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">class</span>, toSelector, method_getImplementation(fromMethod), method_getTypeEncoding(fromMethod)); <span class="comment">// 进行方法的交换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(fromMethod, toMethod); <span class="comment">// 交换 IMP 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class aClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line">        </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod =</span><br><span class="line">        class_addMethod(aClass,</span><br><span class="line">                        originalSelector,</span><br><span class="line">                        method_getImplementation(swizzledMethod),</span><br><span class="line">                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(aClass,</span><br><span class="line">                                swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>什么时候会报unrecognized selector的异常？</p><blockquote><p>当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。</p></blockquote><p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：</p><ol><li>Method resolution</li></ol><p>objc运行时会调用<code>+resolveInstanceMethod:</code>或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。</p><ol start="2"><li>Fast forwarding</li></ol><p>如果目标对象实现了<code>-forwardingTargetForSelector:</code>，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。</p><ol start="3"><li>Normal forwarding</li></ol><p>这一步是Runtime最后一次给你挽救的机会。首先它会发送<code>-methodSignatureForSelector:</code>消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送<code>-forwardInvocation:</code>消息给目标对象。</p><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>通过Runtime给类添加方法，可以把类的实现分开在几个不同的文件，减少单个文件体积、不同功能组织到不同的Category里、可以由多人开发一个类、可以按需加载想要的category、可以把framework的私有方法公开</p><p>与extension不同的是，extension需要有类的源码才能添加，所以无法为系统类添加extension。</p><p>而category是运行时添加的。所以，extension可以添加实例变量，而category只能添加实例方法、类方法、协议、属性，但是不能添加实例变量。</p><p>category并不是完全替换掉原来类的方法，而是附加到方法列表的前面，而runtime寻找方法是顺着找的，找到category覆盖的方法后就执行了</p><h2 id="NSObject-与-objc-class"><a href="#NSObject-与-objc-class" class="headerlink" title="NSObject 与 objc_class"></a>NSObject 与 objc_class</h2><p>NSObject 继承自 objc_class<br>objc_class 继承自 objc_object</p><p><code>objc_object -&gt; objc_class -&gt; NSObject</code></p><p>所以OC中，类也是一个对象。</p><p>objc_class中，除了isa，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法链表。</p><p>每个类都有单独的元类，所以类的superclass指针递归最后指向NSObject，NSObject没有超类所以指向nil。类的isa指向对应唯一的元类，每个元类的isa都指向rootMetaClass，rootMetaClass的superClass指向NSObject，isa指向自己</p><p>元类中保存了创建类对象以及类方法所需的所有信息</p><h2 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h2><p>可以先粗看这篇<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">YYKit大神ibireme的文章</a>，大概过一遍，不用纠结源码和看不懂的地方。<br>然后看这个<a href="https://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="noopener">孙源的线下分享会视频</a>，最后再细看一遍那篇文章</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>运行循环，在程序运行过程中循环做一些事情，如果没有Runloop程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省CPU资源，提高程序性能。简单来说就是让软件一直活着。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190611111951.png" alt></p><ul><li>一个线程对应一个<code>Runloop</code>，主线程的Runloop默认开启，子线程如果不手动开启就没有。</li><li>每个Runloop内有多个Mode，但Runloop同一时间只能执行一个Mode，换Mode需要停下切换。</li><li>每个Mode内有任意多个<code>Source</code>、<code>Timer</code>、<code>Observer</code></li></ul><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><ul><li>即 <code>CFRunloopTimer</code></li><li><code>NSTimer</code>、<code>performSelector:afterDelay:</code>、<code>CADisplayLink</code>都是对<code>RunloopTimer</code>的封装</li></ul><h4 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h4><ul><li>即 <code>CFRunlopSource</code>，是Runloop的数据源抽象类</li><li>Source分<code>Source0</code>和<code>Source1</code></li><li><code>Source0</code>处理App内部事件、App自己负责管理触发、如<code>UIEvent</code>、<code>CFSocker</code></li><li><code>Source1</code>有Runloop和内核管理，<code>Mach Port</code>驱动，如<code>CFMachPort</code>、<code>CFMessagePort</code></li></ul><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><ul><li>向外部报告Runloop当前状态的更改</li><li>框架中很多机制都由RunLoopObserver触发，如CAAnimation</li><li>与 AutoreleasePool 的关系：UIKit通过Observer在RunLoop两个Sleep之间对AutoreleasePool进行Pop和Push，将这次Loop中产生的Autorelease对象释放</li></ul><h4 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h4><ul><li>每个Runloop内有多个Mode，但Runloop同一时间只能执行一个Mode，换Mode需要停止当前Loop切换然后重启Loop。</li></ul><ol><li>默认Mode：<code>NSDefaultRunLoopMode</code>, 空闲状态、普通事件等</li><li>界面追踪Mode：<code>UITrackingRunLoopMode</code>, 滑动时（ScrollView）</li><li>私有Mode：UIInitializationRunLoopMode, App刚启动时, 不重要</li></ol><ul><li><code>NSRunLoopCommonModes</code>是一个集合（打标签），默认包含上面的1和2两个Mode，可以自己添加Mode进去</li><li>开始滑动时，会从DefaultRunLoopMode切换成UITrackingRunLoopMode，停止滑动时会切换回来</li><li>想让<code>NSTimer</code>滑动时也跑，默认是加到DefaultMode的，需要手动加到CommonModes里，使其滑动时也执行，<code>[(NSRunLoop) addTimer:forMode:]</code></li></ul><h4 id="RunLoop-与-GCD-的关系"><a href="#RunLoop-与-GCD-的关系" class="headerlink" title="RunLoop 与 GCD 的关系"></a>RunLoop 与 GCD 的关系</h4><ul><li>只在用到 main queue 时</li><li>GCD 中 dispatch 到 main queue 的 block 被分发到 main RunLoop 中执行</li></ul><h4 id="RunLoop-的挂起与唤醒"><a href="#RunLoop-的挂起与唤醒" class="headerlink" title="RunLoop 的挂起与唤醒"></a>RunLoop 的挂起与唤醒</h4><ul><li>指定用于唤醒的 mach_port 端口</li><li>调用 mach_msg 监听唤醒端口，被唤醒前，系统内核将这个线程挂起，停留在 mach_msg_trap 状态<br><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20190611150612.png" alt></li><li>由另一个线程（或另一个进程中的某个线程）向内核发送该端口的msg后，trap状态被唤醒，RunLoop继续下一轮</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行，对于子线程可以使用run来常驻线程。</li><li>保证NSTimer正常运转</li><li>线上监测App卡顿情况</li><li>处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等）</li><li>节省CPU资源，提高程序性能，程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CUP，现在没有事情做，我要去休息，这时CUP就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情</li></ol><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>进入loop</li><li>do while 保活线程：触发Timer回调、触发Source()回调、执行block</li><li>进入休眠</li><li>等待mach_port消息（如Timer时间到、Runloop超时、被调用者唤醒）</li><li>唤醒，处理消息</li><li>判断是否进入下一个loop</li></ol><h4 id="AFNetworking的RunLoop用法"><a href="#AFNetworking的RunLoop用法" class="headerlink" title="AFNetworking的RunLoop用法"></a>AFNetworking的RunLoop用法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在子线程开启RunLoop，添加一个不会用到的port作为Source防止RunLoop停止</li><li><code>[runloop run]</code>使子线程常驻，从而接收NSURLConnection的回调</li><li>在AF的3.0版本里替换成NSURLSession就不需要常驻线程了</li></ul><h4 id="利用RunLoop延时加载图片"><a href="#利用RunLoop延时加载图片" class="headerlink" title="利用RunLoop延时加载图片"></a>利用RunLoop延时加载图片</h4><ul><li>当scrollview滑动时加载图片可能导致卡顿</li><li>原本做法可以通过delegate处理是否加载</li><li>利用RunLoop：把图片加载的方法放在<code>NSDefaultRunLoopMode</code>里，这样当滑动时就切换出了这个Mode，暂停加载</li></ul><h4 id="Crash时重启RunLoop"><a href="#Crash时重启RunLoop" class="headerlink" title="Crash时重启RunLoop"></a>Crash时重启RunLoop</h4><ul><li>接到 Crash 的 Signal 后手动重启 RunLoop</li><li>不适用于 BAD_ACCESS</li></ul><h4 id="监测卡顿的方法"><a href="#监测卡顿的方法" class="headerlink" title="监测卡顿的方法"></a>监测卡顿的方法</h4><ol><li>创建观察者</li><li>把观察者添加到主线程的Runloop的common模式下观察，然后创建一个常驻子线程专门用来监控主线程的Runloop状态</li><li>一旦发现runloop进入睡眠前的状态或者唤醒后的状态在设置的时间阈值内没有变化，即可判定为卡顿，用第三方库PLCrashReporter来获取堆栈信息，上报服务器。后续分析。</li></ol><h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>配合runloop的，每次runloop开启时重建自动释放池，休息前释放掉池里的东西如Timer<br>ARC下自动创建的在子线程结束后释放，手动创建的在作用域大括号结束后释放<br>底层实现 AutoReleasePoolPage 是一个双向链表，有push release pop操作</p><h2 id="iOS系统架构"><a href="#iOS系统架构" class="headerlink" title="iOS系统架构"></a>iOS系统架构</h2><p>四个层</p><ul><li>第一层：用户体验层：SpringBoard</li><li>第二层：应用框架层：CocoaTouch</li><li>第三层：核心框架层：Metal、图形媒体核心框架</li><li>第四层：Darwin层：XNU、内核、驱动</li></ul><p>iOS的可执行文件和动态库都是Mach-O格式，加载App实际就是加载Mach-O文件。</p><h2 id="App启动过程与优化"><a href="#App启动过程与优化" class="headerlink" title="App启动过程与优化"></a>App启动过程与优化</h2><ol><li><p>main()执行前</p><ul><li>加载可执行文件（App的.o文件的集合）</li><li>加载动态链接库，进行rebase指针调整和bind符号绑定</li><li>Objc Runtime 的初始处理，包括 Objc 相关类的注册、Category注册、selector 唯一性检查</li><li>+load()初始化<blockquote><p>这个阶段的优化有 1. 减少动态库加载（合并动态库）2. 减少加载启动后不会去用的类和方法 3. 少用+load，或用 +initialize替换，因为runtime 的 Method Swizzling 操作每次4ms</p></blockquote></li></ul></li><li><p>main()执行后</p><ul><li>指 main() 执行开始到 didFinishLaunchingWithOptions 方法里首屏渲染相关方法完成</li><li>配置初始化文件的IO操作</li><li>首屏列表大数据的读取</li><li>首屏渲染的大量计算<blockquote><p>优化方法有把各种与首屏渲染不相干的初始化挪走或子线程处理</p></blockquote></li></ul></li><li><p>首屏渲染完成后</p><ul><li>指 didFinishLaunchingWithOptions 作用域内执行首屏渲染之后的所有方法执行完成</li><li>非首屏其他业务服务模块的初始化</li><li>监听的注册</li><li>配置文件的读写<blockquote><p>把可能卡住主线程的方法挪走或子线程处理</p></blockquote></li></ul></li></ol><h2 id="UIScrollView-的代理方法"><a href="#UIScrollView-的代理方法" class="headerlink" title="UIScrollView 的代理方法"></a>UIScrollView 的代理方法</h2><ol><li>滚动完 scrollViewDidScroll </li><li>缩放完 scrollViewDidZoom</li><li>将要开始拖动 scrollViewWillBeginDragging</li><li>将要结束拖动 scrollViewWillEndDragging</li><li>滑动将要减速、 滑动减速完成</li><li>滚动动画完成</li><li>将要开始缩放、已经结束缩放</li></ol><h2 id="响应链和事件传递"><a href="#响应链和事件传递" class="headerlink" title="响应链和事件传递"></a>响应链和事件传递</h2><ol><li><p>hitTest方法检测看是否返回</p></li><li><p>继承<code>UIResponder</code>的类才能响应，如<code>UIApplication</code>、<code>UIView</code>、<code>UIViewController</code>。而<code>CALayer</code>是继承自<code>NSObject</code>的，不能响应</p></li><li><p>事件首先传递给<code>UIApplication</code>，然后向下分发给<code>UIWindow</code>，然后分发给最下层的<code>UIView</code>，逐步调用<code>hitTest</code>从屏内向外找，当某个<code>UIView</code>返回YES时就递归对其<code>SubView</code>执行<code>hitTest</code>，直到找到最后一个</p></li></ol><ul><li>某<code>UIView</code>不接受事件的情况：<ol><li>alpha &lt; 0.01</li><li>userInteractionEnabled = NO</li><li>hidden = YES</li></ol></li></ul><h2 id="UIView-和-CALayer-的区别和联系"><a href="#UIView-和-CALayer-的区别和联系" class="headerlink" title="UIView 和 CALayer 的区别和联系"></a>UIView 和 CALayer 的区别和联系</h2><ol><li>UIView能响应，CALayer不能</li><li>View的frame(和bounds)是简单返回layer的frame(bound), 而layer的frame由几个参数决定</li><li>UIView 是 CALayer 的代理</li><li>每个UIView内都有一个CALayer（即有个属性）</li></ol><h2 id="轮播图朴素实现的集中方法"><a href="#轮播图朴素实现的集中方法" class="headerlink" title="轮播图朴素实现的集中方法"></a>轮播图朴素实现的集中方法</h2><ol><li>UICollectionView, 简单粗暴放100个Cell</li><li>UIScrollView 首尾各放一个展示</li><li>UIScrollView 三个ImageView实现</li><li>UIImageView 自己实现layer转场动画</li></ol><h2 id="TableView-和-CollectionView-必选的代理方法"><a href="#TableView-和-CollectionView-必选的代理方法" class="headerlink" title="TableView 和 CollectionView 必选的代理方法"></a>TableView 和 CollectionView 必选的代理方法</h2><ul><li>delegate都是可选</li><li>datasource各有两个必选</li><li>table: cellForRowAtIndexPath、numberOfRowsInSection</li><li>collection: cellForItemAtIndexPath、numberOfItemsInSection</li></ul><h2 id="UITableView-的优化思路"><a href="#UITableView-的优化思路" class="headerlink" title="UITableView 的优化思路"></a>UITableView 的优化思路</h2><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>获取数据；</li><li>把数据转化成model、存进数组；</li><li>tableview调用reloadData刷新数据；</li><li>在代理方法cellForRowAtIndexPath里，创建自定义的cell，把model赋值给cell；</li><li>cell在对应的model的set方法里，根据拿到的model，设置图片的image，设置label的text等(控件都以懒加载形式初始化)；</li><li>在代理方法heightForRowAtIndexPath里，根据model，算出当前行应该显示多少的高度；</li><li>在cell的layoutSubviews方法里，布局子控件。</li></ol><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><ol><li>避免主线程阻塞</li></ol><p>1/2步里的获取数据、数据处理等耗时操作，应该放入后台线程异步处理，处理好后再通知主线程刷新界面。</p><ol start="2"><li>避免频繁的对象创建</li></ol><p>对象的创建会发送内存分配、属性调整等。<br>所以，首先，尽量用轻量的对象代替重量的对象。比如CALayer代替UIView。<br>接着，多利用缓存思想，对象创建后缓存起来，需要的时候再拿出来用。合理利用内存开销，减少CPU开销。<br>把 Cell setModel里的一些操作放在第二步数据转model里</p><ol start="3"><li>减少对象的属性赋值操作</li></ol><p>尤其是UIView的frame/bounds等属性的赋值操作，会产生比较大的CPU消耗。<br>尽量少让Cell里空间动态变化，有规律的话筛分成多个固定cell</p><ol start="4"><li>异步绘制</li></ol><p>文本渲染、图像绘制都是比较消耗性能的操作，而UILabel等控件都是在主线程进行的文本绘制。这会对性能产生比较大的影响。<br>UIKit和CoreAnimation相关操作必须在主线程中进行，其它的可以在后台线程异步执行</p><ol start="5"><li>简化视图结构</li></ol><p>GPU在绘制图像前，会把重叠的视图进行混合，视图结构越复杂，这个操作就越耗时，如果存在透明视图，混合过程会更加复杂。所以，我们可以：</p><ul><li>尽量避免复杂的图层结构</li><li>少使用透明的视图</li><li>不透明的视图，设置opaque = YES </li></ul><ol start="6"><li>减少离屏渲染</li></ol><p>老生常谈之圆角问题，圆角是开发中经常使用到的美化方式，但一般的设置cornerRadius时会配合masksToBounds属性，这就会造成离屏渲染。关于这种问题的处理，大致有两个思路：</p><ul><li>异步绘制一张圆角的图片来显示；</li><li>用一个圆角而中空的图来盖住。</li></ul><p>tableview需要刷新数据时，使用<br>[tableview beginUpdates]、[tableview insertRowsAtIndexPaths:indexArray withRowAnimation:UITableViewRowAnimationNone]、<br>[tableview endUpdates];而非<br>[tableview reloadData]从而刷新更少的行减少CPU压力</p><ol start="7"><li>对于固定行高，前一个设置属性比后一个实现代理方法效率高</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cell.tableview.rowHeight = <span class="number">50.0</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">50.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>NSDateFormatter这个对象的相关操作很费时，需要避免频繁的创建和计算</p></li><li><p>利用RunLoop延时加载图片</p></li></ol><p>利用RunLoop：把图片加载的方法放在<code>NSDefaultRunLoopMode</code>里，这样当滑动时就切换出了这个Mode，暂停加载</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS处理多线程异步Block中的UI操作</title>
      <link href="/2019-02-23-ios-block-and-mainqueue/"/>
      <url>/2019-02-23-ios-block-and-mainqueue/</url>
      
        <content type="html"><![CDATA[<p>多线程方法的<code>completionHandler</code>block可能运行在非主线程上。两种处理方法：</p><a id="more"></a><ol><li>在block里手动加上<code>dispatch_async(dispatch_get_main_queue(), ^{});</code></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];<span class="comment">//no delegateQueue</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:url] cachePolicy:<span class="built_in">NSURLRequestReturnCacheDataElseLoad</span> timeoutInterval:<span class="number">30.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(<span class="built_in">NSURL</span> * _Nullable location, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<span class="comment">/* do UI things */</span>&#125;);</span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(doUIthings) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure><ol start="2"><li>带有<code>delegateQueue</code>等参数的方法，可传入主线程队列，然后block<code>completionHandler</code>便运行在主线程了。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];<span class="comment">//get the mainQueue</span></span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:url] cachePolicy:<span class="built_in">NSURLRequestReturnCacheDataElseLoad</span> timeoutInterval:<span class="number">30.0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(<span class="built_in">NSURL</span> * _Nullable location, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line"><span class="comment">/* do UI things */</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 判断NSString值是否为空或null并转换为空字符串</title>
      <link href="/2019-02-12-transfer-null-to-nsstring/"/>
      <url>/2019-02-12-transfer-null-to-nsstring/</url>
      
        <content type="html"><![CDATA[<p>遇到了一个后台json误将null作为字符串值导致iOS客户端崩溃闪退的问题，解决方法如下：套一层判断，如果是各种情况的null则转换为@””。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *) nullToString:(<span class="keyword">id</span>)string &#123;</span><br><span class="line">    <span class="keyword">if</span> ([string isEqual:<span class="string">@"NULL"</span>] || [string isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || [string isEqual:[<span class="built_in">NSNull</span> null]] || [string isEqual:<span class="literal">NULL</span>] || [[string <span class="keyword">class</span>] isSubclassOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || string == <span class="literal">nil</span> || string == <span class="literal">NULL</span> || [string isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] || [[string stringByTrimmingCharactersInSet:[<span class="built_in">NSCharacterSet</span> whitespaceAndNewlineCharacterSet]] length]==<span class="number">0</span> || [string isEqualToString:<span class="string">@"&lt;null&gt;"</span>] || [string isEqualToString:<span class="string">@"(null)"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">@""</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">NSString</span> *)string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS MJExtension使用方法指南(Objective-C)</title>
      <link href="/2019-02-03-mj-extension-guide/"/>
      <url>/2019-02-03-mj-extension-guide/</url>
      
        <content type="html"><![CDATA[<h2 id="MJExtension能做什么？"><a href="#MJExtension能做什么？" class="headerlink" title="MJExtension能做什么？"></a>MJExtension能做什么？</h2><h5 id="1-MJExtension是一套字典和模型之间互相转换的超轻量级框架"><a href="#1-MJExtension是一套字典和模型之间互相转换的超轻量级框架" class="headerlink" title="1. MJExtension是一套字典和模型之间互相转换的超轻量级框架"></a>1. MJExtension是一套字典和模型之间互相转换的超轻量级框架</h5><h5 id="2-MJExtension能完成的功能"><a href="#2-MJExtension能完成的功能" class="headerlink" title="2. MJExtension能完成的功能"></a>2. MJExtension能完成的功能</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字典（JSON） --&gt; 模型（Model）</span><br><span class="line">模型（Model） --&gt; 字典（JSON）</span><br><span class="line">字典数组（JSON Array） --&gt; 模型数组（Model Array）</span><br><span class="line">模型数组（Model Array） --&gt; 字典数组（JSON Array）</span><br></pre></td></tr></table></figure><p><code>详尽用法主要参考 main.m中的各个函数 以及 NSObject+MJKeyValue.h</code></p><h2 id="MJExtension和JSONModel、Mantle等框架的区别"><a href="#MJExtension和JSONModel、Mantle等框架的区别" class="headerlink" title="MJExtension和JSONModel、Mantle等框架的区别"></a>MJExtension和JSONModel、Mantle等框架的区别</h2><h5 id="1-转换速率："><a href="#1-转换速率：" class="headerlink" title="1. 转换速率："></a>1. 转换速率：</h5><p>最近一次测试表明：<code>MJExtension &gt; JSONModel &gt; Mantle</code> 各位开发者也可以自行测试</p><h5 id="2-具体用法："><a href="#2-具体用法：" class="headerlink" title="2. 具体用法："></a>2. 具体用法：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JSONModel：</span><br><span class="line"></span><br><span class="line">要求所有模型类必须继承自JSONModel基类</span><br><span class="line"></span><br><span class="line">Mantle：</span><br><span class="line"></span><br><span class="line">要求所有模型类必须继承自MTModel基类</span><br><span class="line"></span><br><span class="line">MJExtension：</span><br><span class="line"></span><br><span class="line">不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性</span><br></pre></td></tr></table></figure><h2 id="如何安装MJExtension"><a href="#如何安装MJExtension" class="headerlink" title="如何安装MJExtension"></a>如何安装MJExtension</h2><p>方法一：cocoapods导入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'MJExtension'</span></span><br></pre></td></tr></table></figure><p>方法二：手动导入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">将MJExtensionExample/MJExtensionExample/MJExtension文件夹中的所有源代码拽入项目中</span><br><span class="line">导入主头文件：<span class="meta">#import <span class="meta-string">"MJExtension.h"</span></span></span><br><span class="line">MJExtension.h</span><br><span class="line">MJConst.h</span><br><span class="line">MJConst.m</span><br><span class="line">MJFoundation.h</span><br><span class="line">MJFoundation.m</span><br><span class="line">MJIvar.h</span><br><span class="line">MJIvar.m</span><br><span class="line">MJType.h</span><br><span class="line">MJType.m</span><br><span class="line"><span class="built_in">NSObject</span>+MJCoding.h</span><br><span class="line"><span class="built_in">NSObject</span>+MJCoding.m</span><br><span class="line"><span class="built_in">NSObject</span>+MJIvar.h</span><br><span class="line"><span class="built_in">NSObject</span>+MJIvar.m</span><br><span class="line"><span class="built_in">NSObject</span>+MJKeyValue.h</span><br><span class="line"><span class="built_in">NSObject</span>+MJKeyValue.m</span><br></pre></td></tr></table></figure><h2 id="如何使用MJExtension"><a href="#如何使用MJExtension" class="headerlink" title="如何使用MJExtension"></a>如何使用MJExtension</h2><h4 id="1-最简单的字典转模型"><a href="#1-最简单的字典转模型" class="headerlink" title="1. 最简单的字典转模型"></a>1. 最简单的字典转模型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    SexMale,    </span><br><span class="line">    SexFemale&#125; Sex;</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *icon;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">double</span> height;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *money;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) Sex sex;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</span><br><span class="line">                        <span class="string">@"name"</span> : <span class="string">@"Jack"</span>,                 </span><br><span class="line">                        <span class="string">@"icon"</span> : <span class="string">@"lufy.png"</span>,               </span><br><span class="line">                        <span class="string">@"age"</span> : @<span class="number">20</span>,               </span><br><span class="line">                        <span class="string">@"height"</span> : <span class="string">@"1.55"</span>,               </span><br><span class="line">                        <span class="string">@"money"</span> : @<span class="number">100.9</span>,               </span><br><span class="line">                        <span class="string">@"sex"</span> : @(SexFemale)            </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典转为User模型</span></span><br><span class="line">User *user = [User objectWithKeyValues:dict];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"name=%@, icon=%@, age=%d, height=%@, money=%@, sex=%d"</span>, user.name, user.icon, user.age, user.height, user.money, user.sex);</span><br><span class="line"><span class="comment">// name=Jack, icon=lufy.png, age=20, height=1.550000, money=100.9, sex=1</span></span><br></pre></td></tr></table></figure><h5 id="核心代码1："><a href="#核心代码1：" class="headerlink" title="核心代码1："></a>核心代码1：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[User objectWithKeyValues:dict]</span><br></pre></td></tr></table></figure><h4 id="2-模型中嵌套模型"><a href="#2-模型中嵌套模型" class="headerlink" title="2. 模型中嵌套模型"></a>2. 模型中嵌套模型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Status</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/** 微博文本内容 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *text;</span><br><span class="line"><span class="comment">/** 微博作者 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) User *user;</span><br><span class="line"><span class="comment">/** 转发的微博 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Status *retweetedStatus;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;               </span><br><span class="line"><span class="string">@"text"</span> : <span class="string">@"是啊，今天天气确实不错！"</span>, </span><br><span class="line"><span class="string">@"user"</span> : @&#123;                   </span><br><span class="line">             <span class="string">@"name"</span> : <span class="string">@"Jack"</span>,                   </span><br><span class="line">             <span class="string">@"icon"</span> : <span class="string">@"lufy.png"</span>                </span><br><span class="line">           &#125;,               </span><br><span class="line"><span class="string">@"retweetedStatus"</span> : @&#123;                   </span><br><span class="line">                        <span class="string">@"text"</span> : <span class="string">@"今天天气真不错！"</span>,                   </span><br><span class="line">                        <span class="string">@"user"</span> : @&#123;                       </span><br><span class="line">                                    <span class="string">@"name"</span> : <span class="string">@"Rose"</span>,                       </span><br><span class="line">                                    <span class="string">@"icon"</span> : <span class="string">@"nami.png"</span>                    </span><br><span class="line">                                   &#125;                </span><br><span class="line">                       &#125;            </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典转为Status模型</span></span><br><span class="line">Status *status = [Status objectWithKeyValues:dict];</span><br><span class="line"><span class="built_in">NSString</span> *text = status.text;</span><br><span class="line"><span class="built_in">NSString</span> *name = status.user.name;</span><br><span class="line"><span class="built_in">NSString</span> *icon = status.user.icon;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"text=%@, name=%@, icon=%@"</span>, text, name, icon);</span><br><span class="line"><span class="comment">// text=是啊，今天天气确实不错！, name=Jack, icon=lufy.png</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *text2 = status.retweetedStatus.text;</span><br><span class="line"><span class="built_in">NSString</span> *name2 = status.retweetedStatus.user.name;</span><br><span class="line"><span class="built_in">NSString</span> *icon2 = status.retweetedStatus.user.icon;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"text2=%@, name2=%@, icon2=%@"</span>, text2, name2, icon2);</span><br><span class="line"><span class="comment">// text2=今天天气真不错！, name2=Rose, icon2=nami.png</span></span><br></pre></td></tr></table></figure><h5 id="核心代码2"><a href="#核心代码2" class="headerlink" title="核心代码2"></a>核心代码2</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Status objectWithKeyValues:dict]`</span><br></pre></td></tr></table></figure><h4 id="3-模型中有个数组属性，数组里面又要装着其它模型"><a href="#3-模型中有个数组属性，数组里面又要装着其它模型" class="headerlink" title="3. 模型中有个数组属性，数组里面又要装着其它模型"></a>3. 模型中有个数组属性，数组里面又要装着其它模型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Ad</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *url;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">StatusResult</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/** 存放着一堆的微博数据（里面都是Status模型） */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span> *statuses;</span><br><span class="line"><span class="comment">/** 存放着一堆的广告数据（里面都是Ad模型） */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> *ads;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSNumber</span> *totalNumber;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">StatusResult</span></span></span><br><span class="line"><span class="comment">// 实现这个方法的目的：告诉MJExtension框架statuses和ads数组里面装的是什么模型</span></span><br><span class="line"><span class="comment">/*    + (NSDictionary *)objectClassInArray&#123;    </span></span><br><span class="line"><span class="comment">return @&#123;         </span></span><br><span class="line"><span class="comment">@"statuses" : [Status class],         </span></span><br><span class="line"><span class="comment">@"ads" : [Ad class]    &#125;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">+ (Class)objectClassInArray:(NSString *)propertyName&#123;    </span></span><br><span class="line"><span class="comment">if ([propertyName isEqualToString:@"statuses"]) &#123;        </span></span><br><span class="line"><span class="comment">return [Status class];    </span></span><br><span class="line"><span class="comment">&#125; else if ([propertyName isEqualToString:@"ads"]) &#123;        </span></span><br><span class="line"><span class="comment">return [Ad class];    &#125;    </span></span><br><span class="line"><span class="comment">return nil;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法对比上面的2个方法更加没有侵入性和污染，因为不需要导入Status和Ad的头文件</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)objectClassInArray&#123;    </span><br><span class="line">    <span class="keyword">return</span> @&#123;         </span><br><span class="line">              <span class="string">@"statuses"</span> : <span class="string">@"Status"</span>,         </span><br><span class="line">              <span class="string">@"ads"</span> : <span class="string">@"Ad"</span>    </span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;                       </span><br><span class="line"><span class="string">@"statuses"</span> : @[                           </span><br><span class="line">                @&#123;                                   </span><br><span class="line">                   <span class="string">@"text"</span> : <span class="string">@"今天天气真不错！"</span>,</span><br><span class="line">                   <span class="string">@"user"</span> : @&#123;                                   </span><br><span class="line">                                <span class="string">@"name"</span> : <span class="string">@"Rose"</span>,</span><br><span class="line">                                <span class="string">@"icon"</span> : <span class="string">@"nami.png"</span>                                                                                  </span><br><span class="line">                              &#125;                            </span><br><span class="line">                 &#125;, </span><br><span class="line"></span><br><span class="line">                 @&#123;                               </span><br><span class="line">                    <span class="string">@"text"</span> : <span class="string">@"明天去旅游了"</span>, </span><br><span class="line">                    <span class="string">@"user"</span> : @&#123;                                                                   </span><br><span class="line">                                 <span class="string">@"name"</span> : <span class="string">@"Jack"</span>,                                       </span><br><span class="line">                                 <span class="string">@"icon"</span> : <span class="string">@"lufy.png"</span>                               </span><br><span class="line">                               &#125;  </span><br><span class="line">                   &#125; </span><br><span class="line"></span><br><span class="line">                ],                       </span><br><span class="line"> <span class="string">@"ads"</span> :@[                           </span><br><span class="line">           @&#123;                               </span><br><span class="line">              <span class="string">@"image"</span> : <span class="string">@"ad01.png"</span>, </span><br><span class="line">              <span class="string">@"url"</span> : <span class="string">@"http://www.ad01.com"</span>                                                          </span><br><span class="line">            &#125;, </span><br><span class="line"></span><br><span class="line">           @&#123;                               </span><br><span class="line">              <span class="string">@"image"</span> : <span class="string">@"ad02.png"</span>,                                   </span><br><span class="line">              <span class="string">@"url"</span> : <span class="string">@"http://www.ad02.com"</span>                           </span><br><span class="line">            &#125;                       </span><br><span class="line">          ],                       </span><br><span class="line"> <span class="string">@"totalNumber"</span> : <span class="string">@"2014"</span>                    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将字典转为StatusResult模型</span></span><br><span class="line">         StatusResult *result = [StatusResult objectWithKeyValues:dict];</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"totalNumber=%@"</span>, result.totalNumber);</span><br><span class="line">         <span class="comment">// totalNumber=2014</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 打印statuses数组中的模型属性</span></span><br><span class="line">         <span class="keyword">for</span> (Status *status <span class="keyword">in</span> result.statuses) &#123;    </span><br><span class="line">                <span class="built_in">NSString</span> *text = status.text;    </span><br><span class="line">                <span class="built_in">NSString</span> *name = status.user.name;    <span class="built_in">NSString</span> *icon = status.user.icon;    </span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"text=%@, name=%@, icon=%@"</span>, text, name, icon);&#125;</span><br><span class="line">               <span class="comment">// text=今天天气真不错！, name=Rose, icon=nami.png</span></span><br><span class="line">               <span class="comment">// text=明天去旅游了, name=Jack, icon=lufy.png</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 打印ads数组中的模型属性</span></span><br><span class="line">         <span class="keyword">for</span> (Ad *ad <span class="keyword">in</span> result.ads) &#123;    </span><br><span class="line">                 <span class="built_in">NSLog</span>(<span class="string">@"image=%@, url=%@"</span>, ad.image, ad.url);&#125;</span><br><span class="line">                 <span class="comment">// image=ad01.png, url=http://www.ad01.com</span></span><br><span class="line">                 <span class="comment">// image=ad02.png, url=http://www.ad02.com</span></span><br></pre></td></tr></table></figure><h5 id="核心代码3："><a href="#核心代码3：" class="headerlink" title="核心代码3："></a>核心代码3：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在模型内部实现+ (<span class="built_in">NSDictionary</span> *)objectClassInArray方法</span><br><span class="line"></span><br><span class="line">[StatusResult objectWithKeyValues:dict]</span><br></pre></td></tr></table></figure><h4 id="4-模型中的属性名和字典中的key不相同-或者需要多级映射"><a href="#4-模型中的属性名和字典中的key不相同-或者需要多级映射" class="headerlink" title="4. 模型中的属性名和字典中的key不相同(或者需要多级映射)"></a>4. 模型中的属性名和字典中的key不相同(或者需要多级映射)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Bag</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="keyword">double</span> price;<span class="keyword">@end</span><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *ID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *desc;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *nowName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *oldName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *nameChangedTime;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) Bag *bag;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="comment">// 实现这个方法的目的：告诉MJExtension框架模型中的属性名对应着字典的哪个key</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)replacedKeyFromPropertyName&#123;    </span><br><span class="line">     <span class="keyword">return</span> @&#123;                </span><br><span class="line">               <span class="string">@"ID"</span> : <span class="string">@"id"</span>,                </span><br><span class="line">               <span class="string">@"desc"</span> : <span class="string">@"desciption"</span>,                </span><br><span class="line">               <span class="string">@"oldName"</span> : <span class="string">@"name.oldName"</span>, </span><br><span class="line">               <span class="string">@"nowName"</span> : <span class="string">@"name.newName"</span>,  </span><br><span class="line">               <span class="string">@"nameChangedTime"</span> : <span class="string">@"name.info.nameChangedTime"</span>,                                       </span><br><span class="line">               <span class="string">@"bag"</span> : <span class="string">@"other.bag"</span>            </span><br><span class="line">              &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;                       </span><br><span class="line">                        <span class="string">@"id"</span> : <span class="string">@"20"</span>,                       </span><br><span class="line">                        <span class="string">@"desciption"</span> : <span class="string">@"孩子"</span>,</span><br><span class="line">                        <span class="string">@"name"</span> : @&#123;                                                         </span><br><span class="line">                                     <span class="string">@"newName"</span> : <span class="string">@"lufy"</span>, </span><br><span class="line">                                     <span class="string">@"oldName"</span> : <span class="string">@"kitty"</span>,  </span><br><span class="line">                                     <span class="string">@"info"</span> : @&#123;                                                                                                   </span><br><span class="line">                                                  <span class="string">@"nameChangedTime"</span> : <span class="string">@"2013-08"</span>                            </span><br><span class="line">                                                 &#125;                       </span><br><span class="line">                                    &#125;,                       </span><br><span class="line">                        <span class="string">@"other"</span> : @&#123;                            </span><br><span class="line">                                      <span class="string">@"bag"</span> : @&#123;                                </span><br><span class="line">                                                  <span class="string">@"name"</span> : <span class="string">@"小书包"</span>, </span><br><span class="line">                                                  <span class="string">@"price"</span> : @<span class="number">100.7</span>                                                              </span><br><span class="line">                                                 &#125;                       </span><br><span class="line">                                     &#125;                   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典转为Student模型</span></span><br><span class="line">Student *stu = [Student objectWithKeyValues:dict];</span><br><span class="line"><span class="comment">// 打印Student模型的属性</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@"</span>, stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime);</span><br><span class="line"><span class="comment">// ID=20, desc=孩子, oldName=kitty, nowName=lufy, nameChangedTime=2013-08</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"bagName=%@, bagPrice=%f"</span>, stu.bag.name, stu.bag.price);</span><br><span class="line"><span class="comment">// bagName=小书包, bagPrice=100.700000</span></span><br></pre></td></tr></table></figure><h5 id="核心代码4："><a href="#核心代码4：" class="headerlink" title="核心代码4："></a>核心代码4：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在模型内部实现+ (<span class="built_in">NSDictionary</span> *)replacedKeyFromPropertyName方法</span><br><span class="line"></span><br><span class="line">[Student objectWithKeyValues:dict]</span><br></pre></td></tr></table></figure><h4 id="5-将一个字典数组转成模型数组"><a href="#5-将一个字典数组转成模型数组" class="headerlink" title="5. 将一个字典数组转成模型数组"></a>5. 将一个字典数组转成模型数组</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *dictArray = @[                       </span><br><span class="line">                        @&#123;                           </span><br><span class="line">                           <span class="string">@"name"</span> : <span class="string">@"Jack"</span>,                           </span><br><span class="line">                           <span class="string">@"icon"</span> : <span class="string">@"lufy.png"</span>,                        </span><br><span class="line">                         &#125;,                       </span><br><span class="line">                        @&#123;                           </span><br><span class="line">                           <span class="string">@"name"</span> : <span class="string">@"Rose"</span>,                           </span><br><span class="line">                           <span class="string">@"icon"</span> : <span class="string">@"nami.png"</span>,                        </span><br><span class="line">                         &#125;                    </span><br><span class="line">                       ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字典数组转为User模型数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *userArray = [User objectArrayWithKeyValuesArray:dictArray];</span><br><span class="line"><span class="comment">// 打印userArray数组中的User模型属性</span></span><br><span class="line"><span class="keyword">for</span> (User *user <span class="keyword">in</span> userArray) &#123;   </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"name=%@, icon=%@"</span>, user.name, user.icon);&#125;</span><br><span class="line">      <span class="comment">// name=Jack, icon=lufy.png</span></span><br><span class="line">      <span class="comment">// name=Rose, icon=nami.png</span></span><br></pre></td></tr></table></figure><h5 id="核心代码5："><a href="#核心代码5：" class="headerlink" title="核心代码5："></a>核心代码5：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[User objectArrayWithKeyValuesArray:dictArray]</span><br></pre></td></tr></table></figure><h4 id="6-将一个模型转成字典"><a href="#6-将一个模型转成字典" class="headerlink" title="6. 将一个模型转成字典"></a>6. 将一个模型转成字典</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建模型</span></span><br><span class="line">  User *user = [[User alloc] init];</span><br><span class="line">user.name = <span class="string">@"Jack"</span>;</span><br><span class="line">user.icon = <span class="string">@"lufy.png"</span>;</span><br><span class="line"></span><br><span class="line">Status *status = [[Status alloc] init];</span><br><span class="line">status.user = user;</span><br><span class="line">status.text = <span class="string">@"今天的心情不错！"</span>;</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将模型转为字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *statusDict = status.keyValues;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, statusDict);</span><br><span class="line"><span class="comment">/*&#123; text = "今天的心情不错！";    </span></span><br><span class="line"><span class="comment">    user = &#123;        </span></span><br><span class="line"><span class="comment">             icon = "lufy.png";        </span></span><br><span class="line"><span class="comment">             name = Jack;    </span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多级映射的模型</span></span><br><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line">stu.ID = <span class="string">@"123"</span>;</span><br><span class="line">stu.oldName = <span class="string">@"rose"</span>;</span><br><span class="line">stu.nowName = <span class="string">@"jack"</span>;</span><br><span class="line">stu.desc = <span class="string">@"handsome"</span>;</span><br><span class="line">stu.nameChangedTime = <span class="string">@"2018-09-08"</span>;</span><br><span class="line"></span><br><span class="line">Bag *bag = [[Bag alloc] init];</span><br><span class="line">bag.name = <span class="string">@"小书包"</span>;</span><br><span class="line">bag.price = <span class="number">205</span>;</span><br><span class="line">stu.bag = bag;</span><br><span class="line"><span class="built_in">NSDictionary</span> *stuDict = stu.keyValues;<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, stuDict);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;    desciption = handsome;    </span></span><br><span class="line"><span class="comment">       id = 123;    </span></span><br><span class="line"><span class="comment">       name = &#123;        </span></span><br><span class="line"><span class="comment">                info =&#123;            </span></span><br><span class="line"><span class="comment">                nameChangedTime = "2018-09-08";        </span></span><br><span class="line"><span class="comment">                       &#125;;        </span></span><br><span class="line"><span class="comment">                newName = jack;        </span></span><br><span class="line"><span class="comment">                oldName = rose;    </span></span><br><span class="line"><span class="comment">               &#125;;    </span></span><br><span class="line"><span class="comment">                other = &#123;  </span></span><br><span class="line"><span class="comment">                          bag =&#123;            </span></span><br><span class="line"><span class="comment">                                 name = "小书包";            </span></span><br><span class="line"><span class="comment">                                 price = 205;        </span></span><br><span class="line"><span class="comment">                               &#125;;    </span></span><br><span class="line"><span class="comment">                        &#125;; </span></span><br><span class="line"><span class="comment">               &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="核心代码6："><a href="#核心代码6：" class="headerlink" title="核心代码6："></a>核心代码6：</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status.keyValues、stu.keyValues</span><br></pre></td></tr></table></figure><h4 id="7-将一个模型数组转成字典数组"><a href="#7-将一个模型数组转成字典数组" class="headerlink" title="7. 将一个模型数组转成字典数组"></a>7. 将一个模型数组转成字典数组</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建模型数组</span></span><br><span class="line">  User *user1 = [[User alloc] init];</span><br><span class="line">user1.name = <span class="string">@"Jack"</span>;</span><br><span class="line">user1.icon = <span class="string">@"lufy.png"</span>;</span><br><span class="line"></span><br><span class="line">User *user2 = [[User alloc] init];</span><br><span class="line">user2.name = <span class="string">@"Rose"</span>;</span><br><span class="line">user2.icon = <span class="string">@"nami.png"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *userArray = @[user1, user2];</span><br><span class="line"><span class="comment">// 将模型数组转为字典数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *dictArray = [User keyValuesArrayWithObjectArray:userArray];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, dictArray);</span><br><span class="line"><span class="comment">/*(    </span></span><br><span class="line"><span class="comment">&#123;        icon = "lufy.png";        name = Jack;    &#125;,    </span></span><br><span class="line"><span class="comment">&#123;        icon = "nami.png";        name = Rose;    &#125;  )*/</span></span><br></pre></td></tr></table></figure><h6 id="核心代码7："><a href="#核心代码7：" class="headerlink" title="核心代码7："></a>核心代码7：</h6><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[User keyValuesArrayWithObjectArray:userArray]</span><br></pre></td></tr></table></figure><h4 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参考<span class="built_in">NSObject</span>+MJKeyValue.h</span><br><span class="line">参考<span class="built_in">NSObject</span>+MJCoding.h</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS UIScrollView的代理方法汇总</title>
      <link href="/2019-02-02-ios-uiscrollview-delegate-methods/"/>
      <url>/2019-02-02-ios-uiscrollview-delegate-methods/</url>
      
        <content type="html"><![CDATA[<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIScrollViewDelegate</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView; </span><br><span class="line"><span class="comment">// any offset changes 只要scrollView的content 这个方法在任何方式触发 contentOffset </span></span><br><span class="line"><span class="comment">// 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 contentOffset </span></span><br><span class="line"><span class="comment">// 的变化，并根据当前的 contentOffset 对其他 view 做出随动调整。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called on start of dragging (may require some time and or distance to move)</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView; </span><br><span class="line"><span class="comment">// 用户开始拖动 scroll view 的时候被调用，可能需要一些时间和距离移动之后才会触发。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// called on finger up if the user dragged. velocity is in points/millisecond. </span></span><br><span class="line"><span class="comment">// targetContentOffset may be changed to adjust where the scroll view comes to rest</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</span><br><span class="line"><span class="comment">// 在 didEndDragging 前被调用，当 willEndDragging 方法中 velocity 为 CGPointZero</span></span><br><span class="line"><span class="comment">//（结束拖动时两个方向都没有速度）时，didEndDragging 中的 decelerate 为 NO，即没有减速过程，</span></span><br><span class="line"><span class="comment">//willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，</span></span><br><span class="line"><span class="comment">// 当 velocity 不为 CGPointZero 时，scroll view 会以 velocity 为初速度，</span></span><br><span class="line"><span class="comment">// 减速直到 targetContentOffset。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate;</span><br><span class="line"><span class="comment">// 在用户结束拖动后被调用，decelerate 为 YES 时，</span></span><br><span class="line"><span class="comment">// 结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，</span></span><br><span class="line"><span class="comment">// scroll view 的 dragging 并不会立即置为 NO，而是要等到减速结束之后，</span></span><br><span class="line"><span class="comment">// 所以这个 dragging 属性的实际语义更接近 scrolling。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView;   <span class="comment">// 减速动画开始前被调用。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView;      </span><br><span class="line"><span class="comment">// 减速动画结束时被调用，这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，</span></span><br><span class="line"><span class="comment">// didEndDecelerating 不会被调用，并且这时 scroll view 的 dragging 和 decelerating 属性都是 YES。</span></span><br><span class="line"><span class="comment">// 新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；</span></span><br><span class="line"><span class="comment">// 如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用      </span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView; </span><br><span class="line"><span class="comment">// called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidZoom:(<span class="built_in">UIScrollView</span> *)scrollView <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2); </span><br><span class="line"><span class="comment">// any zoom scale changes view缩放改变的时候调用。</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)viewForZoomingInScrollView:(<span class="built_in">UIScrollView</span> *)scrollView;     </span><br><span class="line"><span class="comment">// return a view that will be scaled. if delegate returns nil, nothing happens</span></span><br><span class="line">告诉代理要缩放那个控件。 </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginZooming:(<span class="built_in">UIScrollView</span> *)scrollView withView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2); </span><br><span class="line"><span class="comment">// called before the scroll view begins zooming its content缩放开始的时候调用</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndZooming:(<span class="built_in">UIScrollView</span> *)scrollView withView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view atScale:(<span class="built_in">CGFloat</span>)scale; </span><br><span class="line"><span class="comment">// scale between minimum and maximum. called after any 'bounce' animations缩放完毕的时候调用。</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)scrollViewShouldScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView;   <span class="comment">// return a yes if you want to scroll to the top. if not defined, assumes YES- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView;      </span></span><br><span class="line"><span class="comment">// called when scrolling animation finished. may be called immediately if already at top滚动动画完成时调用。</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS UILabel的lineBreakMode省略模式设置</title>
      <link href="/2019-02-01-ios-uilabel-linebreakmode-setting/"/>
      <url>/2019-02-01-ios-uilabel-linebreakmode-setting/</url>
      
        <content type="html"><![CDATA[<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByCharWrapping</span>; <span class="comment">//以字符为显示单位显示，后面部分省略不显示。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByClipping</span>; <span class="comment">//剪切与文本宽度相同的内容长度，后半部分被删除。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByTruncatingHead</span>; <span class="comment">//前面部分文字以……方式省略，显示尾部文字内容。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByTruncatingMiddle</span>; <span class="comment">//中间的内容以……方式省略，显示头尾的文字内容。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByTruncatingTail</span>; <span class="comment">//结尾部分的内容以……方式省略，显示头的文字内容。</span></span><br><span class="line">label.lineBreakMode = <span class="built_in">NSLineBreakByWordWrapping</span>; <span class="comment">//以单词为显示单位显示，后面部分省略不显示。</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS修改UIImage图片尺寸大小逻辑分辨率</title>
      <link href="/2019-02-01-ios-uiimage-resize/"/>
      <url>/2019-02-01-ios-uiimage-resize/</url>
      
        <content type="html"><![CDATA[<p>之前遇到的问题，给UITabbar item设置图片，然而素材的图片分辨率是87*87，填满了整个tabbar item的区域，很难看，又要考虑适配XS Max的三倍问题。 解决方法如下： 通过设置scale使生成的图片尺寸是逻辑分辨率pt单位，不用操心二倍三倍的问题。</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)imageResize:(<span class="built_in">UIImage</span>*)img andResizeTo:(<span class="built_in">CGSize</span>)newSize &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = [[<span class="built_in">UIScreen</span> mainScreen]scale];</span><br><span class="line">    <span class="comment">//UIGraphicsBeginImageContext(newSize);</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(newSize, <span class="literal">NO</span>, scale);</span><br><span class="line">    [img drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>,newSize.width,newSize.height)];</span><br><span class="line">    <span class="built_in">UIImage</span>* newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来就能使tabbar item的图标始终是25pt*25pt，恰到好处。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">childController.tabBarItem.selectedImage = [[SmallTools imageResize:[<span class="built_in">UIImage</span> imageNamed:selected] andResizeTo:<span class="built_in">CGSizeMake</span>(<span class="number">25</span>, <span class="number">25</span>)] imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysOriginal</span>];</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1549072293345_888x213.gif" alt></p><h3 id="另外关于上图中间图标的动画效果实现可参考此文章"><a href="#另外关于上图中间图标的动画效果实现可参考此文章" class="headerlink" title="另外关于上图中间图标的动画效果实现可参考此文章"></a>另外关于上图中间图标的动画效果实现可参考此文章</h3><p><a href="http://paaatrick.com/ios_uitabbar_touch_animation.html" title="iOS UITabbar图标点击动画效果实现">iOS UITabbar图标点击动画效果实现</a>      </p><hr>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS UITabbar图标点击动画效果实现</title>
      <link href="/2019-02-01-ios-uitabbar-touch-animation/"/>
      <url>/2019-02-01-ios-uitabbar-touch-animation/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正常情况下，我们点击tabbar都只有一个变色效果，但有时候，如果我们想给它添加一个点击动画，该如何做呢？ 以下是两种方法： </p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>通过<code>tabBar: didSelectItem:</code>代理方法接收每次点击的item，对每个item都绑定动画效果，弊端是获取到的是整个item，图标和标题都会一起动。 </p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>是自定一个方法单独获取tabbar item的image和label，可自定只对某个item绑定动画，并且可设定单独image的动画。 </p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><blockquote><p>第二种方法：只对image执行动画 </p></blockquote><p>1、带重力效果的弹跳</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1549072293345_888x213.gif" alt></p><a id="more"></a><blockquote><p>后4个是第一种方法</p></blockquote><p>2、先放大，再缩小 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116103844396-1872210226.gif" alt></p><p>3、Z轴旋转 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116103932614-876709799.gif" alt></p><p>4、Y轴位移 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116104000302-95725194.gif" alt></p><p>5、放大并保持 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116104036224-920525159.gif" alt></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="获取要执行动画的Item"><a href="#获取要执行动画的Item" class="headerlink" title="获取要执行动画的Item"></a>获取要执行动画的Item</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MainTabbarVC</span> ()&lt;<span class="title">UITabBarControllerDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">NSInteger</span>  indexFlag;　　<span class="comment">//记录上一次点击tabbar，使用时，记得先在init或viewDidLoad里 初始化 = 0</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方法：通过接收点击事件对每个tabbar item的点击都执行动画</span></span><br><span class="line">-(<span class="keyword">void</span>)tabBar:(<span class="built_in">UITabBar</span> *)tabBar didSelectItem:(<span class="built_in">UITabBarItem</span> *)item&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> index = [<span class="keyword">self</span>.tabBar.items indexOfObject:item];</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="keyword">self</span>.indexFlag) &#123;</span><br><span class="line">        <span class="comment">//执行动画</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arry = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *btn <span class="keyword">in</span> <span class="keyword">self</span>.tabBar.subviews) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([btn isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"UITabBarButton"</span>)]) &#123;</span><br><span class="line">                 [arry addObject:btn];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加动画</span></span><br><span class="line">　　　　 <span class="comment">//---将下面的动画代码块拷贝到此并修改最后一行addAnimation的layer对象即可---</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.indexFlag = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法：只想对某一个item的点击执行动画，且只有图片动，文字不动。并且其余图标的点击不带动画</span></span><br><span class="line">- (<span class="keyword">void</span>)tabBarImageAnimation &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIControl</span> *tabBarButton <span class="keyword">in</span> <span class="keyword">self</span>.tabBar.subviews) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([tabBarButton isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"UITabBarButton"</span>)]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">UIControl</span> *tabBarButtonLabel <span class="keyword">in</span> tabBarButton.subviews) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([tabBarButtonLabel isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"UITabBarButtonLabel"</span>)]) &#123;</span><br><span class="line">                    <span class="built_in">UILabel</span> *label = (<span class="built_in">UILabel</span> *)tabBarButtonLabel;</span><br><span class="line">                    <span class="comment">//"tab1"到"tab4"分别是不打算执行动画的tabbar item的标题名称</span></span><br><span class="line">                    <span class="keyword">if</span> (![label.text isEqualToString:<span class="string">@"tab1"</span>] &amp;&amp; ![label.text isEqualToString:<span class="string">@"tab2"</span>] &amp;&amp; ![label.text isEqualToString:<span class="string">@"tab3"</span>] &amp;&amp; ![label.text isEqualToString:<span class="string">@"tab4"</span>]) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">UIView</span> *imageView <span class="keyword">in</span> tabBarButton.subviews) &#123;</span><br><span class="line">                            <span class="keyword">if</span> ([imageView isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"UITabBarSwappableImageView"</span>)]) &#123;</span><br><span class="line">                                <span class="comment">//添加动画</span></span><br><span class="line">                                <span class="comment">//---将下面的动画代码块拷贝到此并修改最后一行addAnimation的layer对象即可---</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法的用法比较灵活，比如可以在TabbarVC里设上面<code>tabBarImageAnimation</code>方法的通知Observer，在需要执行动画的地方比如打开某VC时在该VC的<code>viewDidAppear</code>里post通知即可。</p></blockquote><h3 id="动画代码"><a href="#动画代码" class="headerlink" title="动画代码"></a>动画代码</h3><p>1、带重力效果的弹跳</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CAKeyframeAnimation</span> *animation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"transform.translation.y"</span>];</span><br><span class="line"><span class="comment">//通过初中物理重力公式计算出的位移y值数组</span></span><br><span class="line">animation.values = @[@<span class="number">0.0</span>, @<span class="number">-4.15</span>, @<span class="number">-7.26</span>, @<span class="number">-9.34</span>, @<span class="number">-10.37</span>, @<span class="number">-9.34</span>, @<span class="number">-7.26</span>, @<span class="number">-4.15</span>, @<span class="number">0.0</span>, @<span class="number">2.0</span>, @<span class="number">-2.9</span>, @<span class="number">-4.94</span>, @<span class="number">-6.11</span>, @<span class="number">-6.42</span>, @<span class="number">-5.86</span>, @<span class="number">-4.44</span>, @<span class="number">-2.16</span>, @<span class="number">0.0</span>];</span><br><span class="line">animation.duration = <span class="number">0.8</span>;</span><br><span class="line">animation.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">1</span>;</span><br><span class="line">[imageView.layer addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>2、先放大，再缩小</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放大效果，并回到原位</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line"><span class="comment">//速度控制函数，控制动画运行的节奏</span></span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.duration = <span class="number">0.2</span>;       <span class="comment">//执行时间</span></span><br><span class="line">animation.repeatCount = <span class="number">1</span>;      <span class="comment">//执行次数</span></span><br><span class="line">animation.autoreverses = <span class="literal">YES</span>;    <span class="comment">//完成动画后会回到执行动画之前的状态</span></span><br><span class="line">animation.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0.7</span>];   <span class="comment">//初始伸缩倍数</span></span><br><span class="line">animation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.3</span>];     <span class="comment">//结束伸缩倍数</span></span><br><span class="line">[[arry[index] layer] addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>3、Z轴旋转</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//z轴旋转180度</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line"><span class="comment">//速度控制函数，控制动画运行的节奏</span></span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.duration = <span class="number">0.2</span>;       <span class="comment">//执行时间</span></span><br><span class="line">animation.repeatCount = <span class="number">1</span>;      <span class="comment">//执行次数</span></span><br><span class="line">animation.removedOnCompletion = <span class="literal">YES</span>;</span><br><span class="line">animation.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0</span>];   <span class="comment">//初始伸缩倍数</span></span><br><span class="line">animation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:M_PI];     <span class="comment">//结束伸缩倍数</span></span><br><span class="line">[[arry[index] layer] addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>4、Y轴位移</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向上移动</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.translation.y"</span>];</span><br><span class="line"><span class="comment">//速度控制函数，控制动画运行的节奏</span></span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.duration = <span class="number">0.2</span>;       <span class="comment">//执行时间</span></span><br><span class="line">animation.repeatCount = <span class="number">1</span>;      <span class="comment">//执行次数</span></span><br><span class="line">animation.removedOnCompletion = <span class="literal">YES</span>;</span><br><span class="line">animation.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">0</span>];   <span class="comment">//初始伸缩倍数</span></span><br><span class="line">animation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">-10</span>];     <span class="comment">//结束伸缩倍数</span></span><br><span class="line">[[arry[index] layer] addAnimation:animation forKey:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>5、放大并保持</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放大效果</span></span><br><span class="line"><span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line"><span class="comment">//速度控制函数，控制动画运行的节奏</span></span><br><span class="line">animation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.duration = <span class="number">0.2</span>;       <span class="comment">//执行时间</span></span><br><span class="line">animation.repeatCount = <span class="number">1</span>;      <span class="comment">//执行次数</span></span><br><span class="line">animation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">animation.fillMode = kCAFillModeForwards;           <span class="comment">//保证动画效果延续</span></span><br><span class="line">animation.fromValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.0</span>];   <span class="comment">//初始伸缩倍数</span></span><br><span class="line">animation.toValue = [<span class="built_in">NSNumber</span> numberWithFloat:<span class="number">1.15</span>];     <span class="comment">//结束伸缩倍数</span></span><br><span class="line">[[arry[index] layer] addAnimation:animation forKey:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//移除其他tabbar的动画</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arry.count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != index) &#123;</span><br><span class="line">        [[arry[i] layer] removeAllAnimations];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，如果想定制其他动画效果，还可以从下面属性里自己定制动画 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/511196-20170116093610724-1578979553.png" alt></p><hr>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比咪蒙更可怕的，是挖祖坟式举报清算</title>
      <link href="/2019-02-01-raistlin2017/"/>
      <url>/2019-02-01-raistlin2017/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文始发于微信公众号（为你写一个故事）：<a href="http://mp.weixin.qq.com/s/Xb4bgA_2ylXRwQO4isgJqg" target="_blank" rel="noopener">比咪蒙更可怕的，是挖祖坟式举报清算</a></p></blockquote><p>因为旗下账号“才华有限青年”一篇自称“非虚构“的文章，咪蒙又被推上风口浪尖。  </p><a id="more"></a><p>就事论事的说，才华有限青年其实和咪蒙关系不大，那确实是个相对独立的团队，我也读过他们以前很多文章，很多都挺好看，要说有什么错，最多是有点煽动情绪。  </p><p>但是做媒体嘛，又有几个不煽动情绪呢，只要不造谣，不引导邪恶的价值观，就没啥问题。  </p><p>所以我觉得一个好的方式是，你不同意她的一篇文章，就说这篇文章写得不好写得不对，甚至可以说这篇文章写得用心险恶。  </p><p>但你去挖她的出身，说她以前是咪蒙的实习生，所以一定不是什么好人。  </p><p>就有点恶毒了。  </p><p>比如有一位我挺喜欢的媒体人，这样写，我就觉得恶毒了  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/4-1548951367.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>（而且如果真的翻了照片的话，较真的说这句话是造谣）  </p><p>还有昨天整个朋友圈轰轰烈烈的”含咪量“测试，很多人号称朋友圈只要有人关注咪蒙了，就要和TA互删。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951367.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/9-1548951368.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"><br>这我也觉得太过。<br>按照他们的意思，也别管这人是谁，和他们是什么关系，是不是好朋友或者亲戚，也不管这个人关注咪蒙究竟是认同咪蒙的价值观还是就想围观一下或者学习排版，只要关注咪蒙，就要互删。<br>这放在几十年前，我们叫做”划清界限“，流行这种运动的十年，是新中国最混乱的十年。<br>当然我觉得更过的，还是下面这张截图。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951370.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>咪蒙一边说这话，一边”永远爱国，永远热泪盈眶“恶不恶心？<br>恶心。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951372.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"><br>咪蒙式毒鸡汤讨不讨厌？  </p><p>我也讨厌。<br>但这样挖祖坟式清算举报，尤其是一直翻到2013年的微博，然后把相关机构全都@一遍的行为，让我感到很不舒服。<br>这种不舒服不是反感，而是感到恐怖。<br>而且这样的事情，这些年越来越多了。<br>这样的待遇，陈一发遭遇过：  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/9-1548951373.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>罗永浩遭遇过：  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/0-1548951373.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>毕福剑也遭遇过：  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/4-1548951374.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>普通网友当然也遭遇过：  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/8-1548951375.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>动不动就呼吁封杀，虎扑和吴亦凡粉丝战斗时，双方都遭遇过。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/3-1548951377.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/4-1548951379.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>游戏《阴阳师》遭遇过：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/8-1548951380.jpg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>明星骂战的时候使用过这种武器。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/10-1548951381.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>社会热点事件就不说了，总是有成千上万人向团团举报。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951383.jpg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>现在甚至王者荣耀玩得不爽了，也要举报。  </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/3-1548951383.jpg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>在这些举报里，网友们用不知道从哪里学到的词汇，给自己看着不爽的人扣上一个又一个大帽子，套上一个又一个罪名，其手法之纯熟，让我一度以为生活在冯骥才的《一百个人的十年》里。</p><p>可惜拿起手机瞧一瞧，发现已经是2019年了。</p><p>在我看来这种行为和看到让自己不爽的综艺，歌曲，电影就呼吁封杀是一样的，都是分不清各种权利界限的表现。就像几百年前，被人欺负了，就去衙门一跪，高喊“大人，我冤啊！”，然后期待青天大老爷给自己做主的古代中国人一样，始终没有长大。</p><p>他们自己是巨婴，却以为我国居民全都是长不大的巨婴，需要妈妈无微不至地照顾我们，帮我们挑好哪些是我们该看的，哪些是我们不该看的，然后只要他们看到自己不爽的，就会像孩子一样哭喊着叫妈妈来，希望妈妈把“坏东西”都打飞，然后才会重新喜笑颜开。</p><p>可惜现代法制社会没有，也不应该有青天大老爷——历史早已经证明了，青天大老爷式的人治，远不如法治来得公平高效，青天大老爷十年一遇，但手握权力，肆意滥用的昏官却遍地都是。  </p><p>这已经很魔幻了。</p><p>但更魔幻的是，这些诉求，有时候还真的会得到回应。</p><p>以前我觉得孩子长不大，站不起来，是因为孩子自己笨，不想长大，后来才明白，孩子长不大，多半是有一个什么都替孩子做主，什么都替孩子决定的妈——在这些挖坟举报真的会得到回应的情况下，这样的行为永远不会停止，只会变本加厉。</p><p>即使如此，我还是希望你们能少挖坟，少呼吁封杀。</p><p>因为“封杀”这个词代表的那个行为，本来就不应该存在于这个世界上，并且当你习惯”封杀“之后，迟早有一天，会降临到你喜欢的那个账号，那个主播或者那个明星身上。</p><p>还记得之前整治八卦的时候吗？  </p><p>一开始封的很多账号，大家都讨厌，所以一片叫好声。结果之后发展到只要账号中带”八卦“两个字的，都被封号了，包括大家爱看的”毒舌电影“，”严肃八卦“，”金融八卦女“也全部都凉了。</p><p>最搞笑的是，我有个朋友，做了个账号叫”财经八卦阵“，那段时间只能改成”财经九卦阵“，终于躲过一劫。</p><p>还记得之前讨厌PGONE的人拼命举报PGONE，@了一大堆官方账号，要求对PGONE进行封杀吗？</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/4-1548951384.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/3-1548951385.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/0-1548951385.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951386.png" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>那会儿恰好GAI求婚成功，所以当时这些人中，有不少都人是通过捧GAI来踩PGONE的。</p><p>我自己也是GAI的粉丝，在一个GAI的粉丝群里，有几个姐们表示太好了，解气。但随即更多人表示这不是好事，因为GAI也有黑历史。</p><p>果然过了没多久，GAI被迫从《歌手》中退赛，至今也没在电视上再看过他。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/0-1548951386.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>在这样轰轰烈烈的挖坟式举报运动中，暴走漫画凉了，陈一发凉了，卢本伟凉了，毕福剑凉了，很多歌手明星都凉了。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/0-1548951387.jpg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p><strong>PGONE被封杀你们叫好，GAI被封杀你们喊冤，毕福剑从央视消失你们想念他。你们以为这几件事不一样应该分开，但经历过这么多事情，你们应该明白，这两件事其实根本就是一件事。</strong>  </p><p>封杀的人不会管哪个嘻哈歌手是正能量的，哪个是屡教不改的——既然嘻哈有问题，那就有问题的一起下。</p><p>就像现在这些为咪蒙的倒台拍手叫好的自媒体人，你又知道封杀的人分得清你和咪蒙的区别咯？</p><p>况且在我看来，很多账号根本就和咪蒙没区别。</p><p>比如某个自媒体，洋洋洒洒写了几千字，细数咪蒙的”七宗罪“。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/8-1548951388.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>最后得出的结论是，咪蒙最大的罪就是她在迎合读者，并且标题低俗，危害极大。他把文章发到500人的新媒体群里，希望大家为他鼓掌叫好。</p><p>结果翻开他自己的公众号，标题却是这个画风的。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/1-1548951390.jpeg" alt="比咪蒙更可怕的，是挖祖坟式举报清算"></p><p>当有人在群里质问他，这是不是在迎合读者，标题低俗，危害极大的时候，他很坦诚的承认”可我的没人看啊。“</p><p>让人心慌。</p><p>一个事实是，我们说的法制说的正义，从来不是给我们喜欢的东西准备的，我们喜欢的东西，根本不需要心中的那杆称来保护。  </p><p>我们说的正义和法制，是你们讨厌的人，也有说话的权利，如果他们没有违法，就不应该不让他们说话。</p><p>还有一个事实是，咪蒙的价值观确实有问题，也许能煽动几十万人的情绪，是会让人焦虑，但真要说她改变了多少人三观，我觉得各位是高看文字的力量了。</p><p>一方面咪蒙并不产生三观，她一般只迎合大众情绪，另一方面三观这东西是没那么容易改变的，2019年了，文字早就没那么大力量了，现在如果说谁因为一篇文章三观就变了，那说明TA本来就有这样的想法，只是这篇文章正好支持了TA而已。</p><p>比起咪蒙，我更害怕那样因为讨厌一个人，就肆无忌惮地爆粗口，就想着要弄死对方，更害怕那样挖祖坟式的举报。</p><p>因为这让我觉得自己每时每刻都活在监视中，终日不得安宁。</p><p>现在你们觉得应该这样对付咪蒙，谁知道哪天我会不会受到这样的待遇。</p><p>而且说一千道一万，当年咪蒙写那几篇文章，疯狂在朋友圈转发刷屏，把咪蒙一度捧成微信第一大号的，还不是网友吗？</p><p>看到某个去年还把咪蒙请为座上宾，一口一个咪蒙老师做分享的机构，昨天他们主编也开始测含咪率了，可能下一步就要表态”互删“了。</p><p>看到之前分享过致贱人几篇的人，开始在朋友圈说”想不通为什么这么多人会关注咪蒙“了。</p><p>有时候见多了这种昨天还万人追捧，今天就过街老鼠的戏码。真是让人对这个复杂繁复的世界，又害怕了几分呢。</p><p>-END-</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>亲测真正好用的WordPress媒体库图片分类插件</title>
      <link href="/2019-01-31-wp-real-media-library/"/>
      <url>/2019-01-31-wp-real-media-library/</url>
      
        <content type="html"><![CDATA[<p>WordPress有个很大的问题就是管理上传图片的媒体库很菜，连最基本的文件夹分类功能都没有。 网上找了好一会儿，最开始找到一个 Attachment Taxonomies 看介绍好像还可以</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-18.12.21.png" alt></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-18.12.51.png" alt></p><p>然而实际使用起来极不方便，上传图片时不能选择上传到哪个分类，现有的图片也不能多选设置分类，需要点开每一张图片再勾选分类。 然后找到一个 WP Real Media Library 度娘盘找到了资源，下载后在WordPress插件界面上传使用。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-18.01.56.png" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-18.13.26.png" alt></p><p>使用起来非常顺手。</p><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a><a href="http://www.4mudi.com/themes/wp-real-media-library/#toggle-id-2" title="下载链接" target="_blank" rel="noopener">下载链接</a></h3><h3 id="V4-0-10-度盘链接"><a href="#V4-0-10-度盘链接" class="headerlink" title="V4.0.10 度盘链接"></a><a href="https://pan.baidu.com/s/1W5AYA0jVPFWZwZMmHMYd4w" title="V4.0.10 度盘链接" target="_blank" rel="noopener">V4.0.10 度盘链接</a></h3>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器使用WordPress搭建个人博客并绑定域名全记录</title>
      <link href="/2019-01-29-build-wordpress-blog/"/>
      <url>/2019-01-29-build-wordpress-blog/</url>
      
        <content type="html"><![CDATA[<p>一直在续费云服务器，索性充分利用资源，复古一下，鼓捣个小博客记录些东西。 现在大致已经搭好博客了，那就先把这折腾了一整天的建站过程给记录下。</p><h3 id="关于服务器"><a href="#关于服务器" class="headerlink" title="关于服务器"></a><strong>关于服务器</strong></h3><p>前几年购入的Vultr的ECS，东京的相对性价比高一些，延迟和网速都很稳，现在（2019.1）还有3.5刀一个月的，非常实惠。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-18.26.19.png" alt> </p><a id="more"></a><h4 id="安装-Apache2、MySQL、PHP"><a href="#安装-Apache2、MySQL、PHP" class="headerlink" title="安装 Apache2、MySQL、PHP"></a><strong>安装 Apache2、MySQL、PHP</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure><p>测试一下Apache2是否成功安装：浏览器访问云服务器的IP，安装成功的话会显示Apache2的默认页面，It works。   安装php7.0，并安装apache的php扩展，再安装整合mysql和php的工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.0</span><br><span class="line">sudo apt-get install libapache2-mod-php7.0</span><br><span class="line">sudo apt-get install php7.0-mysql</span><br></pre></td></tr></table></figure><p>重启一下Apache2和MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><p>安装 phpmyadmin 这是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install phpmyadmin</span><br></pre></td></tr></table></figure><p>开启 apache 的 mod_rewrite，再重启一次apache</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod rewrite</span><br><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure><p>先登录mysql <code>mysql -u root -p</code> ，输入密码 首先创建名为“wordpressdb”数据库，然后查看创建的数据库是否成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database wordpressdb;</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>看到图中出现自己创建的数据库。</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180318165221370.png" alt>  </p><p>给用户服务权限，下面的wordpressuser改为安装mysql时自己输入的用户名。</p><p>GRANT ALL PRIVILEGES ON wordpressdb.* TO wordpressuser@localhost;<br>FLUSH PRIVILEGES;</p><p>  输入 <code>exit;</code>退出mysql，并再次重启服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><h4 id="下载并配置WordPress"><a href="#下载并配置WordPress" class="headerlink" title="下载并配置WordPress"></a><strong>下载并配置WordPress</strong></h4><p>用wget从WordPress官方网站下载安装包，放在 /var/www/html/ 目录，然后解压。 （最新版下载链接在 <a href="https://cn.wordpress.org/download/" target="_blank" rel="noopener">https://cn.wordpress.org/download/</a> 里面有）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html/</span><br><span class="line">sudo wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.zip</span><br><span class="line">sudo tar zxf wordpress-4.9.4.tar.gz</span><br></pre></td></tr></table></figure><p>  在 /var/www/html/wordpress/wp-content/ 下创建uploads。 然后更改上传目录权限，不然之后博客上传不了图片。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir uploads</span><br><span class="line">sudo chown -R www-data /var/www/html/wordpress</span><br><span class="line">sudo chmod -R 755 /var/www/html/wordpress</span><br><span class="line">sudo chown -R :www-data /var/www/html/wordpress/wp-content/uploads</span><br></pre></td></tr></table></figure><p>  配置wp-config-sample.php ，该文件在/var/www/html/wordpress/下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi wp-config-sample.php</span><br></pre></td></tr></table></figure><p>修改方法如下图所示：</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180318182134757.png" alt></p><p>浏览器访问  http://服务器IP地址/wordpress ，如果安装正常则进入wordpress的安装界面。 安装好后的效果如图： </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180318182550961.png" alt></p><p>到此建站完成。接下来申请域名并绑定服务器。</p><h3 id="申请域名并配置DNS"><a href="#申请域名并配置DNS" class="headerlink" title="申请域名并配置DNS"></a><strong>申请域名并配置DNS</strong></h3><p>通过比价网站可以先大致看一下想要的域名价格 <a href="https://www.domcomp.com/" target="_blank" rel="noopener">https://www.domcomp.com/</a></p><p>看了一下知乎，大家推荐的域名供应商有 NameSilo 、Namecheap、Porkbun、GoDaddy等，亲测了一遍，发现 NameSilo 用户界面太丑；Namecheap 实际并不 cheap；最多人说的 GoDaddy 也偏贵但是支持支付宝，Porkbun 性价比高而且界面友好。 因为有境外支付的信用卡就不考虑 GoDaddy 了，直接在 Porkbun 上下单了一个 .com 域名，首年不到 7刀，续费 8.7刀。 </p><p>值得一提的是支付时好几张卡支付失败，建行、农行都不行，换了广发的万事达才支付成功，有点迷。 付款后主页可以看到自己域名的各种详情，然后要设置的是 DNS RECORDS </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.48.31.png" alt></p><p>点击Edit，添加两个A记录，分别是带www和不带的域名，ANSWER填自己的主机地址。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.50.38.png" alt></p><p>两个NS填DNS提供商的，这里因为Vultr自带了免费的DNS服务，直接填上去即可，具体的DNS地址可在Vultr的设置页里找。 下图就是设置页，可以看到底下有两条DNS地址，填到 Porkbun 里，然后还要在 Vultr 里 Add Domain，绑定服务器到域名。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.52.20.png" alt></p><p>两边都操作完成后，静候几分钟，然后访问一下自己的域名，应该就出来了。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a><strong>常见问题</strong></h3><h4 id="在仪表盘的设置中不小心更改了wordpress地址后回不到后台"><a href="#在仪表盘的设置中不小心更改了wordpress地址后回不到后台" class="headerlink" title="在仪表盘的设置中不小心更改了wordpress地址后回不到后台"></a><strong>在仪表盘的设置中不小心更改了wordpress地址后回不到后台</strong></h4><p>在建站过程中，如果改动了 wordpress地址或站点地址，就回不到后台了。 </p><p>解决方法：网站首页在wordpress目录下的index.php中的require这行的内容。 </p><p>下图是wordpress下index.php的require所在行的内容。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180319090603947.png" alt></p><p>最开始wordpress url是： 主机ip/wordpress。 它会自动去找index.php，然后就通过index.php里面的内容加载wordpress环境，更改了url后，就不能自动去找index.php了。此时后台也无法登录。解决这个问题，直接进数据库修改相关数据即可。操作如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p //然后输入密码</span><br><span class="line">show databases; //显示所有数据库</span><br><span class="line">use wordpressdb; //选中你自己网站对应的数据库。</span><br><span class="line">show tables; //显示该数据库所有表格。</span><br><span class="line">select * from wp_options where 1=1 limit 10; //查看数据库前10条记录</span><br><span class="line">update wp\_options set option\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;siteurl&apos;;//（如果home也改了就也改回来）</span><br><span class="line">update wp\_options set option\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;home&apos;;</span><br></pre></td></tr></table></figure><p>其实就是改变了wordpress url ，则wp_options表中的siteurl的值变化了，只要把它在修改过来就行。</p><h4 id="使用服务器IP（或域名）根地址直接访问网站首页"><a href="#使用服务器IP（或域名）根地址直接访问网站首页" class="headerlink" title="使用服务器IP（或域名）根地址直接访问网站首页"></a><strong>使用服务器IP（或域名）根地址直接访问网站首页</strong></h4><p>此文章的建站方法是把所有东西都放在wordpress目录下，因此建完后，访问网站的网址为：主机IP/wordpresss。</p><p>通常情况下，我们会买一个域名与云主机IP绑定，输入IP地址只能访问根目录。 即/var/www/html，但是无法访问其下面的子目录。</p><p>以下将给出解决方案。如果使主机IP直接定位到网站首页。</p><p>第一种解决方式是把wordpress的内容直接都弄到根目录中，这是不提倡的，会使根目录变得杂乱。通常推荐第二种方案。   </p><p>第二种方案操作如下： 登录后台，打开 设置→常规，修改站点地址。 </p><p>WordPress地址是本体存放的地址，按本文安装的话就不用改动了。 站点地址是浏览器访问的地址，改为 “http://服务器IP（或域名）” 的形式，如下图即可。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-31-15.26.26.png" alt></p><p>同时，打开 设置→固定链接，把固定链接修改成如下形式：（去掉中间的/wordpress/） </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.14.42.png" alt></p><p>至于文章后缀名，网上有关WordPress永久链接设置的介绍众多，普遍认为 <code>/%postname%.html</code> 是最佳的自定义永久链接形式。</p><p>这种形式将显示为:http://你的域名/日志标题.html，简单明了，有利于SEO。但当你的日志标题是中文时，文章标题以中文形式出现，看上去很不符合标准，或者可能会出现如:%64%b3%e8%ae%ar%e6%ba%a7%e5%9.html 类似乱码的显示。因此需要在编辑文章时，标题下面固定链接项，点击编辑，用拼音或英文输入文章标题。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-17.19.42.png" alt>  </p><p>然后把wordpress目录下的index.php 和 .htaccess文件复制一份到根目录下，.htaccess 是隐藏文件，可以使用ls -all。将其显示出来。注意是复制文件，原来目录下还存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html/wordpress/</span><br><span class="line">cp index.php /var/www/html/</span><br><span class="line">cp .htaccess /var/www/html/</span><br></pre></td></tr></table></figure><p>然后使用vim修改.htaccess文件的内容为下图所示。（默认文件如果就是如此则跳过该步骤） </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180319093058967.png" alt></p><p>修改index.php文件，因为index.php文件是wordpress下index.php的复制品，因此文件内部的require那一行的值当对于当前目录，是不正确的。同样使用vim编辑该文件，把require那一行路径，修改成下图那样。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20180319093423845.png" alt></p><p>此时再输入IP，看到还是It works界面，那是因为安装apache时，我们看到的It works界面其实是根目录下的index.html。当index.html 和 index.php同时存在时，默认还是打开index.html，所以应该把index.html移出该目录。我们把它移出到其他目录就行。  </p><h4 id="然后可能会产生下一个问题，设置固定链接后，文章页会404"><a href="#然后可能会产生下一个问题，设置固定链接后，文章页会404" class="headerlink" title="然后可能会产生下一个问题，设置固定链接后，文章页会404"></a><strong>然后可能会产生下一个问题，设置固定链接后，文章页会404</strong></h4><p>解决方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure><p>把 AllowOverride None 改为 AllowOverride ALL</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20170922122312719.png" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20170922122320129.png" alt></p><p>注意有两处要改，然后操作一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod rewrite</span><br><span class="line">sudo /etc/init.d/apache2 restar</span><br></pre></td></tr></table></figure><p>刷新一下应该就能正常打开文章了。</p><h3 id="主页样式修改"><a href="#主页样式修改" class="headerlink" title="主页样式修改"></a><strong>主页样式修改</strong></h3><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20170413090347184.jpeg" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/20170413090322305.png" alt></p><p>页尾和功能模块里的链接如果觉得碍眼，可以去除。  </p><h4 id="删除页尾“自豪地使用WordPress”字样"><a href="#删除页尾“自豪地使用WordPress”字样" class="headerlink" title="删除页尾“自豪地使用WordPress”字样"></a><strong>删除页尾“自豪地使用WordPress”字样</strong></h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-18.12.11.png" alt></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/Screenshot-2019-01-29-18.15.07.png" alt>  </p><p>如果是通过函数生成页尾的主题，一般在模板函数那里修改，查找 “Proudly powered by” 的字样删掉就ok。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=“&lt;?php echo esc\_url( \_\_( ‘http://wordpress.org/’, ‘twentyeleven’ )); ?&gt;” title=“&lt;?php esc\_attr\_e(‘SemanticPersonalPublishing Platform’, ‘twentyeleven’ ); ?&gt;” rel=“generator”&gt;&lt;?php printf( __( ‘Proudly powered by%s’,‘twentyeleven’ ), ‘WordPress’ ); ?&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure><h4 id="删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress-org”"><a href="#删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress-org”" class="headerlink" title="删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress.org”"></a><strong>删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress.org”</strong></h4><p>打开组件文件夹：wp-include/widgets/class-wp-widget-meta.php 找到代码段删除即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!\-\-</span> 屏蔽 <span class="attr">RSS</span> 功能</span></span><br><span class="line">&lt;li&gt;&lt;a href="&lt;?php echo esc\_url( get\_bloginfo( 'rss2\_url' )); ?&gt;"&gt;&lt;?php \_e('Entries &lt;abbr title="Really Simple Syndication"&gt;RSS&lt;/abbr&gt;'); ?&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;?php echo esc\_url( get\_bloginfo( 'comments\_rss2\_url' )); ?&gt;"</span>&gt;</span>&lt;?php _e('Comments &lt;abbr title="Really Simple Syndication"&gt;RSS&lt;/abbr&gt;'); ?&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性冷淡商务风：深圳龙华希尔顿逸林酒店</title>
      <link href="/2017-05-17-doubletree-longhua/"/>
      <url>/2017-05-17-doubletree-longhua/</url>
      
        <content type="html"><![CDATA[<p>龙华年初新开了间 DoubleTree，从此深圳也有CAT2的希尔顿了。可惜的是积分房常年不放10000分的基础房型，还好连续两日及以上还能订到基础房，配合 Hilton Q1 促销每晚送2000分活动，非常适合保级刷房。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress1-1548760825.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548760828.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店">  </p><p>酒店在粤商中心大厦1-15层，坐落于龙华文化广场旁，隔壁是龙华星河ICO，距离地铁清湖站较近，周围还算繁华，据说是龙华新区首家五星级国际酒店。粤商中心这栋楼全玻璃覆盖显得比较商务，符合 DoubleTree 品牌的定位。   </p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760829.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>一进大堂就是典型的 DoubleTree 性冷淡风格，米白色大理石为主的装修风格使原本较小的大堂显得大气，前台人手不够，客人多时要排队 CI/CO，上酒廊 Check-in 就更是要等很久了。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548760829.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760830.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548760831.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>酒店被设计在这栋楼底部十几层，上半部分是写字楼，似乎业主不太重视酒店。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548760832.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店">  </p><p>这次入住时房态紧张，只给升一级到12楼的园景房，虽然没升级到行政房不过也给了行政待遇。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760833.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>DoubleTree 标志性的热曲奇饼，每位顾客入住时都给两份，很好吃，路过前台时可以再要几块。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548760835.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760837.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548760837.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548760839.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760840.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>因为是新开业的酒店，硬件水准在同品牌中数一数二，客房面积48平方起步也没什么问题，套房楼层据说被某剧组包了几个月，因此没能升级套房挺可惜的。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548760842.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760843.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760845.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>逸林标配单人浴缸，卫生间干湿分离，瑰珀翠（Crabtree &amp; Evelyn）的备品味道一般，还是更喜欢彼得罗夫（Peter Thomas Roth）的热情果味。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548760846.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548760847.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760848.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>窗外正对龙华文化广场，也是新建的，晚上有大批广场舞大妈，幸好玻璃隔音性能不错，问题是晚上有治安的单车持续闪烁红蓝灯光，穿透力极强，不拉上遮光窗帘要被闪瞎眼。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760850.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760852.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548760853.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760855.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>床头音响支持直接插 iPhone 播放，插座自带USB也是这几年新开酒店的标配了。欢迎水果略显小气，进门的柜子另有玄机，水壶茶杯和小冰箱都藏在里面。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760855.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760856.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress1-1548760857.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760859.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress7-1548760862.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548760863.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>行政酒廊的 Happy Hour 从17点到19点，菜品十分丰富，热菜、甜品很多，当作晚餐完全没有问题。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548760865.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548760865.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548760866.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548760867.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>酒店健身房还没装修好，把酒廊对面的一间套房改造成了一个临时健身房，所以面积很小，设备也不够多，来几个老外就占满了。室外泳池也要到17年5月底才开放。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress1-1548760868.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548760870.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>回到房间发现已经开好了夜床，可能是看到一下子把两瓶水喝完了，于是又补充了六瓶😂而且很贴心地在床上放了张明日天气预报。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress7-1548760872.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress1-1548760874.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760875.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760876.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548760878.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760880.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548760882.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548760884.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>酒店的主餐厅名为 『OPEN | “開”全日餐厅』，然而晚上只营业到22点，并没有通宵开放😑 早餐看似丰富，实际出品一般，蛋卷和鸡肉肠还没有希尔顿花园的好吃。不过餐厅环境确实不错，适合平时晚上来吃自助餐。   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress8-1548760885.jpeg" alt="性冷淡商务风：深圳龙华希尔顿逸林酒店"></p><p>这间 DoubleTree 最近几个月都不放基础房了，可能确实是商务客比较多吧， 10000分入住虽然没有华东一堆5000分 DoubleTree 那么白菜价，但毕竟地处深圳龙华腹地，性价比非常高，实属希尔顿保级优选。      </p><blockquote><p>原文始发于微信公众号（派大星星星星）：<a href="http://mp.weixin.qq.com/s/3AVq0D4fRAt10VIMWOGvmw" target="_blank" rel="noopener">性冷淡商务风：深圳龙华希尔顿逸林酒店</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hotel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宜家 | 一个顺便卖卖家具的饭堂</title>
      <link href="/2015-12-17-ikea-canteen/"/>
      <url>/2015-12-17-ikea-canteen/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548761309.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>相信很多人印象中的宜家只是个卖家具的地方</p><p>跟自己关系不大</p><p>去那里干嘛</p><a id="more"></a><p>然而事实上并不是这样的  </p><p>宜家不只是卖家具</p><p>也卖非常多零碎玩意</p><p>很适合买来充实宿舍</p><p>但更重要的是它的餐厅</p><!-- more --><p>一个室友说</p><p>“宜家就是个顺便卖家具的食堂”</p><p>这话不假</p><p>这个餐厅不只是周末人满为患</p><p>即便是工作日也要找座位找很久</p><p>这还是宜家坐落在没有地铁经过的郊区的前提下</p><p>显得更为难得</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761310.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>▲餐厅门口菜单</p><p>餐厅不算太大</p><p>菜单也很简单</p><p>主菜也就瑞典肉圆 蔬菜丸 肉酱面 三文鱼 西冷牛扒 牛肉饭等</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548761312.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>最赞的就是瑞典肉圆了</p><p>不同于汕头牛肉丸爽口 弹性 有嚼劲</p><p>宜家的瑞典肉圆口感细腻 用料丰富</p><p>以猪肉和牛肉混合搅碎</p><p>加入牛奶 面包糠 切碎的洋葱 马铃薯粉或燕麦片</p><p>然后再加上白胡椒 盐 五香粉或肉桂等香料调味</p><p>搓匀后捏成球形  </p><p>食用时配以肉酱 土豆泥 果酱以及一枚瑞典国旗  </p><p>令人食指大动</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548761313.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>西冷牛扒出品还算可以</p><p>虽然跟专门做牛扒的餐厅相比差距不小</p><p>但考虑到三十多的售价也能理解 还是值这个价的</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548761314.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>烤三文鱼配通心粉</p><p>份量十足</p><p>不到三十块</p><p>价格感人</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress7-1548761316.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>奥尔良鸡腿</p><p>表皮烤的焦焦的</p><p>肉质多汁嫩滑</p><p>跟肉丸一样也是必点</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761318.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>冷盘菜</p><p>香草三文鱼</p><p>酸黄瓜酱不会掩盖三文鱼的鲜美</p><p>反而相得益彰美味可口</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548761319.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>宜家物价让人有种回到十年前的感觉</p><p>在深圳物价飞涨都快赶上香港的年代</p><p>还有这么个出品优良又便宜的餐厅实属不易</p><p>如果不是因为路途遥远交通不便利真的就成饭堂了</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761320.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>▲取菜窗口超像饭堂</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761323.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>说是饭堂的另一个原因</p><p>顾客吃完后需要自己把餐盘放进回收车里</p><p>大大减少清洁阿姨工作量</p><hr><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761325.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>▲会员卡颜值颇高</p><p>记得办一张宜家的会员卡</p><p>在入口和收银台前都有免费申请的电脑</p><p>填完资料直接就吐卡出来了</p><p>工作日凭会员卡可以在餐厅免费喝咖啡</p><p>无限续杯的喔</p><p>而且很多单品都有会员优惠</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548761327.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>比如这个两块九的杯子  </p><p>新会员可以一块钱购买</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548761329.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761330.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>值得一提的是毛巾和门垫  </p><p>毛巾质量很好 不会掉毛</p><p>门垫价格感人</p><p>可以屯多几张在宿舍</p><p>脏了直接换一个</p><hr><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761331.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>在收银台出来的地方还有一个小食档</p><p>五块钱的热狗套餐可以无限续杯</p><p>最近饮料都换成了相比可乐含糖量减半的北欧风味果味饮料</p><p>不过感觉还是以前的蔓越莓果汁好喝</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548761333.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>还有就是十块三串的墨鱼丸</p><p>真心赞赞赞赞赞</p><p>外焦里嫩弹牙可口</p><p>墨鱼味十足</p><p>买买买后吃上一份墨鱼丸真是酸爽</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548761334.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>还有同样十块三串的烤肠  </p><p>味道跟乐凯撒的烤肠差不多</p><p>因为量不多</p><p>晚上七八点后可能就卖完了</p><p>同样强力推荐</p><p>见到了赶紧买三串</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761335.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>小食档旁边还有专门卖瑞典特产的超市</p><p>如果肉丸或者三文鱼吃的不过瘾还能买冷冻的回去自己煮</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548761336.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p>阻挡宜家成为饭堂的最大因素还是地理位置不好</p><p>公交非常不便利</p><p>只能自驾或者打车前往</p><p>不过不塞车的话从桂庙过去十分钟就能到</p><p>所以闲暇之余还是可以去吃餐饭的</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548761337.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548761337.jpeg" alt="宜家 | 一个顺便卖卖家具的饭堂"></p><blockquote><p>原文始发于微信公众号（派大星星星星）：<a href="http://mp.weixin.qq.com/s/fml6LiuDyC8qeY6rLNhtpw" target="_blank" rel="noopener">宜家 | 一个顺便卖卖家具的饭堂</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Food </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一蘭拉面</title>
      <link href="/2015-11-18-ichiran-ramen/"/>
      <url>/2015-11-18-ichiran-ramen/</url>
      
        <content type="html"><![CDATA[<p>一蘭拉面</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548759254.jpeg" alt="一蘭拉面"><br>▲铜锣湾店门口 </p><p>一蘭拉面的特点在于座位是隔间并且24小时运营，很适合深夜下班后一个人来吃，不会尴尬。 </p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress7-1548759255.jpeg" alt="一蘭拉面"><br>▲座位都是一个个隔间 </p><p>年初的时候，一兰除了日本本土外就只有铜锣湾一家分店，港岛线铜锣湾站C出口走5分钟谢斐道440号门面便是。店铺不算大，目测只能容纳50人，天黑了之后一直到凌晨三四点都要排队，22点左右高峰期甚至要排一个钟的队，不过为了吃上一碗一兰拉面，排队久一点也值得。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548759257.jpeg" alt="一蘭拉面"><br>▲铜锣湾店排队排出了店面   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548759259.jpeg" alt="一蘭拉面"><br>▲空余座位展示，每个绿色格子代表一个座位 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548759262.jpeg" alt="一蘭拉面"><br>▲只有一款面的菜单 </p><p>排队快到的时候店员会给单你让你圈出偏好，我除了硬度喜欢偏硬一些外其他都是普通。偏硬是因为咬起来有口感。一碗89块港币的拉面，精华在于汤底，浓香而不腻，实打实用豚骨熬制，不加味精。吃完面后如果不喝汤就太浪费了。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548759263.jpeg" alt="一蘭拉面"><br>▲1/2倍辣 </p><p>因为还是学生，钱不多，所以很少追加面底、温泉蛋、叉烧或者波子汽水。不过温泉蛋是真心好吃，建议尾巴们去的话一定要点一份。 秘制酱汁确实挺辣的，有一次被怂恿写了5倍辣，吃完整个人都不好了，当晚睡觉都睡不好。当然主要是因为我不太能吃辣，无辣不欢的尾巴可以试试20倍辣，很酸爽[doge] </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress10-1548759264.jpeg" alt="一蘭拉面"><br>▲5倍辣 </p><p>店面是单人隔间，每个位置都有冷水水龙头，就算再冷的天也是冷水。网上的解释是  </p><blockquote><p>冰水的作用在於吃拉面时缓和浓厚的味道，同时有助口腔降温加快吃面速度，因为面太热而吃得慢，面浸汤糊烂的情况只会越来越严重。 冰水是多年来日式拉面的传统，春夏秋冬也不改。博主曾在下雪日子在拉面店外排队，店员会为等待的人送上热茶，但去到店内还是冰水。 希望大家不要因為气温10度时拉面店内送上冰水就破口大骂或上网劣评，人家日本人下雪时都未投诉。理解这原因后仍想要热水的话，向店员礼貌地要求就是了。</p></blockquote><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress3-1548759265.jpeg" alt="一蘭拉面"><br>▲每个座位上都有首次来店顾客指南，中英日各一份 </p><p>今年年中的时候，一兰在尖沙咀棉登径8号负一楼开了第二家分店。不知道什么原因，很多地图上都还没有标记出来，尖沙咀N4出口出来就是了。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548759265.jpg" alt="一蘭拉面"><br>▲高德地图 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548759267.jpeg" alt="一蘭拉面"><br>▲尖沙咀店入口，店铺在负一楼 </p><p>可能是因为在铜锣湾的第一家海外分店尝到了甜头，这家新分店面积很大，而且出现了一兰屋台，就是普通餐厅的座椅区，但我还是喜欢隔间多一点，毕竟隔间是一兰的特色，坐屋台的话没有感觉。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress5-1548759269.jpeg" alt="一蘭拉面"><br>▲尖沙咀店一兰屋台 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548759271.jpeg" alt="一蘭拉面"><br>▲一兰方便面 </p><p>一兰方便面，四五月份刚推出的时候有买单满200HKD送一个的活动，回来宿舍泡了一下发现挺一般的，跟店里吃的差距太大，不知道是方便面的问题还是我泡面方法不当[摊手]原价是198HKD五包，据说买一套的话里面会有特殊配料 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548759272.jpeg" alt="一蘭拉面"><br>▲泡出来的效果，凭良心讲确实比合味道之类的好吃一些，但还不至于太好吃，不值那个价。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548759275.jpeg" alt="一蘭拉面"><br>▲方便面海报 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress4-1548759279.jpeg" alt="一蘭拉面"><br>▲收银台 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548759280.jpeg" alt="一蘭拉面"><br>▲收银台后面的展柜 </p><p>月初去吃的时候发现账单多了一项额外10%的服务费，以前都没见过，不知道是最近才开始收的还是因为尖沙咀店比较大要额外收费。付款支持现金、八达通和银联卡，我预计不用太久，支付宝就会来插一脚，进一步方便大陆游客在香港游玩。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress9-1548759281.jpeg" alt="一蘭拉面"><br>▲尖沙咀店内海报 </p><p>还没读大学的时候在广州住，每次去正佳和中华基本上都是吃博多一幸舍。博多刚进驻广州第一次吃的时候震惊了，怎么会有这么好吃的面，从此再也没吃过味千公仔面。 然而上大学后，某次安利别人博多时被反安利了一兰，这才发觉山外有山。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress2-1548759282.jpeg" alt="一蘭拉面"><br>▲铜锣湾店门面 </p><p>一兰没有博多一幸舍的喧闹环境，店员们不会热血地齐声用日语喊欢迎光临，只会在隔间后面端面上来时说一声慢用（不会日语，猜的）然后落下帘子。店里如果没有小孩的话一般都挺安静。 另外不同于博多丰富的菜单，一兰只有一款面（好像最近新推出了一款沾面，不太记得了）。 </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress6-1548759283.jpeg" alt="一蘭拉面"><br>▲基友吃得正欢 </p><p>在我有限的经历中，一兰拉面在我吃过的日本拉面中算是最好吃的了，一兰以其独特的隔间设计，只做一款面的坚持，极致浓香的汤底，口感细腻的面底赢得了大众的喜爱。有时候我嘴馋了也不怕劳累，专门从深圳湾过关搭巴士到天水围转港铁到尖沙咀来吃个面，也算是一兰真粉了。 大家如果去一兰，一定要预留多一些时间用来排队，以免耽误行程。[doge] </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/beepress0-1548759283.jpeg" alt="一蘭拉面"></p><blockquote><p>原文始发于微信公众号（派大星星星星）：<a href="http://mp.weixin.qq.com/s/85y8zF4qNyA2NR8sBmuNLQ" target="_blank" rel="noopener">一蘭拉面</a></p></blockquote><h3 id="2019-01更新-—-日本的一蘭拉面"><a href="#2019-01更新-—-日本的一蘭拉面" class="headerlink" title="2019.01更新 — 日本的一蘭拉面"></a>2019.01更新 — 日本的一蘭拉面</h3><p>  2018年夏天去大阪和东京晃悠了一圈，路过不少一兰。  </p><h3 id="大阪"><a href="#大阪" class="headerlink" title="大阪"></a>大阪</h3><h4 id><a href="#" class="headerlink" title=" "></a> </h4><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_2417.jpg" alt><br>▲大阪也超多人</p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_7512.jpg" alt><br>▲自助机器先付后食，这种机器是真的🐂🍺   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_4485.jpg" alt><br>▲自助机出的票   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_4487.jpg" alt><br>▲出品稳定，跟香港的几乎没区别      </p><h3 id="东京"><a href="#东京" class="headerlink" title="东京"></a>东京</h3><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_7086.jpg" alt><br>▲还是自助机，依然人多得一批   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_5225.jpg" alt><br>▲还是一样的味道   </p><p><img src="https://raw.githubusercontent.com/Fongim/personal_blog_image/master/image/IMG_5497.jpg" alt><br>▲一样的抹茶豆腐</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Food </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
