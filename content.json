{"meta":{"title":"派大星星星星","subtitle":"你有没有给我带点鱼来","description":null,"author":"大星","url":"https://paaatrick.com","root":"/"},"pages":[{"title":"所有标签","date":"2021-11-07T12:02:15.283Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"tags/index.html","permalink":"https://paaatrick.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-11-07T12:02:15.283Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"categories/index.html","permalink":"https://paaatrick.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"如何构建一个支持 Windows XP 的 LIB/DLL/EXE","slug":"build-for-windows-xp","date":"2021-11-07T09:38:41.000Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"2021-11-07-build-for-windows-xp/","link":"","permalink":"https://paaatrick.com/2021-11-07-build-for-windows-xp/","excerpt":"最近把公司的一些大型跨平台 C++ Base 项目从 CMake 构建系统切换到了 Google 的 GN Build。进展都比较顺利，直到有客户需要一个支持 Windows XP 的动态库。。。 虽然马上就要 2022 年，距离 XP 的诞生已经超过 20 年，距离 XP 的废弃也超过 7 年了，但仍然架不住还是将近有 5% 的计算机运行着 XP （大陆地区甚至有 15% ！），既然客户需要，那还是得支持 🤷‍♂️","text":"最近把公司的一些大型跨平台 C++ Base 项目从 CMake 构建系统切换到了 Google 的 GN Build。进展都比较顺利，直到有客户需要一个支持 Windows XP 的动态库。。。 虽然马上就要 2022 年，距离 XP 的诞生已经超过 20 年，距离 XP 的废弃也超过 7 年了，但仍然架不住还是将近有 5% 的计算机运行着 XP （大陆地区甚至有 15% ！），既然客户需要，那还是得支持 🤷‍♂️ 实际上这个项目在几年前已经做过一次 XP 的适配，也顺利交付过很多次了，但明显 Google Chromium 的工具链默认并不支持 Windows XP。 构建支持经过一番研究，实际上在构建这块，想要支持 XP 还是比较简单的，难的是代码中如何解决适配那些 XP 没有提供的 Windows API。以下按照不同的 Windows 工程来讨论。 原生 Visual Studio 工程 首先确保你的 Visual Studio 已安装 XP 工具集（例如 VS 2019 的需要安装标注了已废弃的 v141_xp 工具集。 打开解决方案/项目，在项目属性中找到常规 -&gt; 平台工具集，选择 v141_xp 或其他带有 xp 后缀的工具集。 改动保存后，注意到此时 Windows SDK 的版本会自动切换到 7.0。然后再次生成项目，就能构建出一个支持 Windows XP 的库/可执行二进制了。 CMake 工程 需要使用 Visual Studio Generator，参考 CMake Visual Studio Generator 通过 -T 参数指定 v141_xp 或 v140_xp 的工具集，参考 CMAKE_GENERATOR_TOOLSET 例如 cmake -GVisual Studio 15 2017 -Tv141_xp GN (Ninja) 工程 此方式不仅适用于 GN 工程，也适用于任何直接调用 MSBuild 命令行工具的构建系统。 为所有 source_set 添加 _USING_V110_SDK71_ 这个 defines （宏定义），即为 cl.exe 添加参数 /D_USING_V110_SDK71_ （用于传递给源码中可能出现的 XP 分支宏，这是官方推荐的 XP 专用宏） 为你的 shared_library 或 executable Target 添加 /SUBSYSTEM:WINDOWS,&quot;5.02&quot; 这个 ldflags （链接器参数） ，即为 link.exe 指定构建目标为 5.02 (Windows XP SP2)，参考 链接器选项 /SUBSYSTEM（指定子系统） 如果你使用的是 Google Chromium 的 build 作为你的 GN 工程的工具链，你可以直接为你的 shared_library 或 executable Target 添加如下 config: 1configs += [ &quot;//build/config/win:windowed&quot; ] 参考：GN build toolchain, //build/config/win:windowed 代码支持如果你的项目里依赖了很多 Windows API，可以预见的是链接时找不到符号，因为很多 API 都是在 Windows 7 以后才提供的。 当然你可以耗费一些时间，把那些用到的新 API 替换掉，不管是找替代品还是干脆就不支持，都可以。 个人推荐一个便于你适配 XP 的 开源项目 YY-Thunks，集成到你的工程中，应该就能链接成功了。 :-)","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://paaatrick.com/tags/Windows/"},{"name":"GN","slug":"GN","permalink":"https://paaatrick.com/tags/GN/"},{"name":"Ninja","slug":"Ninja","permalink":"https://paaatrick.com/tags/Ninja/"},{"name":"CMake","slug":"CMake","permalink":"https://paaatrick.com/tags/CMake/"}]},{"title":"Flutter 移动端屏幕采集方案分享","slug":"flutter-screen-capture","date":"2020-11-20T04:12:59.000Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"2020-11-20-flutter-screen-capture/","link":"","permalink":"https://paaatrick.com/2020-11-20-flutter-screen-capture/","excerpt":"现如今随着 Flutter 的应用越来越广泛，纯 Flutter 项目也越来越多，本篇内容主要分享的是 Flutter 移动端（iOS + Android）的屏幕采集的实现。","text":"现如今随着 Flutter 的应用越来越广泛，纯 Flutter 项目也越来越多，本篇内容主要分享的是 Flutter 移动端（iOS + Android）的屏幕采集的实现。 概述在视频会议、线上课堂、游戏直播等场景，屏幕共享是一个最常见的功能。屏幕共享就是对屏幕画面的实时共享，端到端主要有几个步骤：录屏采集、视频编码及封装、实时传输、视频解封装及解码、视频渲染。 一般来说，实时屏幕共享时，共享发起端以固定采样频率（一般 8 - 15帧足够）抓取到屏幕中指定源的画面（包括指定屏幕、指定区域、指定程序等），经过视频编码压缩（应选择保持文本/图形边缘信息不失真的方案）后，在实时网络上以相应的帧率分发。 因此，屏幕采集是实现实时屏幕共享的基础，它的应用场景也是非常广泛的。 实现准备首先我们看看原生系统提供了哪些能力来进行屏幕录制。 iOS 11.0 提供了 ReplayKit 2 用于采集跨 App 的全局屏幕内容，但仅能通过控制中心启动；iOS 12.0 则在此基础上提供了从 App 内启动 ReplayKit 的能力。 Android 5.0 系统提供了 MediaProjection 功能，只需弹窗获取用户的同意即可采集到全局屏幕内容。 我们再看一下 Android / iOS 的屏幕采集能力有哪些区别。 iOS 的 ReplayKit 是通过启动一个 Broadcast Upload Extension 子进程来采集屏幕数据，需要解决主 App 进程与屏幕采集子进程之间的通信交互问题，同时，子进程还有诸如运行时内存最大不能超过 50M 的限制。 Android 的 MediaProjection 是直接在 App 主进程内运行的，可以很容易获取到屏幕数据的 Surface。 解决方案虽然无法避免原生代码，但我们可以尽量以最少的原生代码来实现 Flutter 屏幕采集。将两端的屏幕采集能力抽象封装为通用的 Dart 层接口，只需一次部署完成后，就能开心地在 Dart 层启动、停止屏幕采集了。 iOS打开 Runner Xcode Project，新建一个 Broadcast Upload Extension Target，在此处理 ReplayKit 子进程的业务逻辑。 首先需要处理主 App 进程与 ReplayKit 子进程的跨进程通信问题，由于屏幕采集的 audio/video buffer 回调非常频繁，出于性能与 Flutter 插件生态考虑，在原生侧处理音视频 buffer 显然是目前最靠谱的方案，那剩下要解决的就是启动、停止信令以及必要的配置信息的传输了。 对于启动 ReplayKit 的操作，可以通过 Flutter 的 MethodChannel 在原生侧 new 一个 RPSystemBroadcastPickerView，这是一个系统提供的 View，包含一个点击后直接弹出启动屏幕采集窗口的 Button。通过遍历 Sub View 的方式找到 Button 并触发点击操作，便解决了启动 ReplayKit 的问题。 然后是配置信息的同步问题。 一是使用 iOS 的 App Group 能力，通过 NSUserDefaults 持久化配置在进程间共享配置信息，分别在 Runner Target 和 Broadcast Upload Extension Target 内开启 App Group 能力并设置同一个 App Group ID，然后就能通过 -[NSUserDefaults initWithSuiteName] 读写此 App Group 内的配置了。 二是使用跨进程通知 CFNotificationCenterGetDarwinNotifyCenter 携带配置信息来实现进程间通信。 接下来是停止 ReplayKit 的操作。也是使用上述的 CFNotification 跨进程通知，在 Flutter 主 App 发起结束屏幕采集的通知，ReplayKit 子进程接收到通知后调用 -[RPBroadcastSampleHandler finishBroadcastWithError:] 来结束屏幕采集。 Android启动屏幕采集时，直接通过 Flutter 的 MethodChannel 在原生侧通过 MediaProjectionManager 弹出一个向用户请求屏幕采集权限的弹窗，收到确认后即可调用 MediaProjectionManager.getMediaProjection() 函数拿到 MediaProjection 对象。 然后根据业务场景需求从屏幕采集 buffer 的消费者拿到 Surface，例如，要保存屏幕录制的话，从 MediaRecoder 拿到 Surface，要录屏直播的话，可调用音视频直播 SDK 的接口获取 Surface。 有了 MediaProjection 和消费者的 Surface，接下来就是调用 MediaProjection.createVirtualDisplay() 函数传入 Surface 来创建 VirtualDisplay 实例，从而获取到屏幕采集 buffer。 最后是结束屏幕采集，相比 iOS 复杂的操作，Android 仅需要将 VirtualDisplay 和 MediaProjection 实例对象释放即可。 实战示例一个实现了 iOS/Android 屏幕采集并使用 ZEGO Express Audio and Video Flutter SDK 进行推流直播的示例 Demo。 https://github.com/zegoim/zego-express-example-screen-capture-flutter","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Flutter","slug":"Flutter","permalink":"https://paaatrick.com/tags/Flutter/"},{"name":"Android","slug":"Android","permalink":"https://paaatrick.com/tags/Android/"}]},{"title":"解决 CocoaPods trunk CDN 连接不上的问题","slug":"cocoapods-trunk-cdn-issue","date":"2020-04-10T08:22:10.000Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"2020-04-10-cocoapods-trunk-cdn-issue/","link":"","permalink":"https://paaatrick.com/2020-04-10-cocoapods-trunk-cdn-issue/","excerpt":"CocoaPods 自 1.8 版本开始默认使用 trunk CDN (https://cdn.cocoapods.org/) 作为 spec 的源，本意是非常好的，避免了需要本地 clone 一份庞大的 Specs 仓库导致每次 update 都要全量更新的问题。然而不知为何国内连 trunk CDN 都被限制访问了。 常见的问题是 pod install 时报错 CDN: trunk URL couldn&#39;t be downloaded 以及 pod repo update 时 CDN: trunk Repo update failed 以下是几种解决方案。","text":"CocoaPods 自 1.8 版本开始默认使用 trunk CDN (https://cdn.cocoapods.org/) 作为 spec 的源，本意是非常好的，避免了需要本地 clone 一份庞大的 Specs 仓库导致每次 update 都要全量更新的问题。然而不知为何国内连 trunk CDN 都被限制访问了。 常见的问题是 pod install 时报错 CDN: trunk URL couldn&#39;t be downloaded 以及 pod repo update 时 CDN: trunk Repo update failed 以下是几种解决方案。 安装 CocoaPods在执行以下步骤之前，请确保已安装 CocoaPods。 可执行 pod --version 检查是否有安装 CocoaPods 并查看版本号。 安装 CocoaPods：打开终端 Terminal，执行： 1sudo gem install cocoapods 请参阅 CocoaPods入门 注：若根据以上入门指引，因网络问题无法下载安装 CocoaPods，可考虑使用 Ruby Gems 镜像源： 清华 Gems 镜像站: https://mirror.tuna.tsinghua.edu.cn/help/rubygems/ Ruby China 镜像站: https://gems.ruby-china.com 解决连接不上 trunk CDN 的问题方案一：使用代理不管是使用旧版 CocoaPods 还是使用镜像源，都不是最优解，为了充分使用 CocoaPods 的特性，最推荐的还是使用代理来解决无法连接 trunk CDN 的问题。 方案二：使用旧版 CocoaPods1.7.5 版本的 CocoaPods 默认使用 Specs 作为 repo 源，可以卸载后重新安装旧版 CocoaPods。 卸载： 1sudo gem uninstall cocoapods 安装 CocoaPods 1.7.5： 1sudo gem install cocoapods -v 1.7.5 方案三：手动切换使用官方 Git 源 / 镜像源 不推荐此方案，比较繁琐。 检查当前使用的源 先执行 pod repo list 查看本机的源有哪些，如果存在一个 master 源 (URL: https://github.com/CocoaPods/Specs.git) 以及一个 trunk 源 (URL: https://cdn.cocoapods.org/)，则无需操作下面的第二步，可直接执行 pod repo remove trunk 删除 trunk CDN 源。 若使用 1.9.1 或以上版本，应该只存在一个 trunk CDN 源，此时需要手动添加 Git 源 添加源 添加 官方 CocoaPods Git 源 执行 pod repo add cocoapods https://github.com/CocoaPods/Specs.git 添加 清华 CocoaPods 镜像源 执行 pod repo add tuna https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git 执行 pod repo update --verbose 在 iOS 项目根目录下的 Podfile 文件里指定源 若找不到 Podfile，请先 cd 进 iOS 项目的根目录，执行 pod init 往 Podfile 的第一行添加一句 source https://xxxxx.git （其中的 URL 为上一步添加的源的 URL） 例：使用清华源 12345source 'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git'target 'MyProject' do use_frameworks!end 如果没有在 Podfile 里指定 source 的话，1.8 版本以上的 CocoaPods 会自动重新添加并使用 trunk CDN 源，因此每个项目的 Podfile 都需要显式指定 source，非常麻烦。","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://paaatrick.com/tags/CocoaPods/"}]},{"title":"macOS 使用 QuickLook 预览高亮查看任意代码源文件","slug":"make-mac-quicklook-any-code-source-file","date":"2020-04-05T14:32:43.000Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"2020-04-05-make-mac-quicklook-any-code-source-file/","link":"","permalink":"https://paaatrick.com/2020-04-05-make-mac-quicklook-any-code-source-file/","excerpt":"很多源码文件 macOS 默认不支持通过空格快速查看，比如 Flutter 的 .dart 文件、YAML 的 .yaml、.yml、CocoaPods 的 Podfile、Podfile.lock 等等。","text":"很多源码文件 macOS 默认不支持通过空格快速查看，比如 Flutter 的 .dart 文件、YAML 的 .yaml、.yml、CocoaPods 的 Podfile、Podfile.lock 等等。 就算通过右键文件，显示简介 -&gt; 打开方式 将其设置为全部通过 VSCode、Android Studio 等应用打开，解决了能双击文件打开的问题，也还是不能 QuickLook 快速预览。 普通的 .h、.cpp 等源码文件虽然系统是认识了，但没有代码高亮，看瞎眼。 安装插件幸好有成吨的开源插件做了这些事，不用重复造轮子。 GitHub 项目链接：https://github.com/sindresorhus/quick-look-plugins 其他关于 QuickLook Plugin 的介绍： https://sspai.com/post/31927 https://zhuanlan.zhihu.com/p/57203915 关于 QuickLook 的介绍参考以上两个链接，就不再啰嗦了。 对于本文讨论的高亮预览源码文件的需求，我们可以安装 QLColorCode 用于代码高亮、QLStephen 用于预览无后缀名的文件。 推荐通过 Homebrew 来安装，以便集中管理。 123brew cask install qlcolorcodebrew cask install qlstephen 需要注意的是如果 macOS 系统版本是 10.15 Catalina 及以上，安装完插件后需要额外执行一下 xattr -r ~/Library/QuickLook xattr -d -r com.apple.quarantine ~/Library/QuickLook 以解决运行不了 QuickLook 插件的问题 添加扩展文件然而即便安装了里面的 QLColorCode 也还是没法查看这些系统不认识的文件比如 .dart，此时可修改一下这个插件的配置文件使其支持 打开 ~/Library/QuickLook/QLColorCode.qlgenerator/Contents/Info.plist 文件 找到 Document types &gt; Item 0 &gt; Document Content Type UTIs (CFBundleDocumentTypes &gt; Item 0 &gt; LSItemContentTypes 点击➕添加一行 .dart 文件格式，如上图所示 1com.apple.disk-image-dart 保存后即生效，其他类型文件也可通过这个方法来快速预览。 然而如何查看具体某种文件格式的类型呢？ 通过这条命令 1mdls -name kMDItemContentType ./main.dart 就能得到传入的文件类型了 1kMDItemContentType = \"com.apple.disk-image-dart\" 把常见的源码文件都添加进 ~/Library/QuickLook/QLColorCode.qlgenerator/Contents/Info.plist，生产效率大大提高💪 参考 https://medium.com/@claudmarotta/how-to-preview-dart-files-with-macos-quick-look-54779340811f https://github.com/anthonygelibert/QLColorCode https://github.com/whomwah/qlstephen/issues/81#issuecomment-582365549","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://paaatrick.com/tags/macOS/"},{"name":"QuickLook","slug":"QuickLook","permalink":"https://paaatrick.com/tags/QuickLook/"}]},{"title":"【SwiftUI】解决 NavigationLink 立即加载 destination View 的问题（实现懒加载）","slug":"swiftui-navigationlink-destination-not-lazy","date":"2020-03-22T16:32:43.000Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"2020-03-23-swiftui-navigationlink-destination-not-lazy/","link":"","permalink":"https://paaatrick.com/2020-03-23-swiftui-navigationlink-destination-not-lazy/","excerpt":"在 SwiftUI 中，一般通过 NavigationView 配合 NavigationLinks 来实现页面间的跳转，可类比为 UIKit 中的 UINavigationController 与 segue（或者 push/present 语句）。熟悉 UIKit 的开发者刚接触 SwiftUI 时可能会遇到一个小坑：NavigationLinks 的 destination 并不是懒加载的。","text":"在 SwiftUI 中，一般通过 NavigationView 配合 NavigationLinks 来实现页面间的跳转，可类比为 UIKit 中的 UINavigationController 与 segue（或者 push/present 语句）。熟悉 UIKit 的开发者刚接触 SwiftUI 时可能会遇到一个小坑：NavigationLinks 的 destination 并不是懒加载的。 遇到的问题NavigationLinks 与 UIKit 中 push/present 之间的行为差异导致刚上手 SwiftUI 时，由于不知道目标 View 会被提前加载，使得目标 View 里的业务逻辑时序上出现问题。 我们都知道，UINavigationController 的目标 ViewController 只在调用了 push/present 后才会触发常用的加载方法 viewDidLoad()。 然而在 SwiftUI 中，NavigationLinks 的目标 View 会立即加载，这意味着假设有一个包含 100 个 cell 的 List/ForEach，其中每个 cell 都是用 NavigationLinks 来跳转新页面的话，那当加载显示这个 List 时，内存中会马上创建 100 个对应的 View 结构体。 如果这些 View 的构造函数中还做了些开销大的操作比如网络请求、加载资源等。。。可以想象将导致什么后果🤣 例： 如下所示，MyRootView 是首页 View，通过 NavigationView 来实现路由导航功能，其中是一个包含了三个 cell 的 List，每个 cell 是一个 NavigationLinks，分别导航至 FirstView、SecondView、ThirdView。 12345678910111213141516171819202122232425262728293031323334353637import SwiftUIstruct MyRootView: View &#123; let myViews = [ \"FirstView\", \"SecondView\", \"ThirdView\" ] func containedView(viewName: String) -&gt; AnyView &#123; switch viewName &#123; case \"FirstView\": return AnyView(FirstView()) case \"SecondView\": return AnyView(SecondView()) case \"ThirdView\": return AnyView(ThirdView()) default: return AnyView(Text(\"None\")) &#125; &#125; var body: some View &#123; NavigationView &#123; List(myViews, id: \\.self) &#123; viewName in NavigationLink(destination: self.containedView(viewName: viewName)) &#123; Text(viewName) &#125; &#125; .navigationBarTitle(Text(\"ZegoExpressExample\"), displayMode: .automatic) .onAppear &#123; NSLog(\"🚩 MyRootView appear\") &#125; &#125; &#125;&#125; 然后，在 FirstView、SecondView、ThirdView 的实现中，View 结构体里包含一个 class 实例属性，如下所示： 1234567891011121314151617181920212223242526struct FirstView: View &#123; private let firstCoordinator = FirstCoordinator() init() &#123; NSLog(\"1️⃣ FirstView init 🟢\") &#125; var body: some View &#123; Text(\"I'm FirstView created by Patrick Fu\") .onAppear &#123; NSLog(\"---------1️⃣ FirstView appear-------\") &#125;.onDisappear &#123; NSLog(\"---------1️⃣ FirstView disappear-------\") &#125; &#125; class FirstCoordinator: NSObject &#123; override init() &#123; NSLog(\"1️⃣ FirstCoordinator init 🟢\") &#125; deinit &#123; NSLog(\"1️⃣ FirstCoordinator deinit 🔴\") &#125; &#125;&#125; 12345678910111213141516171819202122232425262728import SwiftUIstruct SecondView: View &#123; private let secondCoordinator = SecondCoordinator() init() &#123; NSLog(\"2️⃣ SecondView init 🟢\") &#125; var body: some View &#123; Text(\"I'm SecondView created by Patrick Fu\") .onAppear &#123; NSLog(\"---------2️⃣ SecondView appear-------\") &#125;.onDisappear &#123; NSLog(\"---------2️⃣ SecondView disappear-------\") &#125; &#125; class SecondCoordinator: NSObject &#123; override init() &#123; NSLog(\"2️⃣ SecondCoordinator init 🟢\") &#125; deinit &#123; NSLog(\"2️⃣ SecondCoordinator deinit 🔴\") &#125; &#125;&#125; ThirdView 的实现完全一致，就不贴出来了 测试一下，通过日志可以发现，当加载显示 MyRootView 的时候，通过 NavigationLinks 导航的目标 View 全部被提前立即初始化了，并且其属性 Coordinator 类也被实例化了。 123456789101112131415162020-03-23 01:10:46.546218+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 🚩 MyRootView appear2020-03-23 01:10:46.553204+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 1️⃣ FirstCoordinator init 🟢2020-03-23 01:10:46.553234+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 1️⃣ FirstView init 🟢2020-03-23 01:10:46.558073+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 2️⃣ SecondCoordinator init 🟢2020-03-23 01:10:46.558104+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 2️⃣ SecondView init 🟢2020-03-23 01:10:46.559791+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 3️⃣ ThirdCoordinator init 🟢2020-03-23 01:10:46.559808+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 3️⃣ ThirdView init 🟢2020-03-23 01:11:03.746197+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------1️⃣ FirstView appear-------2020-03-23 01:11:06.641696+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 🚩 MyRootView appear2020-03-23 01:11:06.892756+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------1️⃣ FirstView disappear-------2020-03-23 01:11:08.618983+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------2️⃣ SecondView appear-------2020-03-23 01:11:11.507952+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 🚩 MyRootView appear2020-03-23 01:11:11.680365+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------2️⃣ SecondView disappear-------2020-03-23 01:11:13.138151+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------3️⃣ ThirdView appear-------2020-03-23 01:11:15.317203+0800 ZegoExpressExample-iOS-Swift[76375:18919854] 🚩 MyRootView appear2020-03-23 01:11:15.488869+0800 ZegoExpressExample-iOS-Swift[76375:18919854] ---------3️⃣ ThirdView disappear------- 并且在右滑返回主页面时，View 和其 Coordinator 类实例也并没有被释放，GG~ 解决方法首先，NavigationLinks 立即加载 destination 的现象应该是 SwiftUI 的 Feature。因为在 SwiftUI 中，View 是非常轻量化的结构体，类似于 Flutter 中的 Widget，创建、销毁的开销非常低。 方案一因此，其中一种解决方案就是充分利用 View 的 onAppear() 和 onDisappear() 作为依赖注入来实现自己的业务逻辑和一些开销大的操作，避免在 View 初始化的时机做业务逻辑。也就是说，把 View 的 onAppear() 当做 UIKit 中的 viewDidLoad() 来使用，并且避免在 View 的属性中直接初始化开销大的对象。 方案二当然了，作为老 UIKit/AppKit 开发者，大量的对象瞬间全部加载实在难顶，还是得懒加载才行。 那另一种解决方案就是通过给 destination 的 View 包裹一层自定义的 View 来实现懒加载功能。 LazyView.swift 1234567891011import SwiftUIpublic struct LazyView&lt;Content: View&gt;: View &#123; private let build: () -&gt; Content public init(_ build: @autoclosure @escaping () -&gt; Content) &#123; self.build = build &#125; public var body: Content &#123; build() &#125;&#125; 一个 View 的 body 属性只在这个 View 被显示出来的时候才会被执行，也就是说，当 body 中的 NavigationLinks 的 destination 是另一个 ViewB 时，这个 destination 的 ViewB 会被马上初始化，但是 ViewB 的 body 属性不会被执行。 换句话说，SwiftUI 会立刻加载当前层级以及下一层级的 View，但不会加载第三层级的 View。 因此，用一个自定义 View 来包裹住真正想要跳转的目标 View，就可以变相的实现懒加载。 实际上，此方案只是“懒加载”了目标 View，在一个拥有大量 cell 的 List/ForEach 中，还是会有等同数量的 LazyView 被创建。 这种方式并不 Swifty，目前看来，最好还是按照 SwiftUI 的设计理念来做业务逻辑，也就是上面的方案一。 用法示例 123456789struct ContentView: View &#123; var body: some View &#123; NavigationView &#123; NavigationLink(destination: LazyView(Text(\"My details page\"))) &#123; Text(\"Go to details\") &#125; &#125; &#125;&#125; 修改后的 MyRootView 的 body 如下所示 12345678910111213var body: some View &#123; NavigationView &#123; List(myViews, id: \\.self) &#123; viewName in NavigationLink(destination: LazyView(self.containedView(viewName: viewName))) &#123; Text(viewName) &#125; &#125; .navigationBarTitle(Text(\"ZegoExpressExample\"), displayMode: .automatic) .onAppear &#123; NSLog(\"🚩 MyRootView appear\") &#125; &#125;&#125; 测试一下，当加载显示 MyRootView 时，通过 NavigationLinks 导航的目标 View 都实现了懒加载，并且在返回 MyRootView 并进入其他新的 View 时，上一个老 View 也能被释放，这就非常舒服了。 123456789101112131415162020-03-23 01:32:12.577138+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 🚩 MyRootView appear2020-03-23 01:32:26.788288+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 1️⃣ FirstCoordinator init 🟢2020-03-23 01:32:26.788380+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 1️⃣ FirstView init 🟢2020-03-23 01:32:26.811396+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------1️⃣ FirstView appear-------2020-03-23 01:32:57.753106+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 🚩 MyRootView appear2020-03-23 01:32:57.969867+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------1️⃣ FirstView disappear-------2020-03-23 01:33:00.826847+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 2️⃣ SecondCoordinator init 🟢2020-03-23 01:33:00.826983+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 2️⃣ SecondView init 🟢2020-03-23 01:33:00.831038+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 1️⃣ FirstCoordinator deinit 🔴2020-03-23 01:33:00.850590+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------2️⃣ SecondView appear-------2020-03-23 01:33:04.745348+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 🚩 MyRootView appear2020-03-23 01:33:05.011015+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------2️⃣ SecondView disappear-------2020-03-23 01:33:06.126583+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 3️⃣ ThirdCoordinator init 🟢2020-03-23 01:33:06.126716+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 3️⃣ ThirdView init 🟢2020-03-23 01:33:06.130353+0800 ZegoExpressExample-iOS-Swift[76407:18927258] 2️⃣ SecondCoordinator deinit 🔴2020-03-23 01:33:06.149465+0800 ZegoExpressExample-iOS-Swift[76407:18927258] ---------3️⃣ ThirdView appear------- 参考资料 https://twitter.com/chriseidhof/status/1144242544680849410 https://stackoverflow.com/questions/57594159/swiftui-navigationlink-loads-destination-view-immediately-without-clicking","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"https://paaatrick.com/tags/Swift/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://paaatrick.com/tags/SwiftUI/"}]},{"title":"详解 YUV 格式（I420/YUV420/NV12/NV12/YUV422）","slug":"yuv-pixel-formats","date":"2020-01-26T06:30:16.000Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"2020-01-26-yuv-pixel-formats/","link":"","permalink":"https://paaatrick.com/2020-01-26-yuv-pixel-formats/","excerpt":"YUV （Y&#39;CbCr）是一种像素格式，常见于视频编码与静态图像。与 RGB 格式（红-绿-蓝）相反，YUV 分别由一个称为 Y（相当于灰度）的“亮度”分量（Luminance or Luma）和两个称为 U（蓝色投影 Cb）和 V（红色投影 Cr）的“色度”分量（Chrominance or Chroma）表示，由此得名。 仅有 Y 分量而没有 UV 分量信息，一样可以显示完整的黑白（灰度）图像，解决了模拟信号电视黑白与彩色的兼容问题。","text":"YUV （Y&#39;CbCr）是一种像素格式，常见于视频编码与静态图像。与 RGB 格式（红-绿-蓝）相反，YUV 分别由一个称为 Y（相当于灰度）的“亮度”分量（Luminance or Luma）和两个称为 U（蓝色投影 Cb）和 V（红色投影 Cr）的“色度”分量（Chrominance or Chroma）表示，由此得名。 仅有 Y 分量而没有 UV 分量信息，一样可以显示完整的黑白（灰度）图像，解决了模拟信号电视黑白与彩色的兼容问题。 采样色度通道（UV）的采样率可以低于亮度通道（Y），而不会显着降低感知质量。一种称为 “A:B:C” 的表示法用于描述相对于 Y 采样， U 和 V 的频率： 4:4:4 表示不降低色度（UV）通道的采样率。每个 Y 分量对应一组 UV 分量。 4:2:2 表示 2:1 水平下采样，没有垂直下采样。每两个 Y 分量共享一组 UV 分量。 4:2:0 表示 2:1 水平下采样，同时 2:1 垂直下采样。每四个 Y 分量共享一组 UV 分量。 4:1:1 表示 4:1 水平下采样，没有垂直下采样。每四个 Y 分量共享一组 UV 分量。4:1:1 采样比其他格式少见，本文不再详细讨论。 下图显示了如何针对每个下采样率采样色度。亮度样本用十字表示，色度样本用圆圈表示。 存储格式YUV 在存储上通常分为平面格式（Planar），半平面格式（Semi-Planar）以及打包格式（Packed）。 Planar 平面格式平面格式有时也称为三面格式（Triplanar），即 Y, U, V 三个分量各自使用单独的数组保存，这种三平面分离的格式比较方便视频编码。 YU12 (I420) 4:2:0 Formats, 12 Bits per Pixel, 3 Planars FOURCC I420 YU12 即 I420，也叫 IYUV，属于 YUV420P 格式。三个平面，分别存储 Y U V 分量。每四个 Y 分量共享一组 UV 分量。U、V 平面的 strides, width 和 height 都是 Y 平面的一半，因此一个像素 12 bits，内存排列如下图所示： 从图中可看出，U、V 平面的每行字节数（strides）、高（height）都是 Y 平面的一半。 I420 是音视频开发中常用的一种格式。 YV12 4:2:0 Formats, 12 Bits per Pixel, 3 Planars FOURCC YV12 YV12 与 I420 几乎一样，仅改变了 U, V 平面的顺序。内存排列如下图所示： J420 4:2:0 Formats, 12 Bits per Pixel, 3 Planars J420 与 I420 完全相同，但具有完整范围（0-255，full range）的亮度（Y）分量，而不是有限范围（16-240，limited range，在 iOS 上也叫做 video range）。色度（UV）分量与 I420 中的完全相同。 IMC1 4:2:0 Formats, 16 Bits per Pixel, 3 Planars FOURCC IMC1 IMC1 与 I420 类似，U, V 平面的宽（width）、高（height）是 Y 平面的一半，但是每行字节数（strides）与 Y 平面一致，因此 U, V 平面在内存上会有留空（padding），因此一个像素 16 bits，如图所示： IMC3 4:2:0 Formats, 16 Bits per Pixel, 3 Planars IMC3 与 IMC1 几乎一样，仅改变了 U, V 平面的顺序。内存排列如下图所示： I422 4:2:2 Formats, 16 Bits per Pixel, 3 Planars I422 属于 YUV422P 格式。三个平面，分别存储 Y U V 分量。每两个 Y 分量共享一组 UV 分量。U、V 平面的 strides, width 是 Y 平面的一半，但 height 与 Y 平面一致，因此一个像素 16 bits，内存排列如下图所示： 从图中可看出，U、V 平面的每行字节数（strides）是 Y 平面的一半，高（height）与 Y 平面一致。 J422 4:2:2 Formats, 16 Bits per Pixel, 3 Planars J422 与 I422 完全相同，但具有完整范围（0-255，full range）的亮度（Y）分量，而不是有限范围（16-240，limited range，在 iOS 上也叫做 video range）。色度（UV）分量与 I420 中的完全相同。 Semi-Planar 半平面格式半平面格式具有两个平面而不是三个平面，一个平面存储亮度（Y）分量，另一个平面存储两个色度（UV）分量。有时也将它们称为双平面格式（BiPlanar）。 NV12 4:2:0 Formats, 12 Bits per Pixel, 2 Planars FOURCC NV12 NV12 属于 YUV420SP 格式。两个平面，分别存储 Y 分量 和 UV 分量。其中 UV 分量共用一个平面并且以 U, V, U, V 的顺序交错排列。每四个 Y 分量共享一组 UV 分量。 UV 平面的 strides, width 与 Y 平面一样长，但 height 仅为 Y 平面的一半。因此一个像素 12 bits，内存排列如下图所示： 从图中可看出，UV 平面的每行字节数（strides）与 Y 平面一致，高（height）是 Y 平面的一半。 NV12 是 iOS 相机（AVCaptureOutput）可直接输出的两种视频帧格式之一，另外一种是 BGRA32(kCVPixelFormatType_32BGRA)。 在 iOS 上，NV12 还分为 Full Range (0-255, kCVPixelFormatType_420YpCbCr8BiPlanarFullRange) 和 Video Range (16-240, kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange)，区别仅为亮度（Y）分量的取值范围，一般而言，Full Range 适用于静态图像（拍照），Video Range 适用于视频采集（摄像）。 NV21 4:2:0 Formats, 12 Bits per Pixel, 2 Planars FOURCC NV21 NV21 属于 YUV420SP，与 NV12 几乎一致，区别是 UV 平面中 U 与 V 的排列顺序颠倒，以 V, U, V, U 的顺序交错排列，内存排列如图所示： NV21 是 Android 相机（Camera）默认的输出格式。 Packed 打包格式打包格式通常只有一个平面，所有亮度（Y）和色度（UV）数据都交织在一起。有点类似于 RGB 格式，只是使用了不同的色彩空间。 打包格式在网络摄像头中较为常见。硬件设备使用多平面格式效率较低，因为每个像素需要多次内存访问。而打包格式由于仅一个平面，访问内存的开销较小。 AYUV 4:4:4 Formats, 32 Bits per Pixel FOURCC AYUV AYUV 是 Packed 打包格式，其中每个像素编码为四个连续字节，每个像素在内存中按照 V, U, Y, A 的顺序排列（A 指 alpha 通道），如下图所示： YUYV (V422 / YUY2 / YUNV) 4:2:2 Formats, 16 Bits per Pixel FOURCC YUY2 YUYV 通常也称作 V422、YUY2、YUNV YUY2 是 Packed 打包格式，其中两个像素共用一组 UV 分量，内存中按照 Y U Y V 的顺序排列，如下图所示： UYVY (Y422 / UYNV) 4:2:2 Formats, 16 Bits per Pixel FOURCC UYVY UYVY 通常也称作 Y422、UYNV UYVY 与 YUYV 类似，只是亮度（Y）分量与色度（UV）分量排列顺序颠倒，如下图所示： 参考资料 Microsoft: Recommended 8-Bit YUV Formats for Video Rendering VideoLAN’s Wiki: YUV FOURCC: YUV pixel formats WWDC2011: Capturing from the Camera using AV Foundation on iOS 5","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"Audio/Video","slug":"Audio-Video","permalink":"https://paaatrick.com/tags/Audio-Video/"}]},{"title":"杂谈网络协议之种子与P2P","slug":"network-protocol-p2p","date":"2019-07-07T04:15:17.000Z","updated":"2021-11-07T12:02:15.283Z","comments":true,"path":"2019-07-07-network-protocol-p2p/","link":"","permalink":"https://paaatrick.com/2019-07-07-network-protocol-p2p/","excerpt":"最近学了些P2P协议相关的内容，做了些笔记。","text":"最近学了些P2P协议相关的内容，做了些笔记。 P2PP2P 即 peer-to-peer，为了解决 HTTP 或 FTP 下载文件时难以解决单一服务器带宽压力的缺点。P2P 的特点是资源开始并不集中地存储在某些设备上，而是分散地存储在多台设备上，而是分散地存储在多台设备上。这些设备我们姑且称为 peer。 想要下载一个文件的时候，只需得到那些已经存在了文件的 peer，并和这些 peer 之间，建立点对点的连接，而不需要到中心服务器上，就可以就近下载文件。一旦下载了文件，你也就成为 peer 中的一员，你旁边的那些机器，也可能会选择从你这里下载文件，所以当你使用 P2P 软件的时候，例如 BitTorrent，往往能够看到，既有下载流量，也有上传的流量，也即你自己也加入了这个 P2P 的网络，自己从别人那里下载，同时也提供给其他人下载。 美国工程师 Bram Cohen 在 2001 年发布了 BitTorrent 协议，资源不再由一个人或一个中心服务器提供，而是所有人提供给所有人，下载的人越多，速度越快。 BitTorrent 的核心思想是把文件分成很多个小块，让下载者互相连接。协议需要资源共享者生成一个包含下载信息的种子文件，后缀是 .torrent，即 BT 种子。 torrent.torrent 种子文件由两部分组成，分别是：announce（tracker URL）和文件信息 文件信息包含文件的名字、大小，分块后每块文件的大小、哈希值等，具体如下： info 区：指定的是种子文件数量、文件大小、目录结构、目录和文件的名字 Name 字段：指定顶层目录名字。 每个段的大小：BitTorrent 协议把文件分成很多个小段 段哈希值：整个种子中，每个段的 SHA-1 哈希值拼在一起 下载时，BT 客户端首先解析.torrent 文件，得到 Tracker 地址，然后连接 Tracker 服务器。 Tracker 很重要，通过 Tracker 我们才能找到其他下载者的联系方式。当你用下载软件打开种子，就会开始联系种子文件里内置的 Tracker 服务器，告诉 Tracker 我要下载这个文件，服务器会记录下你的 IP，并把其他正在下载或下载完成的人的 IP 返回给你，这样你们就可以愉快的组队下载了。 Tracker 服务器回应下载者请求，将其他下载者包括发布者的 IP 提供给下载者。下载者再连接其他下载者，根据种子文件，双方互相告知自己已经有的块，然后交换对方没有的数据。此时不需要其他服务器参与，并分散了单个线路上的数据流量，减轻服务器负担。 下载者每得到一个块，需要算出下载块的 Hash 验证码，并与.torrent 文件中的对比。如果一样，则说明块正确，不一样则需要重新下载这个块。这种规定是为了解决下载内容的准确性问题。 当然，如果没有找到正在下载的人，资源发布者也不在线，你就只能以 0kb/s 的速度等着了。 不难发现，Tracker 服务器是 P2P 网络的弱点，如果 Tracker 被关闭或封禁，你就无法找到同伴，也难以完成下载，BT 依然是中心化的协议。 DHT 去中心化网络为了摆脱对 Tracker 服务器的依赖，彻底去中心化，于是产生了一种叫做 DHT（Distributed Hash Table）的去中心化网络，每个加入 DHT 网络的人，都要负责存储这个网络里的资源信息和其他成员的联系信息，相当于所有人一起构成了一个庞大的分布式存储数据库。 DHT 的本质是把所有人都变成一个小型 Tracker，每个人都拿着一份动态更新的地址和文件信息。我找与我连接的 10 个人，他们再各自找 10 个人，一传十十传百、千、万，最后我通过N个人的中转，找到应该连上的人。 有一种著名的 DHT 协议：Kademlia。任何一个 BitTorrent 启动之后，它都有两个角色。一个是 peer，监听一个 TCP 端口，用来上传和下载文件，这个角色表明，我这里有某个文件。另一个角色 DHT node，监听一个 UDP 的端口，通过这个角色，这个节点加入了一个 DHT 的网络。 在 DHT 网络中，每个 DHT node 都有一个很长的 ID 字符串。每个 DHT node 都有责任掌握一些知识，即文件索引，即它应该知道某些文件是保存在哪些节点上。它只需要有这些知识就行，自己本身不一定就是保存这个文件的节点。node 应该知道哪些知识是通过哈希算法计算出来。 每个文件都有一串通过 SHA1 哈希算法计算出唯一的文件 ID，可以产生 2 的 (4*40) 即 2 的 160 次方种组合，用只有 0 和 1 的二进制表示就是 160 个 0 和 1。 而每个节点也有一串 160 位的 0 和 1，作为节点 ID。根据这 160 位数，我们可以计算节点和节点之间，节点和资源之间的距离。 在 Kademlia 网络中，距离是通过异或（XOR）计算的。以5位举例，01010 与 01000 的距离，就是两个 ID 之间的异或值，为 00010，也即为 2。 01010 与 00010 的距离为 01000，也即为 8。01010 与 00011 的距离为 01001，也即 8+1=9。以此类推，高位不同的，表示距离更远一些；低位不同的，表示距离更近一些，总的距离为所有的不同的位的距离之和。 有个理论是，社交网络中，任何两个人直接的距离不超过六度，也即你想联系比尔盖茨，也就六个人就能够联系到了。 假设小明发布了一个文件，就能计算他所知道的节点 ID 与这个文件 ID 的距离，让算出来最距离最短的节点再计算它知道的节点和文件 ID 的距离，重复这个过程，就能找到与文件 ID 的距离最短的一批节点 ID，把小明提供的下载信息存在这里。 这样，下载者也只要找到和文件 ID 距离接近的节点 ID，就能建立连接，开始下载。 DHT 网络如何维护就像人一样，虽然我们常联系人的只有少数，但是朋友圈里肯定是远近都有。DHT 网络的朋友圈也是一样，远近都有，并且按距离分层。 假设某个节点的 ID 为 01010，如果一个节点的 ID，前面所有位数都与它相同，只有最后 1 位不同。这样的节点只有 1 个，为 01011。与基础节点的异或值为 00001，即距离为 1；对于 01010 而言，这样的节点归为“k-bucket 1”。 如果一个节点的 ID，前面所有位数都相同，从倒数第 2 位开始不同，这样的节点只有 2 个，即 01000 和 01001，与基础节点的异或值为 00010 和 00011，即距离范围为 2 和 3；对于 01010 而言，这样的节点归为“k-bucket 2”。 如果一个节点的 ID，前面所有位数相同，从倒数第 i 位开始不同，这样的节点只有 2^(i-1) 个，与基础节点的距离范围为 [2^(i-1), 2^i)；对于 01010 而言，这样的节点归为“k-bucket i”。 最终到从倒数 160 位就开始都不同。差距越大，陌生人越多，但是朋友圈不能都放下，所以每一层都只放 K 个，这是参数可以配置。 DHT 网络节点的查找假设，node A 的 ID 为 00110，要找 node B ID 为 10000，异或距离为 10110，距离范围在 [2^4, 2^5)，所以这个目标节点可能在“k-bucket 5”中，这就说明 B 的 ID 与 A 的 ID 从第 5 位开始不同，所以 B 可能在“k-bucket 5”中。 然后，A 看看自己的 k-bucket 5 有没有 B。如果有就找到了；如果没有，在 k-bucket 5 里随便找一个 C。因为是二进制，C、B 都和 A 的第 5 位不同，那么 C 的 ID 第 5 位肯定与 B 相同，即它与 B 的距离会小于 2^4，相当于比A、B 之间的距离缩短了一半以上。 再请求 C，在它自己的通讯录里，按同样的查找方式找一下 B。如果 C 知道 B，就告诉 A；如果 C 也不知道 B，那 C 按同样的搜索方法，可以在自己的通讯录里找到一个离 B 更近的 D 朋友（D、B 之间距离小于 2^3），把 D 推荐给 A，A 请求 D 进行下一步查找。 Kademlia 的这种查询机制，是通过折半查找的方式来收缩范围，对于总的节点数目为 N，最多只需要查询 log2(N) 次，就能够找到。 DHT 网络节点之间的沟通Kademlia 算法中，每个节点只有 4 个指令。 PING：测试一个节点是否在线。 STORE：要求一个节点存储一份数据。 FIND_NODE：根据节点 ID 查找一个节点 FIND_VALUE：根据 KEY 查找一个数据，与 FIND_NODE 类似 DHT 网络的更新每个 bucket 里的节点，都按最后一次接触的时间倒序排列，这就相当于，朋友圈里面最近联系过的人往往是最熟的。 每次执行四个指令中的任意一个都会触发更新。 当一个节点与自己接触时，检查它是否已经在 k-bucket 中，也就是说是否已经在朋友圈。如果在，那么将它挪到 k-bucket 列表的最底，也就是最新的位置，刚联系过，就置顶一下，方便以后多联系；如果不在，新的联系人要不要加到通讯录里面呢？假设通讯录已满的情况，PING 一下列表最上面，也即最旧的一个节点。如果 PING 通了，将旧节点挪到列表最底，并丢弃新节点，老朋友还是留一下；如果 PING 不通，删除旧节点，并将新节点加入列表，这人联系不上了，删了吧。 这个机制保证了任意节点加入和离开都不影响整体网络。 磁力链接今天最流行的下载方式是磁力链接（Magnet URI scheme）就是基于 DHT 网络的，通常是一串这样的神秘代码： 前面都是标准格式，最重要的是这 40 个 16 进制的数字即 160 位 2 进制数字。任何文件丢进 SHA1 哈希算法都能得到一串这样字符，40 位、16 进制、只属于这个文件，它能帮我们找到我们要下载的东西。 根据上面讲的 DHT，只需要一串文件 ID 和存储在本地的 K 桶数据，你就可以高效的找到要下载的文件。而资源的发布者和传播者也只需要分享 40 个数字就好，足够简单，方便和隐私。 在真实的 DHT 网络，每个 K 桶至少记录了 8 个节点，任何一个节点下线，都不会影响整个网络的运行。 作为文件和节点 ID ，2 的 160 次方也足够大，大到全地球 70 亿人每秒下载 10000 个种子，也足够下载百万亿年直到宇宙终结。 这些天才们的设计，让我们拥有了一个无法被审查和追踪的去中心化网络。这催生了庞大的盗版产业，但也让很多内容有机会避开审查。 因为网站可以被隔离、被拔线、被禁止访问，但种子不会。只要种子不死，那些不存在的音乐图书和视频就还活在互联网上，没有任何人可以毁掉。 小结 下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下的方式，而 P2P 则换了一种思路，采取非中心化下载的方式； P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基于分布式的哈希算法，元数据和文件数据全部分散。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"NetworkProtocol","slug":"NetworkProtocol","permalink":"https://paaatrick.com/tags/NetworkProtocol/"}]},{"title":"杂谈网络协议之 TCP/IP","slug":"network-protocol-ip-tcp-udp","date":"2019-06-06T01:13:26.000Z","updated":"2021-11-07T12:02:15.282Z","comments":true,"path":"2019-06-06-network-protocol-ip-tcp-udp/","link":"","permalink":"https://paaatrick.com/2019-06-06-network-protocol-ip-tcp-udp/","excerpt":"最近学了些TCP/IP相关的内容，做了些笔记。","text":"最近学了些TCP/IP相关的内容，做了些笔记。 关于HTTP(S)、TLS的内容链接 网络分层 网络分层的原因 复杂的程序都需要分层，各层次之间是独立的 某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务，这样能降低问题的复杂度，上层工作不影响下层的工作 易与多人协作，易与实现和维护，促进标准化工作 只要是在网络上跑的包，都是完整的，可以有下层没上层，绝不可能有上层没下层 对于TCP来说，只要想发出去包，就必须要有IP层和MAC层 网络如何分层 一般有五层模型和七层模型，按个人理解，七层模型只是把五层模型最上层的应用层给细化了 物理层(中继器、集线器、HUB、网线) 数据链路层(MAC) 网络层(IP) 传输层(TCP/UDP) 应用层(HTTP(S)) 网络分层运行的过程 接收过程 当一个包经过网口时，首先看看要不要请进来处理一下（配置了混杂模式的网口，凡是经过的都拿进来），拿进来以后交给一段程序处理，于是调用process_layer2(buffer)，当然这是假函数，但你知道肯定有类似功能的函数的，这个函数功能是从buffer中摘掉二层（MAC）的头查看。 假如发现这个包的MAC地址与自己相符，说明是发给你的，于是调用process_layer3(buffer)，摘掉三层（IP）的头查看，如果IP地址不是自己的，就应该转发出去，如果IP地址是自己的，就根据IP头的指示，拿掉三层的头，进程下一层的处理，如果地址是TCP的，调用process_tcp(buffer)，如果是UDP的调用process_udp(buffer)。 假设是TCP的，调用process_tcp(buffer)，查看四层的头，看是一个发起，还是应答，或者是一个正常的数据包，分别交给不同的逻辑处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。交给谁呢？是不是有 process_http(buffer) 函数呢？ 没有的，如果你是一个网络包处理程序，你不需要有process_http(buffer)，而是应该交给应用去处理。交给哪个应用呢？在四层的头里面有端口号，不同的应用监听不同的端口号。如果发现浏览器应用在监听这个端口，那你发给浏览器就行了。至于浏览器怎么处理，和你没有关系。 浏览器自然是解析 HTML，显示出页面来。电脑的主人看到页面很开心，就点了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起另一个 HTTP 请求了，于是使用端口号，将请求发给了你。 发送过程 收到了一个封装好的HTTP包后，首先调用send_tcp(buffer)，buffer里就是HTTP请求的内容，这个函数里面加一个TCP的头，记录下浏览器给的源端口号，一般是80（HTTPS就443）。 然后调用send_layer3(buffer)，buffer里面已经有了HTTP的头和内容，以及TCP的头，这个函数里面加一个IP的头，记录下源IP地址和目标IP地址。 然后调用send_layer2(buffer)，buffer里面已经有了HTTP的头和内容、TCP的头，以及IP的头，这个函数里面加一个MAC的头，记录源MAC地址，得到的就是本机器的 MAC 地址和目标的 MAC 地址。不过，这个还要看当前知道不知道，知道就直接加上；不知道的话，就要通过一定的协议处理过程，找到 MAC 地址。反正要填一个，不能空着。 只要buffer里面的内容完整，就可以从网口发出去了。 数据链路层 MAC MAC的全称是Medium Access Control，即媒体访问控制。 以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。 前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。 一块网卡获取另一块网卡MAC地址的方式：ARP协议，当已知IP时请求MAC地址 ARP的工作方式：广播，向同个子网络内所有计算机发送数据包，让每台计算机自己判断自己是否为接收方 网络层 IP ARP寻找MAC的广播方式只能在子网络内使用，每个子网络之间通信需要IP协议 Linux 上查看IP地址的命令：ifconfig 和 ip addr、没有的话自行安装net-tools和iproute2 IP地址 IPv4的网络地址由32个二进制位组成 IP 地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码 CIDR 32位的IP地址分成了5类，但因为太浪费了，所以使用CIDR CIDR代替ABC类分配IP地址段，注意私有IP段，CIDR伴随广播地址和子网掩码 IP的作用 IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 从IP得到MAC的方式 因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的，但是我们不知道它的MAC地址。分两种情况 如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。 如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。 DHCP请求IP地址，DHCP附送PXE协议安装OS ICMP 和 ping ping 是基于 ICMP 工作的，ICMP全称Internet Control Message Protocol，就是互联网控制报文协议。 ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。 查询报文 ping 就是ICMP的查询报文，是一种主动请求，并获得主动应答的ICMP协议，不过ping在ICMP后面增加了自己的格式 ping 主动请求的发送：ICMP ECHO REQUEST ping 主动请求的回复：ICMP ECHO REPLY 比原生ICMP多了两个字段：标识符、序号，以及可选存放请求的时间值，可计算往返时间 差错报文 终点不可达：3，分为网络不可达、主机不可达、协议不可达、端口不可达、需要进行分片但设置了不分片等 源抑制：4，让源站放慢发送速度 超时：11，超过网络包的生存时间还没到达目标 重定向：5，让下次发给另一个路由器 ping 的发送和接收过程 可以看出ping是使用\b了ICMP里的ECHO REQUEST和ECHO REPLY TTL (TimeToLive) 在IPv4中, TTL是IP协议的一个8个二进制位的值(0-255)，这个值可以被认为是数据包在internet系统中可以跳跃的次数上限。 TTL是由数据包的发送者设置的, 在前往目的地的过程中, 每经过一台主机或设备, 这个值就要减少一点。 如果在数据包到达目的地前, TTL值被减到了0，那么这个包将作为一个ICMP错误的数据包被丢弃。 差错报文的应用Traceroute Traceroute 故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器 对目的IP地址发送UDP包，设置TTL为1，即到达第一个路由就挂掉了，然后返回一个ICMP差错报文包，类型是超时 然后设置TTL为2，继续到第二个路由就挂了，返回超时，逐步迭代这个过程取得整个路径上的路由IP和延迟 有些路由不会回复这个ICMP，这就是Traceroute返回内容部分空白的原因 另外一个作用是故意设置不分片，从而确定路径的MTU TCP 和 UDP 的区别 TCP 面向连接，UDP 面向无连接 TCP 提供可靠交付，UDP 不可靠 TCP 连接传输的数据，无差错，不丢失，不重复，按序到达 UDP 继承 IP 包的特性，不保证不丢失，不保证按顺序到达 TCP 基于字节流，UDP 基于数据报 TCP 发送的时候是一个流，没头没尾 虽然 IP 包是一个个的 IP 包，TCP 自己维护成了流 UDP 继承了 IP 的特性，基于数据报，一个个地发，一个个地收 TCP 有拥塞控制， UDP 没有 TCP 意识到包丢失或者网络环境差后，根据情况调整行为，调节发送速度 UDP 没有意识，应用叫发包就发 TCP 是有状态服务，UDP 是无状态服务 TCP 精确记录了发送、接收状态 UDP 不记录状态 UDPUDP 包头格式 源端口号 | 目的端口号 16位UDP长度 | 16位UDP校验和 数据 UDP 特点 沟通简单，认为网络通路默认就是很容易送达的，不容易被丢弃的 轻信他人， 不会建立连接，虽然有端口号，但是监听后任何人都能发数据给他，他也可以发数据给任何、任意多人 愣头青，不会根据网络情况进行发包的拥塞控制，无论丢包成什么样还是该怎么发就怎么发 UDP 使用场景 需要资源少，网络环境好的内网，或对丢包不敏感的应用。如 DCHP 和 TFTP 就是基于 UDP 协议的，因为BIOS资源少不适合维护TCP那种复杂的状态机 不需要一对一沟通建立连接，而是可以广播的应用。UDP 面向无连接的功能可以承载广播或者多播的协议，基于 UDP 的 DHCP 就是广播的形式 需要处理速度快，时延低，可容忍少数丢包，但即便网络拥塞也要不停歇发包的应用。比如网络直播，用户不关心过时数据，老数据丢了也就丢了，但不能因为拥塞而停歇了 UDP 使用例子 网页或者App的访问 QUIC协议 移动互联，网络经常变换，TCP会经常重连很耗时，基于UDP的QUIC就比较合适 流媒体协议 TCP 的严格顺序传输不适合直播，用户不在意老数据而是要实时性，宁可丢包也不要卡顿 很多直播应用基于 UDP 实现自己的视频传输协议 实时游戏 游戏的实时性要求很高，而且服务器需要沟通很多客户端（玩家），在异步IO机制引入之前，UDP是应对海量客户端连接的策略 TCP的强顺序问题，对战游戏对网络要求简单，如FPS只需传输玩家位置和行为等，客户端解析响应并渲染场景，玩家并不关心过期数据，如果一个数据包丢失导致卡顿，下一秒就被爆头了。用UDP自定义可靠协议，自定义重传策略，能尽量降低延迟，减少网络问题对游戏性能的影响 IoT 物联网 物联网设备终端资源少，维护TCP开销太大 物联网对实时性要求高，TCP容易导致高延迟 Google子公司推出的物联网通信协议 Thread 就是基于 UDP 的 移动通信领域 4G 网络的数据协议 GTP-U 是基于 UDP 的 UDP 小结 如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；TCP 维护连接，UDP 谁都相信；TCP 会坚持知进退；UDP 愣头青一个，勇往直前； UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。 TCP TCP的seq是32位的计数器，每4微秒加1，计算可知284分钟即4.73小时重置一次 TCP 包头格式 源端口号 | 目标端口号 包序号:seq 确认序号:ack 首部长度 | 保留 | URG | ACK | PSH | RST | SYN | FIN | 16位窗口大小 校验和 | 紧急指针 选项 数据本体 首先与UDP一样是源端口和目标端口号，用于确定发给哪个应用 seq序号解决乱序问题，确定每个包的先来后到，是个32位的计数器，每4微秒加1，计算可知284分钟即4.73小时重置一次 ack的值是对方发来的TCP包内seq的值+1，解决不丢包问题 状态位，SYN是发起连接，ACK是回复，RST是重新连接，FIN是结束连接，这是TCP面向连接的体现，维护连接状态，这些带状态位的包的发送会引起双方的状态变更 窗口大小，做流量控制，双方各自声明一个窗口，标识自己当前的处理能力，不要发送得太快也别太慢 TCP 的特征 顺序问题，稳重不乱； 丢包问题，承诺靠谱； 连接维护，有始有终； 流量控制，把握分寸； 拥塞控制，知进知退。 三次握手四次挥手 三次握手 ① A：您好，我是 A ② B：您好 A，我是 B ③ A：您好 B TCP连接的建立称为三次握手，“请求 -&gt; 应答 -&gt; 应答之应答”，让双方的消息都“有去有回” 第三次握手\b，A应答B的应答包，能解决一个问题：B收到了来自很久之前A的多次申请连接的SYN包，如果两次握手，B这时建立了连接就等于单相思，所以需要“应答之应答” 为什么不四次握手？因为就算40次握手也不能真正保证连接就建立了，只要双方都有去有回就基本认为建立了，并且一般A和B连接建立后就开始发数据，一但A方开始发送数据，问题就解决了 如果连接建立后A一直不发数据，这个在HTTP有keepalive机制，即使没有真实数据包也有探活包 B也可以设计对于长时间不发包的A主动关闭连接 大写ACK与小写ack的区别：大写的是状态位，当为1时表示包是回复包，小写是确认序号，值是对方的序号seq+1 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。 四次挥手 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号 服务器B关闭与客户端A的连接，发送一个FIN给客户端A 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1 上面2与3的过程中，B可能还有要发给A的数据没发送完，就首先ACK了A的FIN后，等处理完数据后再发送FIN给A，所以一共需要4次挥手。 白话解释四次挥手 ① A：B 啊，我不想玩了 ② B：哦，你不想玩了啊，我知道了 ③ B：A 啊，好吧，我也不玩了，拜拜 ④ A：好的，拜拜。 A 开始说“不玩了”，B 说“知道了”，这个回合是没什么问题的，因为在此之前，双方还处于合作的状态，如果 A 说“不玩了”，没有收到回复，则 A 会重新发送“不玩了”。但是这个回合结束之后，就有可能出现异常情况了，因为已经有一方率先撕破脸。 一种情况是，A 说完“不玩了”之后，直接跑路，是会有问题的，因为 B 还没有发起结束，而如果 A 跑路，B 就算发起结束，也得不到回答，B 就不知道该怎么办了。另一种情况是，A 说完“不玩了”，B 直接跑路，也是有问题的，因为 A 不知道 B 是还有事情要处理，还是过一会儿会发送结束。 断开的时候，我们可以看到，当 A 说“不玩了”，就进入 FIN_WAIT_1 的状态，B 收到“A 不玩”的消息后，发送知道了，就进入 CLOSE_WAIT 的状态。 A 收到“B 说知道了”，就进入 FIN_WAIT_2 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状态。TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 tcp_fin_timeout 这个参数，设置一个超时时间。 如果 B 没有跑路，发送了“B 也不玩了”的请求到达 A 时，A 发送“知道 B 也不玩了”的 ACK 后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是最后的这个 ACK 万一 B 收不到呢？则 B 会重新发一个“B 不玩了”，这个时候 A 已经跑路了的话，B 就再也收不到 ACK 了，因而TCP 协议要求 A 最后等待一段时间 TIME_WAIT，这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B。 A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来 B 发送的所有的包都死翘翘，再空出端口来。 等待的时间设为 2MSL，MSL是Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个TTL 域，是 IP 数据报可以经过的最大路由数，每经过一一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。 还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。 TCP 状态机 把上面两个时序图合并起来就是这个TCP状态机图 加黑加粗的部分是主要流程，阿拉伯数字的序号是连接建立的顺序，大写中文数字的序号是连接断开的顺序。加粗实线是客户端A的状态变化过程，加粗虚线是服务端B的状态变化过程。细虚线是其他非主流过程。 TCP 的顺序机制 每个包都有一个ID，按照ID一个个发送 累计确认（累计应答） 发送端和接收端分别有缓存保存记录所有发送和接收的包 发送端窗口 发送端的缓存里是按照包ID排列的，有四种类型 发送了且已确认 发送了且尚未确认 还没发送但等待发送 还没发送且暂时不会发送 上面3和4的区分是流量控制 流量控制使用窗口（Advertised Window），窗口大小等于上面2+3部分，即发送未确认和未发送但可发送的 LastByteAcked：第一部分和第二部分的分界线 LastByteSent：第二部分和第三部分的分界线 LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线 接收端窗口 接收端的缓存里是按照包ID排列的，有三种类型 接收且确认过 尚未接收但可接收 尚未接收且不能接收 流量控制使用窗口（AdvertisedWindow），窗口大小是上面第2部分，需要计算 MaxRcvBuffer：最大缓存的量； LastByteRead 之后是已经接收了，但是还没被应用层读取的； NextByteExpected 是第一部分和第二部分的分界线。 NextByteExpected 和 LastByteRead 的差其实是还没被应用层读取的部分占用掉的 MaxRcvBuffer 的量，我们定义为 A。 AdvertisedWindow 其实是 MaxRcvBuffer 减去 A，即第2部分的大小 也就是：AdvertisedWindow = MaxRcvBuffer - ((NextByteExpected-1) - LastByteRead)。 第2部分和第3部分的分界线就是 NextByteExpected + AdvertisedWindow，即 LastByteRead + MaxRcvBuffer TCP 的丢包重发机制 确认与重发机制 超时重试，没有ACK的包都有设一个定时器，超过一定时间就重新尝试 超时时间需要大于往返时间 RTT，也不宜过长 自适应重传算法 TCP 通过采样 RTT 时间和 RTT 的波动范围，进行加权平均，算出一个值，还需要根据新状况不断变化 超时触发重传的问题是超时周期可能很长 快速重传机制 当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。 还有一种方式 SACK (Selective Acknowledgment)，在TCP头里加一个SACK，可以把可以将缓存的地图发送给发送方。 TCP 的流量控制机制 如果发送方发送太猛，接收方处理不过来导致缓存中没有空间，可以通过确认信息修改窗口大小，甚至设为0，使发送方暂时停止发送 当发送方发现自己窗口被调整到0后，会定时发送窗口探测数据包，看是否有机会调整窗口大小 当接收方比较慢时，要防止低能窗口综合征，避免空出一个字节就通知发送方然后又填满窗口。当窗口太小时，可以暂停更新窗口，直到窗口达到一定大小或者缓冲区一半为空，才更新窗口 TCP 的拥塞控制机制 也是通过窗口大小控制，滑动窗口 rwnd 是怕发送方把接收方缓存占满，拥塞窗口 cwnd 是怕把网络塞满 LastByteSent - LastByteAcked &lt;= min {cwnd, rwnd}，是拥塞窗口和滑动窗口共同控制发送的速度 发送方难以判断网络是否满的方法，在TCP看来网络路径是一个黑盒 TCP 发送包常被比喻为往一个水管里面灌水，而 TCP 的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽。 TCP 的拥塞控制主要用来避免两种现象：包丢失和超时重传 一旦出现了这些现象就说明，发送速度太快了，要慢一点。但是一开始我怎么知道速度多快呢，我怎么知道应该把窗口调整到多大呢？ 慢启动：一开始 cwnd 大小为一个报文段，当收到确认时指数型增大cwnd大小 指数型涨到一个值为65535字节的 ssthresh 时降为线性增长，每8个确认cwnd增加1，但总有溢出的时候。 当出现拥塞即丢包时，需要超时重传，ssthresh设为cwnd/2，cwnd设为1，重新开始慢启动，一夜回到解放前。 快速重传 当接收端发现丢了一个中间包时，发送三次前一个包的ACK，于是发送端就会快速重传，不必等待超时重传。 此时cwnd = cwnd / 2， sshthresh = cwnd，当三个包返回时，cwnd = sshthresh + 3 也就是不用回到解放前，只是减半而已 这种机制导致延迟高的情况下，反而降低速度，导致本文前面UDP部分里说的TCP的问题 丢包不代表通道满了，可能本身公网就是会丢包的，这时其实并没有拥塞 TCP 的拥塞控制要等到将中间设备都填充满了才发生丢包，从而降低发送速度，此时已经晚了，其实TCP只要通道满了就应该开始控制了，而不应该等到连缓存都满了才控制 解决方法：BBR 拥塞算法，找到一个平衡点，填满管道但是不填满中间设备的缓存，达到高带宽和低时延的平衡 TCP 小结 TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制 连接的建立是经过三次握手，断开的时候四次挥手 顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的 拥塞控制是通过拥塞窗口来解决的","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"NetworkProtocol","slug":"NetworkProtocol","permalink":"https://paaatrick.com/tags/NetworkProtocol/"}]},{"title":"杂谈网络协议之 HTTP、HTTPS 和 TLS","slug":"network-protocol-https","date":"2019-06-03T06:42:40.000Z","updated":"2021-11-07T12:02:15.280Z","comments":true,"path":"2019-06-03-network-protocol-https/","link":"","permalink":"https://paaatrick.com/2019-06-03-network-protocol-https/","excerpt":"最近学了些HTTP相关的内容，做了些笔记，深入了解TLS后感觉密码学挺有意思。","text":"最近学了些HTTP相关的内容，做了些笔记，深入了解TLS后感觉密码学挺有意思。 关于TCP/IP的内容链接 HTTPHTTP/0.9 这是后来回来定义的版本，这个初始版本采用纯文本格式 只有GET动作，在响应请求后立即关闭连接，功能非常有限 HTTP/1.0 1996年发布，与1.1差不了多少了 增加了HEAD、POST等方法 增加响应状态码，标记可能的错误原因 引入协议版本号概念 引入了Header头部的概念 传输的数据不再仅限于文本 但是1.0并不是一个标准，只相当于一个备忘录（参考文档） HTTP/1.1 1999年，发布RFC文档编号2616，是个正式的标准 增加了PUT、DELETE等方法 增加了缓存管理和控制 明确了连接管理，允许持久连接 允许响应数据分块（chunked），利于传输大文件 强制要求Host头，让互联网主机托管成为可能 HTTP请求报文格式 请求方法 | URL | 协议版本 Header头部（一行一个字段，key-value，中间冒号分隔） 空行 请求包体(GET没有,POST用)(GET也可以填body,服务端不一定处理) HTTP响应报文格式 协议版本 | 状态码 | 状态码描述 Header头部（一行一个字段，key-value，中间冒号分隔） 空行 响应包体 常见的Header Accept-Charset： 数据编码格式 Content-Type： 数据的类型 Cache-control：max-age，客户端的话就是希望多新的缓存，服务端的话就是告诉客户端某个时间段内的数据都是最新的 If-Modified-Since：如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最最新的资源；如果没有更新，服务端会返回304 Not Modified的响应，那客户端就不用下载了 Retry-After：告诉客户端应该在多长时间以后再次尝试一下 Connection：一般是keep-alive，用来保活TCP连接，close的话就是传输完后就关闭TCP连接 Referer：客户端告诉服务端我是从哪个链接来的，服务端收到后可以做处理，重定向，或者用于支付后的回调（微信支付） User-Agent：老生常谈，操作系统和浏览器名称版本，很多骚操作 一些特点 一般POST时，先发送header，服务器响应 100 Continue 后，浏览器再发送Data，服务器响应 200 OK，可能分两个TCP包 header是key-value，中间冒号分隔 HTTP即超文本传输协议 HyperTextTransferProtocol, 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范 HTTP没有实体，不是互联网，不是语言，不是HTML，不是孤立的协议。 HTTP是基于TCP的，TCP的重传HTTP不知道 由于有Keep-Alive机制，每次HTTP连接无需TCP重新握手 HTTP/2.0 HTTP2.0通过头压缩、分帧、多路复用等技术提升性能 SPDY是谷歌推出的，HTTP2.0基于此制定 HTTP2.0对header压缩，用索引表替代key-value，将一个TCP连接中切分多个流。 每个流有自己ID，流是双向的虚拟通道，流有优先级。2.0还将所有信息分割为帧。 有header帧和data帧，用二进制编码，多个data帧属于同一个流。 这样可以将多个请求分到不同的流中，将请求内容拆成帧，进行二进制传输。 帧可以打散乱序发送，然后根据每个帧首部的流标识符重新组装，并根据优先级决定先处理哪个流。 HTTP2.0其实是将n个请求变成n个流，将数据分成帧，乱序发送到一个TCP连接中。 这样2.0解决了1.1的队首阻塞问题。1.1通过pipeline用多条TCP实现并发，2.0只用1个TCP实现并发，提高性能。 但HTTP2.0还是基于TCP的，TCP处理包时有严格顺序，前面流2的帧没收到，后面流1的帧也会阻塞 QUIC QUIC是谷歌基于UDP改进的应用层，未来HTTP3.0可能基于此实现，解决HTTP2.0的问题，QUIC也是面向连接的。 QUIC自定义类似TCP的连接、重试、多路复用、流量控制技术，进一步提升性能 机制1：自定义连接 一条TCP连接是四元组（源IP和端口,目标IP和端口）标识的，一旦一个元素变化就需要断开重连 移动互联经常不稳定、切换，都会导致重连，又三次握手，时延高 而基于UDP的QUIC自己用64位随机数作为标识替代四元组，而且UDP是无连接的 当前述的四个元素变化时，不用重新建立连接 机制2：自定义重传机制 TCP有通过采样往返时间RTT的自适应重传算法，但是这种采样不准确。 QUIC也有递增序列号，任何一个包重发序列号都+1，不像TCP重发包还是原来的序号。 这样超时采样就准了，但是如何知道重发的包内容与前一个一样呢 QUIC在数据流里定义了offset，可以通过offset查看数据发送到了哪里 只要某个offset没到就重发，按照offset拼接成一个流，相当于多设一个参数处理流的顺序。 机制3：无阻塞的多路复用 跟2.0一样，同一条QUIC上可以创建多个流来发送HTTP请求 但因为基于UDP，一个连接上的多个流之间没有依赖 假如流2丢了一个UDP包，后面跟着流3的一个UDP包，虽然流2的包需要重传，但流3的包无需等待，而TCP就会阻塞 机制4：自定义流量控制 TCP的流量控制是通过滑动窗口协议，QUIC也是通过window_update来告诉对方自己可接受的字节数 但QUIC的窗口是适应自己的多路复用机制的，不但在一个连接上控制窗口，每个流也有控制窗口 TCP里接收端的窗口起始点是下一个要接收并且ACK的包，即便后来的包都到了放在缓存里，窗口也不能右移 只要前面的包没到，后面的到了也不能ACK，就会导致后面的到了也可能超时重传，浪费带宽。 QUIC的ACK是基于offset的，每个offset的包到了进了缓存就可以应答，应答后就不用重发，再继续等中间的包即可 QUIC窗口的其实位置为当前收到的最大offset，从这个offset到当前流所能容纳的最大缓存才是真正的窗口 另外还有整个连接的窗口，需要对所有流的窗口做一个统计 关于HTTP的队首阻塞 HTTP/1.0对于同一个tcp连接，所有的请求放入队列中，只有前一个请求的响应收到了，然后才能发送下一个请求。可见，HTTP/1.0的队首组塞发生在客户端。 HTTP/1.1对于同一个tcp连接，HTTP/1.1允许一次发送多个请求，也就是说，不必等前一个响应收到，就可以发送下一个请求，这样就解决了HTTP/1.0的客户端的队首阻塞。但服务端响应的发送要根据请求的顺序排队发送，如果前一个请求的处理时间长就会影响后面的响应发送。可见，HTTP/1.1的队首阻塞发生在服务器端。 HTTP/2.0无论在客户端还是在服务器端都不需要排队，在同一个TCP连接上，有多个stream，由各个stream发送和接收请求，各个steam相互独立，互不阻塞。只要TCO没有人在用那么就可以发送已经生成的requst或者reponse的数据，在两端都不用等，从而彻底解决了HTTP协议层面的队首阻塞问题。 HTTPS建立连接过程 开始连接时，客户端用服务端的公钥加密发送，服务端用客户端的公钥加密回应 CA证书里有公钥，CA是递归的最后有几个大的rootCA，先用非对称加密获取密钥，然后用对称加密传输数据，TLS/SSL HTTPS握手过程：（c是客户端，s是服务端） c发送 Client Hello 给s，明文传输TLS版本、加密套件候选列表、压缩算法候选列表等以及一个随机数A s返回 Server Hello 给c，声明选择使用的协议版本、加密套件、压缩算法等以及一个随机数B s发送 Server Certificate 给c，然后再发送 Server Hello Done，说明发送信息就这么多了，结束 c校验前一步s给的证书，从自己信任的CA仓库中拿CA证书的公钥取解密s的证书，过程中可能需要往上追溯CA、CA的CA等 c发送 Client Key Exchange，内含生成的一个随机数C：Pre-master，用s证书的公钥加密，发送给s，s可以通过自己的私钥解密出来（Pre-master是RSA加密的说法，DH加密需要 DH exponent） 现在，c和s都有了三个随机数，分别是自己的、对方的、Pre-master，通过这三个随机数，c和s能生成相同的对称密钥 c发送 Change Cipher Spec 通知s采用协商的通信密钥和加密算法进行对称加密通信 c发送 Encrypted Handshake Message 将先前商定好的参数采用协商密钥加密，发送给s用于数据与握手验证 s发送 Change Cipher Spec 回应c采用协商的通信密钥和加密算法进行对称加密通信 s发送 Encrypted Handshake Message 将先前商定好的参数采用协商密钥加密，发送给c用于数据与握手验证 双方转而使用对称加密通信，握手完成，除了以上过程，其余过程与HTTP一样 上面是HTTPS单向验证，只是c验证了s的证书，是大部分的场景，也可以在更加严格安全要求的情况下，启用双向验证，互验证书 重放与篡改攻击：自定义的：通过Timestamp和Nonce随机数联合起来做不可逆签名来保证。 为什么不直接用非对称加密通信？ 非对称加密的加密的内容不能超过公钥长度，所以只能用来作密钥交换或者内容签名 性能问题，对称加密是毫秒级，非对称是秒级，HTTPS握手过程的90%时间都在解密RSA 除了Premaster外还需要两个随机数的原因是TLS不信任每个客户端都能产生安全的随机数，所以引入多两个随机数 SSL/TLS TLS即SSL升级版，18年推出TLS1.3，目前(19年)用TLS1.2和1.3的都不少，SSL早就废弃了 对称加密算法有：AES、DES、3DES，非对称加密算法有：RSA、ECDHE TLS中上面将两个随机数和Premaster计算成对称加密主密钥的算法是PRF算法(SHA256) TLS是在传输层（TCPUDP层）之上，应用层（HTTP）之下的层，HTTPS其实就是在TCP和HTTP之间加了TLS层 握手的加密套件：例子：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256，ECDHE密钥交换、RSA身份验证、AES算法、128加密强度、GCM加密模式、SHA256是MAC或者PRF 目前主流HTTPS的流量是使用ECDHE进行密钥交换、用RSA进行身份验证 TLS协议原理 自顶向下、分层抽象，TLS大致在四层 最底层是基础算法原语的实现如AES、RSA、MD5、SHA256、ECDH等 第二层是选定参数后，符合密码学里标准分类的算法，包括块加密算法，签名算法，非对称加密算法，MAC算法等，例如： aes-128-cbc-pkcs7，rsaes-oaep ，rsassa-pkcs1-v1_5, hmac-sha256，ecdsa-p256，curve25519 等 第三层是把多种标准算法组合而成的半成品组件，例如：对称传输组件例如 aes-128-cbc + hmac-sha256，aes-128-gcm，认证密钥协商算法: rsassa-OAEP + ecdh-secp256r1，数字信封：rsaes-oaep + aes-cbc-128 + hmac-sha256 ，文件密码加密存储组件：pbkdf2+aes-128-cbc-hmac-sha256，密钥扩展算法 PRF-sha256 等 第四层是用各种组件拼装而成的各种成品密码学协议/软件，例如：TLS协议，SSH协议，SRP协议，gnupg文件格式，iMessage协议，bitcoin协议等等 很多程序员自己造的轮子，往往说白了就是想重复实现第3层的某个组件而已。 TLS加密套件 (CipherSuite) 从上述分层的角度看，TLS大致是由三个组件拼成的： 对称加密传输组件，例如aes-128-gcm; 认证密钥协商组件，例如rsa-ecdhe; 密钥扩展组件，例如TLS-PRF-sha256 这些组件可以再拆分为5类算法，在TLS中，这5类算法组合在一起，称为一个CipherSuite： authentication (认证算法) encryption (加密算法 ) message authentication code (消息认证码算法 简称MAC) key exchange (密钥交换算法) key derivation function （密钥衍生算法) TLS协议设计之初就考虑到了这每一类算法的演变，所以没有定死算法，而是设计了一个算法协商过程，来允许加入新的算法( 简直是软件可扩展性设计的典范！)，协商出的一个算法组合即一个CipherSuite 常见加密套件 加密算法分类 上述第二层中的密码学算法常见有下面几类 块加密算法：AES（AES_128_GCM等）、Serpent等 流加密算法：RC4、ChaCha20等 加密用哈希函数：MD5、SHA1、SHA256、POLY1305等 消息验证码函数：AEAD、HMAC-SHA256等 密钥交换算法：RSA、DH、ECDH、ECDHE 公钥加密算法：RSA 数字签名算法：RSA、DSA、ECDSA 设计一个加密通信协议的过程，就是自顶向下，逐步细化，挑选各类组件，拼装成完整协议的过程 AES加密算法 每个加密数据块大小固定为128位（16个字节），最后一块不满16字节的话需要用填充算法补齐 最终生成的加密密钥长度有128位、192位、256位三种 多种工作模式：ECB、CBC、CFB等，这块内容很多，后续补充 DES、3DES加密算法 DES: 每个加密数据块大小固定为64位（8个字节） 生成的密钥长度为64位（其中8位用于校验（每个字节的第8位）），所以AES比DES安全 3DES: 还是64位的加密数据块大小 简单粗暴的 Triple DES，使用3个DES密钥（所以共192位，其中24位校验），对数据块（还是64位的小块）应用三次DES算法进行三次加密 使用的3个密钥不是合并成1个密钥，而还是分成3个用，3DES加密时依次使用密钥1、密钥2、密钥3对明文数据块进行加密，解密过程反之亦然。 每次加解密原理与DES一样 RSA加密算法1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的“非对称加密算法”。 公钥与私钥的产生 假设Alice想要通过一个不可靠的媒体接收Bob的一条私人讯息。 她可以用以下的方式来产生一个公钥和一个私钥： 随意选择两个大的质数p和q，p不等于q，计算N=pq。 根据欧拉函数，求得r =φ(N)=φ(p)φ(q)= (p-1)(q-1) 选择一个小于 r 的整数 e，求得 e 关于模 r 的模反元素，命名为d。（模反元素存在，当且仅当e与r互质） 将 p 和 q 的记录销毁。 (N,e)是公钥，(N,d)是私钥。Alice将她的公钥(N,e)传给Bob，而将她的私钥(N,d)藏起来。 加密消息 假设Bob想给Alice送一个消息m，他知道Alice产生的N和e。 他使用起先与Alice约好的格式将m转换为一个小于N，且与N互质的整数n 比如他可以将每一个字转换为这个字的Unicode码，然后将这些数字连在一起组成一个数字。 假如他的信息非常长的话，他可以将这个信息分为几段，然后将每一段转换为n。 用下面这个公式他可以将n加密为c： n^e ≡ c (mod N) 计算c并不复杂。Bob算出c后就可以将它传递给Alice。 解密消息 Alice得到Bob的消息c后就可以利用她的密钥d来解码。她可以用以下这个公式来将c转换为n： c^d ≡ n (mod N) 得到n后，她可以将原来的信息m重新复原。 解码的原理是 c^d ≡ n^(e·d)(mod N) 已知e·d ≡ 1 (mod r)，即e·d =1 +hφ(N)。由欧拉定理可得： n ^(e·d) =n^ (1 +hφ(N))=n·((n^φ(N))^h)≡(n(1)^h)(modN) ≡ n (mod N) 签名消息 RSA也可以用来为一个消息署名。 假如Alice想给Bob传递一个署名的消息的话，那么她可以为她的消息计算一个散列值（Message digest） 然后用她的私钥加密这个散列值并将这个“署名”加在消息的后面。 这个消息只有用她的公钥才能被解密。 Bob获得这个消息后可以用Alice的公钥解密这个散列值 然后将这个数据与他自己为这个消息计算的散列值相比较。 假如两者相符的话，那么他就可以知道发信人持有甲的密钥，以及这个消息在传播路径上没有被篡改过。 实战例子 通过一次简单实践更好的了解RSA 假设p = 2，q = 5（p，q都是素数即可），则N = pq = 10； 得到：r = (p-1)(q-1) = (2-1)(5-1) = 4； 根据模反元素公式，可以得出，e·d ≡ 1 (mod 4),即e·d = 4n+1 (n为正整数)； 假设n=5，则e·d = 21，且e、d为正整数，并且e与r互质，则e = 7，d = 3； 获得公钥和密钥：公钥为(N, e) = (10, 7)，密钥为(N, d) = (10, 3)； 假设要传输的数字为2，通过公钥加密后为：(2^7)(mod 10) = 8； 通过密钥解密：(8^3)(mod 10) = 512(mod 10) = 2，即获得结果； ECDHE加密算法 主要用于HTTPS中的密钥交换 ECDHE源自ECDH，ECDH即使用椭圆曲线加密技术（ECC）的 DH密钥交换（Diffie-Hellman）算法. DH密钥交换算法，可以让交换双方在不共享任何秘密的情况下协商出一个密钥。ECC则是建立在基于椭圆曲线的离散对数问题上的密码体制，在相同的密钥长度下，其安全性比RSA更高。 而ECDHE则是ECDH的Ephemeral version，它会为每次握手过程分配一个不同的DH key，从而提供前向安全性。实际上，在HTTP/2中允许使用的Cipher Suite必须采用具有前向安全性的密钥交换算法。 总结 HTTPS实际就是在TCP层与http层之间加入了TLS/SSL来解决安全问题的。 在进行应用数据传输之前，TLS需要通过握手过程来协商安全通信所需的相关参数。 整个通信过程中主要用到散列、对称加密、非对称加密和证书等相关技术，来解决客户端与服务器数据传输中各种安全风险问题，从而达到保证整个通信过程的安全。","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"NetworkProtocol","slug":"NetworkProtocol","permalink":"https://paaatrick.com/tags/NetworkProtocol/"}]},{"title":"WKWebView获取H5页面里图片地址以及图片相对视图窗口的坐标的方法","slug":"ios-achieve-h5-image-bounding-rect","date":"2019-06-01T04:04:39.000Z","updated":"2021-11-07T12:02:15.280Z","comments":true,"path":"2019-06-01-ios-achieve-h5-image-bounding-rect/","link":"","permalink":"https://paaatrick.com/2019-06-01-ios-achieve-h5-image-bounding-rect/","excerpt":"WKWebView获取H5页面里图片地址以及图片相对视图窗口的坐标的方法 最近有个需求是点击放大查看H5内容页面的图片，寻找到一个比较轻量的库YHPhotoBrowser，其中根据图片位置来缩放的动画需要传递一个图片所在屏幕里的位置CGRect，想获取H5的图片坐标那就需要JS注入了","text":"WKWebView获取H5页面里图片地址以及图片相对视图窗口的坐标的方法 最近有个需求是点击放大查看H5内容页面的图片，寻找到一个比较轻量的库YHPhotoBrowser，其中根据图片位置来缩放的动画需要传递一个图片所在屏幕里的位置CGRect，想获取H5的图片坐标那就需要JS注入了 123456789101112131415161718192021222324252627282930313233- (void)handleSingleTap:(UITapGestureRecognizer *)recognizer &#123; CGPoint touchPoint = [recognizer locationInView:self.webView]; NSString *jsString = [NSString stringWithFormat:@\"function getURLandRect()&#123;\\ var ele=document.elementFromPoint(%f, %f);\\ var url=ele.src;\\ var left=ele.getBoundingClientRect().left;\\ var top=ele.getBoundingClientRect().top;\\ var width=ele.getBoundingClientRect().width;\\ var height=ele.getBoundingClientRect().height;\\ var jsonString= `&#123;\\\"url\\\":\\\"$&#123;url&#125;\\\",\\\"left\\\":\\\"$&#123;left&#125;\\\",\\\"top\\\":\\\"$&#123;top&#125;\\\",\\\"width\\\":\\\"$&#123;width&#125;\\\",\\\"height\\\":\\\"$&#123;height&#125;\\\"&#125;`;\\ return(jsonString)&#125; getURLandRect()\", touchPoint.x, touchPoint.y]; [self.webView evaluateJavaScript:jsString completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSDictionary *resultDic = [SmallTools convertToDictionary:(NSString *)result]; NSString *imageURL = [SmallTools isNullToString:resultDic[@\"url\"]]; if (imageURL.length == 0 || [imageURL isEqualToString:@\"undefined\"]) &#123; return; &#125; CGFloat imgX = [resultDic[@\"left\"] floatValue]; CGFloat imgY = [resultDic[@\"top\"] floatValue] + NAV_HEIGHT + 5; CGFloat imgW = [resultDic[@\"width\"] floatValue]; CGFloat imgH = [resultDic[@\"height\"] floatValue]; self.photoView = [[YHPhotoBrowser alloc]init]; self.photoView.sourceView = self.view; //图片所在的父容器 self.photoView.urlImgArr = @[imageURL]; //网络链接图片的数组 if (imgX &amp;&amp; imgY &amp;&amp; imgW &amp;&amp; imgH) &#123; //原图片所在屏幕位置 self.photoView.sourceRect = CGRectMake(imgX, imgY, imgW, imgH); &#125; self.photoView.indexTag = 0; //初始化进去显示的图片下标 [self.view addSubview:self.photoView]; //叠加在当前VC上 &#125;];&#125; 这个JS方法document.elementFromPoint(%f, %f)根据传入的点返回该点最上层的对象，通过src找到图片的链接，然后getBoundingClientRect()方法能返回对象的八个属性left, top, right, bottom, x, y, width, height，根据需要获取相应属性构造原图的CGRect即可 这里附带一下判断NSString合法性以及JSON字符串转NSDictionary的工具方法 1234567+ (NSString *)isNullToString:(id)string &#123; if ([string isEqual:@\"NULL\"] || [string isKindOfClass:[NSNull class]] || [string isEqual:[NSNull null]] || [string isEqual:NULL] || [[string class] isSubclassOfClass:[NSNull class]] || string == nil || string == NULL || [string isKindOfClass:[NSNull class]] || [[string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] length]==0 || [string isEqualToString:@\"&lt;null&gt;\"] || [string isEqualToString:@\"(null)\"]) &#123; return @\"\"; &#125; else &#123; return (NSString *)string; &#125;&#125; 12345+ (NSDictionary *)convertToDictionary:(NSString *)jsonStr &#123; NSData *data = [jsonStr dataUsingEncoding:NSUTF8StringEncoding]; NSDictionary *tempDic = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; return tempDic;&#125;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"LeetCode做题笔记—并查集相关题目","slug":"leetcode-union-find","date":"2019-05-24T01:34:02.000Z","updated":"2021-11-07T12:02:15.280Z","comments":true,"path":"2019-05-24-leetcode-union-find/","link":"","permalink":"https://paaatrick.com/2019-05-24-leetcode-union-find/","excerpt":"有关并查集 Union Find Set 的做题笔记，Python实现","text":"有关并查集 Union Find Set 的做题笔记，Python实现 200. 岛屿的个数 Number of IslandsLeetCodeCN 第200题链接 第一种方法：构造一个简单的并查集，将输入的二维数组坐标一维化。 实例化并查集对象后，遍历二维数组，发现为1时对该节点上下左右都执行一次union()，将这上下左右的1 （如果是的话）的parent指向当前节点 123456789101112131415161718192021222324252627282930313233343536373839class UnionFind: def __init__(self, grid): n, m = len(grid), len(grid[0]) self.count = 0 self.parent = [-1] * (n*m) # self.rank = [0] * (n*m) for i in range(n): for j in range(m): if grid[i][j] == '1': self.parent[i*m + j] = i*m + j self.count += 1 # 在查找的同时，也把节点换绑到根节点上了 def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootx self.count -= 1class Solution: def numIslands(self, grid) -&gt; int: if not grid: return 0 uf = UnionFind(grid) directions = [(0,1), (0,-1), (-1,0), (1,0)] n, m = len(grid), len(grid[0]) for i in range(n): for j in range(m): if grid[i][j] == '1': for x, y in directions: if 0 &lt;= i+x &lt; n and 0 &lt;= j+y &lt; m and grid[i+x][j+y] == '1': uf.union(i*m+j, (i+x)*m+(j+y)) return uf.count 第二种方法：染色解法，DFS深度优先搜索清除相邻岛屿，遍历二维数组，发现为1时岛屿数量加1，同时DFS将自身及周边相邻（上下左右）位置递归置0 1234567891011121314151617181920class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: if not grid: return 0 self.grid, count = grid, 0 self.n, self.m = len(grid), len(grid[0]) for i in range(self.n): for j in range(self.m): if grid[i][j] == '1': count += 1 self.dfs(i, j) return count def dfs(self, i, j): if 0 &lt;= i &lt; self.n and 0 &lt;= j &lt; self.m and self.grid[i][j] == '1': self.grid[i][j] = '0' self.dfs(i-1, j) self.dfs(i+1, j) self.dfs(i, j-1) self.dfs(i, j+1) 第三种方法：染色解法，BFS广度优先搜索清除相邻岛屿，遍历二维数组，发现为1时岛屿数量加1，同时BFS将自身及周边相邻（上下左右）位置用队列逐个置0，把上面的DFS的递归改成BFS的队列即可 12345678910111213141516171819202122232425from collections import dequeclass Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: if not grid: return 0 self.grid, count = grid, 0 self.n, self.m = len(grid), len(grid[0]) for i in range(self.n): for j in range(self.m): if grid[i][j] == '1': count += 1 self.bfs(i, j) return count def bfs(self, i, j): queue = deque() queue.append((i, j)) while queue: i, j = queue.popleft() if 0 &lt;= i &lt; self.n and 0 &lt;= j &lt; self.m and self.grid[i][j] == '1': self.grid[i][j] = '0' queue.append((i-1, j)) queue.append((i+1, j)) queue.append((i, j-1)) queue.append((i, j+1)) 547. 朋友圈 Friend CirclesLeetCodeCN 第547题 第一种方法：构造一个简单的并查集，将输入的二维数组坐标一维化。 实例化并查集对象后，遍历二维数组，发现为1时对该节点上下左右都执行一次union()，将这上下左右的1 （如果是的话）的parent指向当前节点 12345678910111213141516171819202122232425262728293031class UnionFind: def __init__(self, M): self.n = len(M) self.parent = list(range(self.n)) # 在查找的同时，也把节点换绑到根节点上了 def find(self, i): if self.parent[i] != i: self.parent[i] = self.find(self.parent[i]) return self.parent[i] def union(self, x, y): rootx = self.find(x) rooty = self.find(y) if rootx != rooty: self.parent[rooty] = rootx def diff_groups(self): diff_groups = set() for i in range(self.n): diff_groups.add(self.find(i)) return len(diff_groups)class Solution: def findCircleNum(self, M) -&gt; int: uf = UnionFind(M) for i in range(len(M)): for j in range(len(M)): if M[i][j]: uf.union(i, j) return uf.diff_groups() 第二种方法：DFS， 首先我们进行情景转换，如果把每个同学看作一个城市，同学与同学之间的朋友关系表示两个城市之间存在公路（可互相到达）。那么朋友圈的个数就转换为城市圈的个数。我们每次从整个城市集合中挑选出一个未访问的城市，接着我们访问它所能到达的所有城市（递归，深度优先搜索）。那么我们挑选了几次就是访问到了多少个城市圈。 12345678910111213141516class Solution: def findCircleNum(self, M: List[List[int]]) -&gt; int: if not M: return 0 self.M, self.n, self.visited, count = M, len(M), set(), 0 for i in range(self.n): if i not in self.visited: count += 1 self.dfs(i) return count def dfs(self, i): for j in range(self.n): if self.M[i][j] == 1 and j not in self.visited: self.visited.add(j) self.dfs(j) 第三种方法：BFS，把上面的DFS的递归写法改成BFS的队列即可 1234567891011121314151617from collections import dequeclass Solution: def findCircleNum(self, M: List[List[int]]) -&gt; int: if not M: return 0 n, visited, count, queue = len(M), set(), 0, deque() for i in range(n): if i not in visited: count += 1 queue.append(i) while queue: p = queue.popleft() visited.add(p) for j in range(n): if M[p][j] == 1 and j not in visited: queue.append(j) return count","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"粗谈iOS中 weak、self、循环引用的二三事","slug":"ios-weakself-retain-cycle","date":"2019-05-21T08:20:16.000Z","updated":"2021-11-07T12:02:15.280Z","comments":true,"path":"2019-05-21-ios-weakself-retain-cycle/","link":"","permalink":"https://paaatrick.com/2019-05-21-ios-weakself-retain-cycle/","excerpt":"有关weak、self、循环引用的一些问题 0. 什么是循环引用，后果是什么","text":"有关weak、self、循环引用的一些问题 0. 什么是循环引用，后果是什么 循环引用可以简单理解为A引用了B，而B又引用了A，双方都同时保持对方的一个引用，导致任何时候引用计数都不为0，始终无法释放。若当前对象是一个ViewController，则在dismiss或者pop之后其dealloc无法被调用，在频繁的push或者present之后内存暴增，就会Crash。 关于ARC的介绍 1. 在使用block时，为了避免产生循环引用，通常会使用weakSelf与strongSelf，例如如下代码，那么什么时候在 block里面用self，什么时候不需要使用weakSelf1234567__weak typeof(self) weakSelf = self;[self doSomeBlockJob:^&#123; __strong typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) &#123; ... &#125;&#125;]; 当 block 本身不被 self 持有，而被别的对象持有，同时不产生循环引用的时候，就不需要使用 weakSelf 了。最常见的代码就是 UIView 的动画代码，我们在使用 UIView 的 animateWithDuration:animations 方法做动画的时候，并不需要使用 weakSelf，因为引用持有关系是： UIView 的某个负责动画的对象持有了 block block 持有了 self 因为 self 并不持有 block，所以就没有循环引用产生，因为就不需要使用 weakSelf 了。 123[UIView animateWithDuration:0.2 animations:^&#123; self.alpha = 1;&#125;]; 当动画结束时，UIView 会结束持有这个 block，如果没有别的对象持有 block 的话，block 对象就会释放掉，从而 block 会释放掉对于 self 的持有。整个内存引用关系被解除。 2. block 里面还需要写一个 strongSelf 的原因，如果不写会发生什么外部的weakSelf是为了打破环，从而使得没有循环引用，而内部的strongSelf仅仅是个局部变量，存在栈中，会在block执行结束后回收，不会再造成循环引用。 在 block 中先写一个 strongSelf，其实是为了避免在 block 的执行过程中，突然出现 self 被释放的尴尬情况。通常情况下，如果不这么做的话，还是很容易出现一些奇怪的逻辑，甚至闪退。 以 AFNetworking 中 AFNetworkReachabilityManager.m 的一段代码举例： 123456789__weak __typeof(self)weakSelf = self;AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; strongSelf.networkReachabilityStatus = status; if (strongSelf.networkReachabilityStatusBlock) &#123; strongSelf.networkReachabilityStatusBlock(status); &#125;&#125;; 如果没有 strongSelf 的那行代码，那么后面的每一行代码执行时，self 都可能被释放掉了，这样很可能造成逻辑异常。 特别是当我们正在执行 strongSelf.networkReachabilityStatusBlock(status);这个 block 闭包时，如果这个 block 执行到一半时 self 释放，那么多半情况下会 Crash。 3. 有没有这样一个需求场景，block 会产生循环引用，但是业务又需要你不能使用 weakSelf? 如果有，请举一个例子并且解释这种情况下如何解决循环引用问题。需要不使用 weakSelf 的场景是：你需要构造一个循环引用，以便保证引用双方都存在。比如你有一个后台的任务，希望任务执行完后，通知另外一个实例。在 YTKNetwork 网络库的源码中，就有这样的场景。 在 YTKNetwork 库中，我们的每一个网络请求 API 会持有回调的 block，回调的 block 会持有 self，而如果 self 也持有网络请求 API 的话，我们就构造了一个循环引用。虽然我们构造出了循环引用，但是因为在网络请求结束时，网络请求 API 会主动释放对 block 的持有，因此，整个循环链条被解开，循环引用就被打破了，所以不会有内存泄漏问题。代码其实很简单，如下所示： 123456// YTKBaseRequest.m- (void)clearCompletionBlock &#123; // nil out to break the retain cycle. self.successCompletionBlock = nil; self.failureCompletionBlock = nil;&#125; 总结来说，解决循环引用问题主要有两个办法： 第一个办法是「事前避免」，我们在会产生循环引用的地方使用 weak 弱引用，以避免产生循环引用。 第二个办法是「事后补救」，我们明确知道会存在循环引用，但是我们在合理的位置主动断开环中的一个引用，使得对象得以回收。 4. weak 变量在引用计数为0时，会被自动设置成 nil 的这个特性的实现原理 简单来说，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。所以使用weak会有额外的开销 在 Friday QA 上，有一期专门介绍 weak 的实现原理。 《Objective-C高级编程》一书中也介绍了相关的内容。 系统有一个全局的 CFMutableDictionary 实例，来保存每个对象的 weak 指针列表，因为每个对象可能有多个 weak 指针，所以这个实例的值是 CFMutableSet 类型。 剩下我们要做的，就是在引用计数变成 0 的时候，去这个全局的字典里面，找到所有的 weak 指针，将其值设置成 nil。如何做到这一点呢？Friday QA 上介绍了一种类似 KVO 实现的方式。当对象存在 weak 指针时，我们可以将这个实例指向一个新创建的子类，然后修改这个子类的 release 方法，在 release 方法中，去从全局的 CFMutableDictionary 字典中找到所有的 weak 对象，并且设置成 nil。我摘抄了 Friday QA 上的实现的核心代码，如下： 123456Class subclass = objc_allocateClassPair(class, newNameC, 0);Method release = class_getInstanceMethod(class, @selector(release));Method dealloc = class_getInstanceMethod(class, @selector(dealloc));class_addMethod(subclass, @selector(release), (IMP)CustomSubclassRelease, method_getTypeEncoding(release));class_addMethod(subclass, @selector(dealloc), (IMP)CustomSubclassDealloc, method_getTypeEncoding(dealloc));objc_registerClassPair(subclass); 当然，这并不代表苹果官方是这么实现的，因为苹果的这部分代码并没有开源。《Objective-C高级编程》一书中介绍了 GNUStep 项目中的开源代码，思想也是类似的。所以我认为虽然实现细节会有差异，但是大致的实现思路应该差别不大。 5. 如果有一些 UI 控件我们要用代码的方式来创建，那么它应该用 weak 还是 strong我们知道，从 Storyboard 往编译器拖出来的 UI 控件的属性是 weak 的，如下所示 1@property (weak, nonatomic) IBOutlet UIButton *myButton; 那么如果有一些 UI 控件我们要用代码的方式来创建，那么它应该用 weak 还是 strong? 从上面弱引用自动置nil的原理可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与 Xcode 通过 Storyboard 拖拽生成的新变量是一致的。 UI 控件用默认用 weak，根源还是苹果希望只有这些 UI 控件的父 View 来强引用它们，而 ViewController 只需要强引用 ViewController.view 成员，则可以间接持有所有的 UI 控件。这样有一个好处是：在以前，当系统收到 Memory Warning 时，会触发 ViewController 的 viewDidUnload 方法，这样的弱引用方式，可以让整个 view 整体都得到释放，也更方便重建时整体重新构造。 但是首先 viewDidUnload 方法在 iOS 6 开始就被废弃掉了，苹果用了更简单有效地方式来解决内存警告时的视图资源释放，具体如何做的呢？嗯，这个可以当作某一期的面试题展开介绍。总之就是，除非你特殊地操作 view 成员，ViewController.view 的生命期和 ViewController 是一样的了。 所以在这种情况下，其实 UI 控件是不是 weak 其实关系并不大。当 UI 控件是 weak 时，它的引用计数是 1，持有它的是它的 superview，当 UI 控件是 strong 时，它的引用计数是 2，持有它的有两个地方，一个是它的 superview，另一个是这个 strong 的指针。UI 控件并不会持有别的对象，所以，不管是手写代码还是 Storyboard，UI 控件是 strong 都不会有循环引用的。 那么回到我们的最初的问题，自己写的 view 成员，应该用 weak 还是 strong？我个人觉得应该用 strong，因为用 weak 并没有什么特别的优势，而且由上面 weak的实现来看，weak 变量会有额外的系统维护开销的，如果你没有使用它的特别的理由，那么用 strong 的话应该更好。 另外如果要做懒加载，那么你也只能选择用 strong。 当然，如果你非要用 weak，其实也没什么问题，只需要注意在赋值前，先把这个对象用 addSubView 加到父 view 上，否则可能刚刚创建完，它就被释放了。","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"LeetCode做题笔记—DP动态规划相关题目","slug":"leetcode-dynamic-programming","date":"2019-05-20T03:13:52.000Z","updated":"2021-11-07T12:02:15.280Z","comments":true,"path":"2019-05-20-leetcode-dynamic-programming/","link":"","permalink":"https://paaatrick.com/2019-05-20-leetcode-dynamic-programming/","excerpt":"有关动态规划 Dynamic Programming 的做题笔记，Python实现","text":"有关动态规划 Dynamic Programming 的做题笔记，Python实现 70. 爬楼梯 Climbing StairsLeetCodeCN 第70题链接 第一种方法：递归，显然是个斐波那契数列，时间复杂度 $O(2^n)$很高，这样没法通过LeetCode，参考 @wikizero 的解法可以加个LRU缓存 1234567# from functools import lru_cacheclass Solution: # @lru_cache(10**8) def climbStairs(self, n: int) -&gt; int: if n &lt;= 2: return n return self.climbStairs(n - 1) + self.climbStairs(n - 2) 第二种方法：动态规划，用数组记录每个台阶的所有走法个数，时间复杂度降为 $O(n)$ 123456789class Solution: def climbStairs(self, n: int) -&gt; int: if n &lt;= 2: return n f = [0] * (n+1) f[0] = f[1] = 1 for i in range(2, n+1): f[i] = f[i-1] + f[i-2] return f[n] 第三种方法：动态规划，由于只需要返回最后一步的所有走法个数，不需要数组记录过程，利用Python的同时赋值特性，只需两个变量就行，空间复杂度降为 $O(1)$ 123456class Solution: def climbStairs(self, n: int) -&gt; int: x = y = 1 for _ in range(1, n): x, y = x+y, x return x 120. 三角形最小路径和 TriangleLeetCodeCN 第120题链接 第一种方法：递归，时间复杂度O(2^n)，LeetCode会超时过不了 1234567891011121314class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: self.tri = triangle self.path = [] self.helper(0,0,0) return min(self.path) def helper(self, i, j, res): if i &gt;= len(self.tri): self.path.append(res) return res += self.tri[i][j] self.helper(i+1, j, res) self.helper(i+1, j+1, res) 第二种方法：动态规划，新建个二维数组mini，定义mini[i][j]为从三角形底部到[i][j]的最小路径和，递推公式mini[i][j] = triangle[i][j] + min(mini[i+1][j], mini[i+1][j+1])即本身节点的值加上下一层[i+1]里相邻两个节点mini的最小值，首先把三角形最后一层赋值给mini的最后一层，然后两个循环，最后得到mini[0][0]三角形顶部节点，时间复杂度O(n^2) 123456789class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: lens = len(triangle) mini = [[0]*lens for _ in range(lens)] mini[lens-1] = triangle[lens-1] for i in range(lens-2, -1, -1): for j in range(len(triangle[i])): mini[i][j] = triangle[i][j] + min(mini[i+1][j], mini[i+1][j+1]) return mini[0][0] 第三种方法：在第二种方法的基础上，mini只需一维数组即可，更新自身 1234567class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: mini = triangle[len(triangle)-1] for i in range(len(triangle)-2, -1, -1): for j in range(len(triangle[i])): mini[j] = triangle[i][j] + min(mini[j], mini[j+1]) return mini[0] 第四种方法：在第二种方法的基础上，直接修改三角形数组的值，空间复杂度为O(1) 123456class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: for i in range(len(triangle)-2, -1, -1): for j in range(len(triangle[i])): triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]) return triangle[0][0] 152. 乘积最大子序列 Maximum Product SubarrayLeetCodeCN 第152题链接 第一种方法：DP动态规划，创建二维数组dp，dp[i][0]存放正数最大值, dp[i][1]存放最小值即负数的最大值 12345678910111213class Solution: def maxProduct(self, nums: List[int]) -&gt; int: if nums is None: return 0 dp = [[0]*2 for _ in range(len(nums))] dp[0][0], dp[0][1] = nums[0], nums[0] for i in range(1, len(nums)): dp[i][0] = max(dp[i-1][0]*nums[i], dp[i-1][1]*nums[i], nums[i]) dp[i][1] = min(dp[i-1][0]*nums[i], dp[i-1][1]*nums[i], nums[i]) result = [] for j in dp: result.append(j[0]) return max(result) 第二种方法：在第一种方法的基础上，用一维滚动数组dp，每次循环交替x和y为0和1 123456789101112class Solution: def maxProduct(self, nums: List[int]) -&gt; int: if nums is None: return 0 dp = [[0]*2 for _ in range(2)] dp[0][0], dp[0][1], res = nums[0], nums[0], nums[0] for i in range(1, len(nums)): x, y = i &amp; 1, (i - 1) &amp; 1 dp[x][0] = max(dp[y][0]*nums[i], dp[y][1]*nums[i], nums[i]) dp[x][1] = min(dp[y][0]*nums[i], dp[y][1]*nums[i], nums[i]) res = max(res, dp[x][0]) return res 300. 最长上升子序列 Longest Increasing SubsequenceLeetCodeCN 第300题链接 DP动态规划，定义状态dp[i]为以nums[i]为结尾且必须包含nums[i]本身的最长上升子序列的长度。两个嵌套的循环，状态转移方程dp[i] = max(dp[i], dp[j] + 1)即在内层循环内通过比较dp[j]来不断迭代dp[i]，找到前面最大的一个dp值然后加1。最后dp数组的最大值就是问题的解 1234567891011class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 n = len(nums) dp = [1]*n for i in range(1, n): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j]+1) return max(dp) 322. 零钱兑换 Coin ChangeLeetCodeCN 第322题链接 第一种方法：DFS深度优先搜索，暴力操作，LeetCode会超时过不去 123456789101112131415161718192021class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: if amount &lt; 1: return 0 self.coins = sorted(coins, reverse=True) self.res = [] for i in self.coins: self.dfs(amount, i, 1) if not self.res: return -1 return min(self.res) def dfs(self, amount, num, count): last = amount - num if last &lt; 0: return if not last: self.res.append(count) return for i in self.coins: self.dfs(last, i, count + 1) 第二种方法：DP动态规划，定义状态dp[i]为拼凑数额i最少所需的硬币数量 123456789class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: dp = [amount+1]*(amount+1) dp[0] = 0 for i in range(1, amount+1): for c in coins: if i - c &gt;= 0: dp[i] = min(dp[i], dp[i-c] + 1) return dp[amount] if dp[amount] &lt;= amount else -1 第三种方法：把coins的循环放外层，减少循环次数及一次if判断 1234567class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: dp = [0] + [amount+1]*amount for coin in coins: for i in range(coin, amount+1): dp[i] = min(dp[i], dp[i-coin]+1) return dp[-1] if dp[-1] != amount+1 else -1 72. 编辑距离 Edit DistanceLeetCodeCN 第72题链接 第一种方法：BFS暴力求解 第二种方法：DP动态规划，定义状态dp[i][j] 表示word1的前i个字母和word2的前j个字母之间的编辑距离，即word1的前i个字符要替换到word2的前j个字符所需要的最少操作次数。当word1[i-1] == word2[j-1]时，dp[i][j]的状态就是直接转移dp[i-1][j-1]，无需任何步骤，否则，dp[i][j]的状态来自dp[i-1][j], dp[i][j-1], dp[i-1][j-1]（添加、删除、替换）中的最小值并加操作步骤1次。 12345678910111213141516171819class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: n, m = len(word1), len(word2) dp = [[0]*(m+1) for _ in range(n+1)] for i in range(n+1): dp[i][0] = i for j in range(m+1): dp[0][j] = j for i in range(1,n+1): for j in range(1,m+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 # 上面的if else逻辑可以压缩成一行 # dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+(0 if word1[i-1] == word2[j-1] else 1)) return dp[n][m] 42. 接雨水 Trapping Rain WaterLeetCodeCN 第42题链接 第一种方法：DP动态规划，计算出每个点的左边界最大与右边界最大，最后减去自身高度 123456789101112131415class Solution: def trap(self, height: List[int]) -&gt; int: if not height: return 0 n, res = len(height), 0 maxLeft, maxRight = [0]*n, [0]*n maxLeft[0] = height[0] maxRight[-1] = height[-1] for i in range(1, n): maxLeft[i] = max(height[i], maxLeft[i-1]) for j in range(n-2, -1, -1): maxRight[j] = max(height[j], maxRight[j+1]) for k in range(n): res += min(maxLeft[k], maxRight[k]) - height[k] return res 第二种方法：双指针，每次矮边向内推进，如果自身不是该边最大值证明有更大的边，就可以接雨水了，否则更新自己为该边最大值 12345678910111213141516171819class Solution: def trap(self, height: List[int]) -&gt; int: if not height: return 0 l, r, left_max, right_max, res = 0, len(height)-1, height[0], height[-1], 0 while l &lt; r: if height[r] &gt;= height[l]: if left_max &gt; height[l]: res += left_max - height[l] else: left_max = height[l] l += 1 else: if right_max &gt; height[r]: res += right_max - height[r] else: right_max = height[r] r -= 1 return res 62. 不同路径 Unique PathsLeetCodeCN 第62题链接 标准的动态规划，从右下目标点往左上走，dp储存当前点位共有多少种走法，dp[i][j]的走法数量 = dp[i+1][j] + dp[i][j+1] 底边和最右边格子都是1，所以创建dp数组时顺便把初始化也完成了 123456789class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: if not m or not n: return 0 dp = [[1]*m for _ in range(n)] for i in range(n-2, -1, -1): for j in range(m-2, -1, -1): dp[i][j] = dp[i+1][j] + dp[i][j+1] return dp[0][0] 63. 不同路径 II Unique Paths IILeetCodeCN 第63题链接 与上题62题思路一样，从右下目标点往左上走，dp储存当前点位共有多少种走法，dp[i][j]的走法数量 = dp[i+1][j] + dp[i][j+1]，不过因为有障碍物需要额外处理一下，分别初始化底边和最右边。然后迭代时判断一下障碍物即可 1234567891011121314151617181920212223242526272829303132class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: if not obstacleGrid or not obstacleGrid[0]: return 0 n, m = len(obstacleGrid), len(obstacleGrid[0]) dp = [[1]*m for _ in range(n)] # 处理最右列的初始值 flag = 0 for i in range(n-1, -1, -1): if flag: dp[i][m-1] = 0 continue if obstacleGrid[i][m-1]: dp[i][m-1] = 0 flag = 1 # 处理最下行的初始值 flag = 0 for i in range(m-1, -1, -1): if flag: dp[n-1][i] = 0 continue if obstacleGrid[n-1][i]: dp[n-1][i] = 0 flag = 1 # 从右下到左上的DP递推 for i in range(n-2, -1, -1): for j in range(m-2, -1, -1): if obstacleGrid[i][j]: dp[i][j] = 0 continue dp[i][j] = dp[i+1][j] + dp[i][j+1] return dp[0][0] 64. 最小路径和 Minimum Path SumLeetCodeCN 第64题链接 动态规划，定义DP二维数组储存的是经过该点位的最小路径和，首先初始化好最右边和底边的初始值，然后从目标右下递推到起始点左上，dp[0][0]即结果 123456789101112131415class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) dp = [[0]*m for _ in range(n)] dp[-1][-1] = grid[-1][-1] for i in range(n-2, -1, -1): dp[i][m-1] = grid[i][m-1] + dp[i+1][m-1] for i in range(m-2, -1, -1): dp[n-1][i] = grid[n-1][i] + dp[n-1][i+1] for i in range(n-2, -1, -1): for j in range(m-2, -1, -1): dp[i][j] = min(dp[i+1][j], dp[i][j+1]) + grid[i][j] return dp[0][0] 用滚动数组降低空间复杂度，从左上角往右下角迭代 12345678910111213141516171819class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(2)] dp[0][0] = grid[0][0] for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, m): x, y = i&amp;1, (i-1)&amp;1 for j in range(n): if not j: dp[x][j] = dp[y][j] + grid[i][j] else: dp[x][j] = min(dp[y][j], dp[x][j-1]) + grid[i][j] return dp[0][-1] if m&amp;1 else dp[1][-1] 198. 打家劫舍 House RobberLeetCodeCN 第198题链接 第一种方法：动态规划，递推方程f(i) = max(f(i-1), f(i-2)+nums[i])，当前点位最大利润可能来自前一个点位的最大利润（当前点位不偷）或者来自前两个点位的最大利润加上偷当前点位。开一个长度为n的数组记录，取数组末尾即结果 123456789101112class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 n = len(nums) if n &lt;= 2: return max(nums) dp = [0]*n dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2]+nums[i]) return dp[-1] 第二种方法：用滚动数组降低空间复杂度，O(n)→O(1)，无需改动太多代码，适合面试时改进代码 12345678910111213class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 n = len(nums) if n &lt;= 2: return max(nums) dp = [0]*2 dp[0], dp[1] = nums[0], max(nums[0], nums[1]) for i in range(2, n): x, y = i&amp;1, (i+1)&amp;1 dp[x] = max(dp[y], dp[x]+nums[i]) return max(dp[0], dp[1]) 5. 最长回文子串 Longest Palindromic SubstringLeetCodeCN 第5题链接 第一种方法：动态规划，定义dp[i][j]为从位置j到i的字符串是否是回文串，递推式子是if (s[i] == s[j] and dp[i-1][j+1]) then dp[i][j] = 1其中加入一个判断如果子串长度为2就不用看dp了加速计算。然后如果dp[i][j]是回文串了，就跟当前最长的回文串比较，如果新的更长就更新结果 1234567891011121314class Solution: def longestPalindrome(self, s: str) -&gt; str: if not s: return '' n = len(s) maxLen, res, dp = 0, '', [[0]*n for _ in range(n)] for i in range(n): for j in range(i, -1, -1): if s[i] == s[j] and (i-j&lt;2 or dp[i-1][j+1]): dp[i][j] = 1 if dp[i][j] and maxLen &lt; i-j+1: maxLen = i-j+1 res = s[j:i+1] return res 动态规划——买卖股票最佳时机系列题链接","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"粗谈ARC自动引用计数和GC垃圾回收","slug":"ios-arc-gc","date":"2019-05-19T02:59:35.000Z","updated":"2021-11-07T12:02:15.280Z","comments":true,"path":"2019-05-19-ios-arc-gc/","link":"","permalink":"https://paaatrick.com/2019-05-19-ios-arc-gc/","excerpt":"粗谈ARC自动引用计数和GC垃圾回收 1. ARC 自动引用计数","text":"粗谈ARC自动引用计数和GC垃圾回收 1. ARC 自动引用计数 自动引用计数（Automatic Reference Count 简称 ARC），是苹果在 WWDC 2011 年大会上提出的用于内存管理的技术。虽然 ARC 极大地简化了我们的内存管理工作，但是引用计数这种内存管理方案如果不被理解，那么就无法处理好那些棘手的循环引用问题。 引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。由于引用计数简单有效，除了 Objective-C 语言外，微软的 COM（Component Object Model ）、C++11（C++11 提供了基于引用计数的智能指针 share_prt）等语言也提供了基于引用计数的内存管理方式。 引用计数这种内存管理方式虽然简单，但是手工写大量的操作引用计数的代码不但繁琐，而且容易被遗漏。于是苹果在 2011 年引入了 ARC。ARC 顾名思义，是自动帮我们填写引用计数代码的一项功能。 ARC 的想法来源于苹果在早期设计 Xcode 的 Analyzer 的时候，发现编译器在编译时可以帮助大家发现很多内存管理中的问题。后来苹果就想，能不能干脆编译器在编译的时候，把内存管理的代码都自动补上，带着这种想法，苹果修改了一些内存管理代码的书写方式（例如引入了 @autoreleasepool 关键字）后，在 Xcode 中实现了这个想法。 ARC 的工作原理大致是这样：当我们编译源码的时候，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，来添加相应的引用计数操作代码。所以，ARC 是工作在编译期的一种技术方案，这样的好处是： 编译之后，ARC 与非 ARC 代码是没有什么差别的，所以二者可以在源码中共存。实际上，你可以通过编译参数 -fno-objc-arc 来关闭部分源代码的 ARC 特性。 相对于垃圾回收这类内存管理方案，ARC 不会带来运行时的额外开销，所以对于应用的运行效率不会有影响。相反，由于 ARC 能够深度分析每一个对象的生命周期，它能够做到比人工管理引用计数更加高效。例如在一个函数中，对一个对象刚开始有一个引用计数 +1 的操作，之后又紧接着有一个 -1 的操作，那么编译器就可以把这两个操作都优化掉。 但是也有人认为，ARC 也附带有运行期的一些机制来使 ARC 能够更好的工作，他们主要是指 weak 关键字。weak 变量能够在引用计数为 0 时被自动设置成 nil，显然是有运行时逻辑在工作的。我通常并没有把这个算在 ARC 的概念当中，当然，这更多是一个概念或定义上的分歧，因为除开 weak 逻辑之外，ARC 核心的代码都是在编译期填充的。 2. GC 垃圾回收Android 手机通常使用 Java 来开发，而 Java 是使用垃圾回收这种内存管理方式。 那么，ARC 和垃圾回收对比，有什么优点和缺点？ 虽然做 iOS 开发并不需要用到垃圾回收这种内存管理机制。但是垃圾回收被使用得非常普遍，不但有 Java，还包括 JavaScript, C#，Go 等语言。 垃圾回收简介垃圾回收（Garbage Collection，简称 GC）这种内存管理机制最早由图灵奖获得者 John McCarthy 在 1959 年提出，垃圾回收的理论主要基于一个事实：大部分的对象的生命期都很短。 所以，GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到 Old 区。（其实还有一个 Perm 区，但是内存回收算法通常不涉及这个区域） Young 区和 Old 区因为对象的特点不一样，所以采用了两种完全不同的内存回收算法。 Young 区的对象因为大部分生命期都很短，每次回收之后只有少部分能够存活，所以采用的算法叫 Copying 算法，简单说来就是直接把活着的对象复制到另一个地方。Young 区内部又分成了三块区域：Eden 区 , From 区 , To 区。每次执行 Copying 算法时，即将存活的对象从 Eden 区和 From 区复制到 To 区，然后交换 From 区和 To 区的名字（即 From 区变成 To 区，To 区变成 From 区）。 Old 区的对象因为都是存活下来的老司机了，所以如果用 Copying 算法的话，很可能 90% 的对象都得复制一遍了，不划算啊！所以 Old 区的回收算法叫 Mark-Sweep 算法。简单来说，就是只是把不用的对象先标记（Mark）出来，然后回收（Sweep），活着的对象就不动它了。因为大部分对象都活着，所以回收下来的对象并不多。但是这个算法会有一个问题：它会产生内存碎片，所以它一般还会带有整理内存碎片的逻辑，在算法中叫做 Compact。如何整理呢？早年用过 Windows 的硬盘碎片整理程序的朋友可能能理解，其实就是把对象插到这些空的位置里。这里面还涉及很多优化的细节，我就不一一展开了。 讲完主要的算法，接下来 GC 需要解决的问题就只剩下如何找出需要回收的垃圾对象了。为了避免 ARC 解决不了的循环引用问题，GC 引入了一个叫做「可达性」的概念，应用这个概念，即使是有循环引用的垃圾对象，也可以被回收掉。下面就给大家介绍一下这个概念。 当 GC 工作时，GC 认为当前的一些对象是有效的，这些对象包括：全局变量，栈里面的变量等，然后 GC 从这些变量出发，去标记这些变量「可达」的其它变量，这个标记是一个递归的过程，最后就像从树根的内存对象开始，把所有的树枝和树叶都记成可达的了。那除了这些「可达」的变量，别的变量就都需要被回收了。 听起来很牛逼对不对？那为什么苹果不用呢？实际上苹果在 OS X 10.5 的时候还真用了，不过在 10.7 的时候把 GC 换成了 ARC。那么，GC 有什么问题让苹果不能忍，这就是：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所以说，你知道 Android 手机有时候为什么会卡吧，GC 就相当于春运的最后一天返城高峰。当所有的对象都需要一起回收时，那种体验肯定是当时还在世的乔布斯忍受不了的。 看看下面这幅漫画，真实地展现出 GC 最尴尬的情况（漫画中提到的 Full GC，就是指执行 Old 区的内存回收）： 当然，事实上经过多年的发展，GC 的回收算法一直在被优化，人们想了各种办法来优化暂停的时间，所以情况并没有那么糟糕。 ARC 相对于 GC 的优点：ARC 工作在编译期，在运行时没有额外开销。 ARC 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 GC 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。 ARC 相对于 GC 的缺点：GC 真的是太简单了，基本上完全不用处理内存管理问题，而 ARC 还是需要处理类似循环引用这种内存管理问题。 GC 一类的语言相对来说学习起来更简单。","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"LeetCode做题笔记—买卖股票的最佳时机系列题目","slug":"leetcode-best-time-to-buy-and-sell-stock-series","date":"2019-05-18T13:34:40.000Z","updated":"2021-11-07T12:02:15.280Z","comments":true,"path":"2019-05-18-leetcode-best-time-to-buy-and-sell-stock-series/","link":"","permalink":"https://paaatrick.com/2019-05-18-leetcode-best-time-to-buy-and-sell-stock-series/","excerpt":"这是一套经典的动态规划题目，题目主干都是给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格，在不同的情况下求在什么时候买卖以获取最大利润。","text":"这是一套经典的动态规划题目，题目主干都是给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格，在不同的情况下求在什么时候买卖以获取最大利润。 121题是只能买卖一次的情况下求最大利润； 122题可以买卖任意多次； 123题可以买卖两次； 188题是前面三题的泛化版本，给定参数k，求买卖k次情况下的最大利润； 309题是在122题买卖任意多次的基础上加上冷冻期即T+1才能卖出。 其中买卖k次的188题是标准的三维动态规划题，用解这题的通用方可以稍加改造就能解决前三题，当然前三题也有单独的特定简单解法，这里为了练习还是重点看动态规划的解决方法。 在188题的基础上可以再变形出更多题目，比如现在这些题都是最多只能持有1股，如果可以持有n股（每天只能买入或卖出1股），也能用这个188题的三维DP通解来解决。 121. 买卖股票的最佳时机 Best Time to Buy and Sell StockLeetCodeCN 第121题链接 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1:1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解：第一种方法：由于一次交易操作，可以通过记录最小价格，计算最大利润的方式，空间换时间，时间复杂度O(n) 1234567class Solution: def maxProfit(self, prices: List[int]) -&gt; int: res, low = 0, float('inf') for i in range(len(prices)): low = min(prices[i], low) res = max(res, prices[i] - low) return res 第二种方法：DP动态规划，与下面122题相比，由于只能一次交易操作，第i天的状态就不止“不持有”和“持有”两种状态，而是“未持有”、“持有”、“卖出”三种，并需要一个变量存储最大值 12345678910111213141516class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 # 生成数组, 然后给初始状态赋值 dp, res = [[0]*3 for _ in range(len(prices))], 0 dp[0][0], dp[0][1], dp[0][2] = 0, -prices[0], 0 for i in range(1, len(prices)): # dp[i][0] 第i天 一直没有股票的利润 # dp[i][1] 第i天 当前有股票的利润 取 max(前面有股票今天不卖, 前面没股票今天买入) # dp[i][2] 第i天 之前买入现在卖了的利润(前面有股票今天卖出) dp[i][0] = dp[i-1][0] dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1]) dp[i][2] = dp[i-1][1] + prices[i] res = max(res, dp[i][0], dp[i][2]) return res 122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock IILeetCodeCN 第122题链接 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解：第一种方法：深度优先搜索，时间复杂度O(2^n)，这个通过不了LeetCode，不过能work，测试了多组测试样例是正确的 123456789101112131415161718class Solution: def maxProfit(self, prices: List[int]) -&gt; int: self.prices = prices self.profit = [] self.helper(0, 0, 0) return max(self.profit) # have 0:未持有 1:持有 def helper(self, i, have, profit): if i == len(self.prices): self.profit.append(profit) return if have: # 如果持有中 self.helper(i+1, 0, profit + self.prices[i]) # 卖出 self.helper(i+1, 1, profit) # 不动 else: # 如果未持有 self.helper(i+1, 0, profit) # 不动 self.helper(i+1, 1, profit - self.prices[i]) # 买入 第二种方法：贪心算法，一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度O(n) 1234567class Solution: def maxProfit(self, prices: List[int]) -&gt; int: ans = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: ans += prices[i] - prices[i-1] return ans 第三种方法：标准二维DP动态规划，第i天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 n = len(prices) dp = [[0]*2 for _ in range(n)] # dp[i][0]表示第i天不持有股票, dp[i][1]表示第i天持有股票 dp[0][0], dp[0][1] = 0, - prices[0] for i in range(1, n): dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) return dp[n-1][0] 123. 买卖股票的最佳时机 III Best Time to Buy and Sell Stock IIILeetCodeCN 第123题链接 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 第一种方法：标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。与下面188题买卖股票4一样的代码，把交易k次定义为2次。当然也可以把内层的for循环拆出来，分别列出交易0次、1次、2次的状态转移方程即可 1234567891011121314151617181920class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 n = len(prices) dp = [[[0]*2 for _ in range(3)] for _ in range(n)] # dp[i][j][0]表示第i天交易了j次时不持有股票, dp[i][j][1]表示第i天交易了j次时持有股票 # 定义卖出股票时交易次数加1 for i in range(3): dp[0][i][0], dp[0][i][1] = 0, -prices[0] for i in range(1, n): for j in range(3): if not j: dp[i][j][0] = dp[i-1][j][0] else: dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j-1][1] + prices[i]) dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0] - prices[i]) return max(dp[n-1][0][0], dp[n-1][1][0], dp[n-1][2][0]) 第二种方法：用变量而不是多维数组保存迭代的值，优点是省内存空间，缺点是不是标准DP，没法泛化 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 buy1, sell1, buy2, sell2 = -prices[0], 0, -prices[0], 0 for i in range(1,len(prices)): buy1 = max(buy1,-prices[i]) #用负值统一变量 sell1 = max(sell1,buy1 + prices[i]) #sell1为 0~i(含)天股市中买卖一次的最优利润 buy2 = max(buy2,sell1 - prices[i]) #仅当＞0才会更新，保证 第二次买入不会与第一次卖出为同一天。而sell1为历史记录保证第二次买入比第一次卖出晚。 sell2 = max(sell2,buy2 + prices[i]) #若第二轮买卖为同一天，则不会更新。此操作自然保证sell2为买卖至多两次的最优利润。 return sell2 188. 买卖股票的最佳时机 IV Best Time to Buy and Sell Stock IVLeetCodeCN 第188题链接 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:123输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2:1234输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 解：标准的三维DP动态规划，三个维度，第一维表示天，第二维表示交易了几次，第三维表示是否持有股票。 首先初始化三维数组，填充第1天操作j次的没买或买了的情况的初始值，没买就是0，第一天就买入即-prices[0]。这里定义卖出操作时交易次数加1 然后是状态转移方程，下面描述的i, j都大于0 「第i天交易次数0不持有股票」的情况只能来自「第i-1天交易次数0不持有股票」； 「第i天交易j次不持有股票」的状态可以来自「第i-1天交易j次不持有股票」或者「第i-1天交易j-1次持有股票」(即今天卖出股票，然后交易次数+1)； 「第i天交易j次持有股票」的状态可以来自「第i-1天交易j次持有股票」或者「第i-1天交易j次不持有股票」(即今天买入股票，因为是买入操作所以交易次数不变) 最后对于这题LeetCode的测试样例里有超大k值的情况，退化成122题不限次数的操作，可以用贪心解决或者直接替换k值为数组长度的一半 12345678910111213141516171819202122232425262728293031323334class Solution: def maxProfit(self, k: int, prices: List[int]) -&gt; int: if not prices or not k: return 0 n = len(prices) # 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数 if k &gt; n//2: return self.greedy(prices) dp, res = [[[0]*2 for _ in range(k+1)] for _ in range(n)], [] # dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票 # 设定在卖出时加1次交易次数 for i in range(k+1): dp[0][i][0], dp[0][i][1] = 0, - prices[0] for i in range(1, n): for j in range(k+1): if not j: dp[i][j][0] = dp[i-1][j][0] else: dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j-1][1] + prices[i]) dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0] - prices[i]) # 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解 for m in range(k+1): res.append(dp[n-1][m][0]) return max(res) # 处理k过大导致超时的问题，用贪心解决 def greedy(self, prices): res = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: res += prices[i] - prices[i-1] return res 一个技巧：之前为了降低空间复杂度，需要改动很多代码来把DP数组降维（比如下面题目的方法二），其实可以在标准的DP解法基础上，把时间（天数）的维度稍加改动，用滚动数组，两个元素即可代替n个元素，有效降低空间复杂度，比如这题原本三维DP数组的空间复杂度是O(n×k×2)即O(n*k),用上滚动数组后就降为O(k×2)即O(k),性能提升比较显著。 滚动数组即用两个值 x, y, 在迭代 n 的时候, 赋值为 i&amp;1, (i-1)&amp;1, 利用位运算效果等同于 i%2, 即奇偶判断取1或0, 如此实现 x, y 交替0和1。需要注意一下迭代的起始值是1还是0。下面代码是对上面代码稍加改动的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def maxProfit(self, k: int, prices: List[int]) -&gt; int: if not prices or not k: return 0 n = len(prices) # 当k大于数组长度的一半时，等同于不限次数交易即122题，用贪心算法解决，否则LeetCode会超时，也可以直接把超大的k替换为数组的一半，就不用写额外的贪心算法函数 if k &gt; n//2: return self.greedy(prices) dp, res = [[[0]*2 for _ in range(k+1)] for _ in range(2)], [] # dp[i][k][0]表示第i天已交易k次时不持有股票 dp[i][k][1]表示第i天已交易k次时持有股票 # 设定在卖出时加1次交易次数 for i in range(k+1): dp[0][i][0], dp[0][i][1] = 0, - prices[0] for i in range(1, n): x, y = i&amp;1, (i-1)&amp;1 # 对 i 与 i-1 取奇偶, 令 x,y 交替 0和1, 实现滚动数组 # 可以减少一维DP数组, 降低空间复杂度 for j in range(k+1): if not j: dp[x][j][0] = dp[y][j][0] else: dp[x][j][0] = max(dp[y][j][0], dp[y][j-1][1] + prices[i]) dp[x][j][1] = max(dp[y][j][1], dp[y][j][0] - prices[i]) # 「所有交易次数最后一天不持有股票」的集合的最大值即为问题的解 for m in range(k+1): res.append(dp[0][m][0]) res.append(dp[1][m][0]) # 这里因为前面用了滚动数组 # 不知道最后一天的值在哪里 # 所以都加进去然后取最大值 return max(res) # 处理k过大导致超时的问题，用贪心解决 def greedy(self, prices): res = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i-1]: res += prices[i] - prices[i-1] return res 309. 最佳买卖股票时机含冷冻期 Best Time to Buy and Sell Stock with CooldownLeetCodeCN 第309题链接 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 解：第一种方法：标准DP动态规划，三个维度，第一维表示天，第二维表示是否处于冷冻期，第三维表示是否持有股票 12345678910111213class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 n = len(prices) dp = [[[0]*2 for _ in range(2)] for _ in range(n)] # dp[i][0][0]第一维表示第i天, 第二维用0,1表示是否处于冷冻期, 第三维用0,1表示是否持有股票 dp[0][0][0], dp[0][0][1], dp[0][1][0] = 0, -prices[0], 0 for i in range(1, n): dp[i][0][0] = max(dp[i-1][1][0], dp[i-1][0][0]) dp[i][1][0] = dp[i-1][0][1] + prices[i] dp[i][0][1] = max(dp[i-1][0][1], dp[i-1][0][0] - prices[i]) return max(dp[n-1][0][0], dp[n-1][1][0]) 第二种方法：优化版的动态规划，用两个维度处理，第一维表示天，第二维用0表示未持有，1表示持有股票中，2表示处于冷冻期 12345678910111213class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 n = len(prices) dp = [[0]*3 for _ in range(n)] # dp[i][0]表示第i天未持有, dp[i][1]表示持有股票, dp[i][2]表示前一天刚卖出今天处于冷冻期 dp[0][0], dp[0][1], dp[0][2] = 0, -prices[0], 0 for i in range(1, n): dp[i][0] = max(dp[i-1][0], dp[i-1][2]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) dp[i][2] = dp[i-1][1] + prices[i] return max(dp[n-1][0], dp[n-1][2])","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—位运算相关题目","slug":"leetcode-bitwise","date":"2019-05-13T01:35:25.000Z","updated":"2021-11-07T12:02:15.279Z","comments":true,"path":"2019-05-13-leetcode-bitwise/","link":"","permalink":"https://paaatrick.com/2019-05-13-leetcode-bitwise/","excerpt":"有关位运算的做题笔记，Python实现","text":"有关位运算的做题笔记，Python实现 191. 位1的个数 Number of 1 BitsLeetCodeCN 第191题链接 第一种方法：遍历所有二进制位，通过取模n%2或者与运算n&amp;1判断尾数是否为1，然后把n右移一位 1234567class Solution(object): def hammingWeight(self, n): count = 0 while n: count += n &amp; 1 n &gt;&gt;= 1 return count 第二种方法：通过n &amp; (n - 1)直接摘掉最后一位的1 1234567class Solution(object): def hammingWeight(self, n): count = 0 while n: count += 1 n = n &amp; (n - 1) return count 231. 2的幂 Power of TwoLeetCodeCN 第231题链接 先排除负数和0，由于2的幂的二进制只有第一位是1，通过n &amp; (n - 1)直接摘掉最后一位的1，如果摘掉后为0即符合条件 123class Solution(object): def isPowerOfTwo(self, n): return n &gt; 0 and not n &amp; (n - 1) 338. 比特位计数 Counting BitsLeetCodeCN 第338题链接 第一种方法：遍历，每次分别计算一次比特位，时间复杂度为n乘以每个数的1位个数 12345678910class Solution(object): def countBits(self, num): result = [] for i in range(num+1): count = 0 while i: count += 1 i = i &amp; (i - 1) result.append(count) return result 第二种方法：用一个递推式子count[i] = count[i&amp;(i-1)] + 1，原理是i&amp;(i-1)的1的个数总是比i少1，同时i&amp;(i-1)这个数肯定比i小，所以预先是算过的，这样时间复杂度为O(n) 123456class Solution(object): def countBits(self, num): result = [0] * (num+1) for i in range(1, num+1): result[i] = result[i&amp;(i-1)] + 1 return result","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—广度优先搜索、深度优先搜索、回溯、剪枝相关题目","slug":"leetcode-bfs-dfs-pruning","date":"2019-05-09T04:02:49.000Z","updated":"2021-11-07T12:02:15.279Z","comments":true,"path":"2019-05-09-leetcode-bfs-dfs-pruning/","link":"","permalink":"https://paaatrick.com/2019-05-09-leetcode-bfs-dfs-pruning/","excerpt":"有关BFS（广度优先搜索）与DFS（深度优先搜索）、回溯、剪枝的做题笔记，Python实现","text":"有关BFS（广度优先搜索）与DFS（深度优先搜索）、回溯、剪枝的做题笔记，Python实现 102. 二叉树的层次遍历 Binary Tree Level Order TraversalLeetCodeCN 第102题链接 第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，注意range(len(queue))使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度O(n) 123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 123456789101112131415161718192021222324import collectionsclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] result = [] queue = collections.deque() queue.append(root) # 如果不是树而是图的话要记录一下访问过的节点，避免重复访问 # visited = set(root) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result 第二种方法：DFS深度优先搜索，利用递归的栈，借助level记号把节点放入对应层，由于每个节点仅访问一次，所以时间复杂度O(n) 12345678910111213141516class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] self.result = [] self._dfs(root, 0) return self.result def _dfs(self, node, level): if not node: return if len(self.result) &lt; level + 1: self.result.append([]) self.result[level].append(node.val) self._dfs(node.left, level + 1) self._dfs(node.right, level + 1) 104. 二叉树的最大深度 Maximum Depth of Binary TreeLeetCodeCN 第104题链接 第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，range(len(queue))使只遍历当前的层，每次大循环ans加1。由于每个节点仅访问一次，所以时间复杂度O(n) 123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 1234567891011121314151617import collectionsclass Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 queue = collections.deque() queue.append(root) ans = 0 while queue: ans += 1 for _ in range(len(queue)): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return ans 第二种方法：DFS深度优先搜索，利用递归的栈，借助level标记当前层，由于每个节点仅访问一次，所以时间复杂度O(n) 123456789101112131415class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 self.ans = 0 self._dfs(root, 0) return self.ans def _dfs(self, node, level): if not node: return if self.ans &lt; level + 1: self.ans = level + 1 self._dfs(node.left, level + 1) self._dfs(node.right, level + 1) 第三种方法：DFS+分治，虽然代码简洁但耗时比上面两种方法都久 12345class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) 111. 二叉树的最小深度 Minimum Depth of Binary TreeLeetCodeCN 第111题链接 第一种方法：BFS广度优先搜索，使用双端队列deque（因为性能比另外两种Queue好得多），在大循环内对二叉树的每个层做一次遍历，range(len(queue))使只遍历当前的层。由于每个节点仅访问一次，所以时间复杂度O(n) 123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 123456789101112131415161718import collectionsclass Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 ans = 0 queue = collections.deque() queue.append(root) while queue: ans += 1 for _ in range(len(queue)): node = queue.popleft() if node.left is None and node.right is None: return ans if node.left: queue.append(node.left) if node.right: queue.append(node.right) 第二种方法：DFS深度优先搜索，利用递归的栈，借助level标记当前层，由于每个节点仅访问一次，所以时间复杂度O(n) 123456789101112131415161718class Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 self.ans = float('inf') self._dfs(root, 0) return self.ans def _dfs(self, node, level): if not node: return if node.left is None and node.right is None: if self.ans &gt; level + 1: self.ans = level + 1 return self._dfs(node.left, level + 1) self._dfs(node.right, level + 1) 22. 括号生成 Generate ParenthesesLeetCodeCN 第22题链接 DFS+剪枝，利用左括号与右括号分别已用的参数，当两个参数都为n时即填完一个结果添加进结果数组，精髓在于if left_used &gt; right_used，只有在右括号少于左括号时才能填充右括号，保证输出的结果是合法的 1234567891011121314class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: self.ans = [] self.helper(0, 0, n, '') return self.ans def helper(self, left_used: int, right_used: int, n: int, result: str): if left_used == n and right_used == n: self.ans.append(result) return if left_used &lt; n: self.helper(left_used + 1, right_used, n, result + '(') if left_used &gt; right_used and right_used &lt; n: self.helper(left_used, right_used + 1, n, result + ')') 51. N皇后 N-Queens / 52. N皇后 II N-Queens IILeetCodeCN 第51题链接LeetCodeCN 第52题链接 用三个set()记录矩阵内因放入皇后而封住的格子，self.col是列，self.sum是row+col表示的 ‘/‘ 方向 self.dif是row-col表示的 ‘\\‘ 方向。 用深度优先搜索方法，逐行递归下去，递归终止条件是行数加到n时，此时即生成了一种解决方案，放入结果数组。 每次递归内迭代列col检查这个点位是否能放下，能放下的话把自身点位加入三个set内，继续下个递归，参数state数组append这一行的列值 col。 递归函数后记得清除因放入自己的影响即三个set。 最后为51题生成结果图的函数_gen。 123456789101112131415161718192021222324252627282930313233343536373839class Solution: def solveNQueens(self, n: int) -&gt; List[List[str]]: self.result = [] self.col = set() self.sum = set() self.dif = set() self._dfs(n, 0, []) # 51题: 输出点阵图 return self._gen(n) # 52题: 输出结果数量 # return len(self.result) def _dfs(self, n, row, state): if row &gt;= n: self.result.append(state) return for col in range(n): if col in self.col or row+col in self.sum or row-col in self.dif: continue self.col.add(col) self.sum.add(row + col) self.dif.add(row - col) self._dfs(n, row + 1, state + [col]) self.col.remove(col) self.sum.remove(row + col) self.dif.remove(row - col) def _gen(self, n): result = [] for res in self.result: graph = [] for i in res: graph.append('.'*i + 'Q' + '.'*(n-i-1)) result.append(graph) return result 37. 解数独 Sudoku SolverLeetCodeCN 第37题链接 DFS朴素解法 1234567891011121314151617181920212223242526272829303132class Solution: def solveSudoku(self, board: List[List[str]]) -&gt; None: \"\"\" Do not return anything, modify board in-place instead. \"\"\" if board is None or not len(board): return self.solve(board) def solve(self, board: List[List[str]]) -&gt; bool: for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == '.': for c in [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"]: if self.isValid(board, i, j, c): board[i][j] = c if self.solve(board): return True else: board[i][j] = '.' return False return True def isValid(self, board, row, col, c) -&gt; bool: for i in range(9): if board[row][i] != '.' and board[row][i] == c: return False if board[i][col] != '.' and board[i][col] == c: return False if board[3 * (row//3) + i//3][3 * (col//3) + i%3] != '.' and board[3 * (row//3) + i//3][3 * (col//3) + i%3] == c: return False return True 36. 有效的数独 Valid Sudoku第一种方法：利用collections的defaultdict数据结构记录 1234567891011121314151617import collections as clclass Solution: def isValidSudoku(self, board) -&gt; bool: if not board or not len(board): return False self.row, self.col, self.box = cl.defaultdict(set), cl.defaultdict(set), cl.defaultdict(set) for r in range(9): for c in range(9): if board[r][c] != '.': if board[r][c] not in self.row[r] and board[r][c] not in self.col[c] and board[r][c] not in self.box[(r//3, c//3)]: self.row[r].add(board[r][c]) self.col[c].add(board[r][c]) self.box[(r//3, c//3)].add(board[r][c]) else: return False return True 第二种方法：不用额外空间，直接循环检测 12345678910111213141516171819202122232425class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: if not board or not len(board): return False for r in range(9): for c in range(9): if board[r][c] != '.': if self.isValid(board, r, c, board[r][c]): continue else: return False return True def isValid(self, board, row, col, c) -&gt; bool: board[row][col] = '.' for i in range(9): if board[row][i] != '.' and board[row][i] == c: return False if board[i][col] != '.' and board[i][col] == c: return False if board[3 * (row//3) + i//3][3 * (col//3) + i%3] != '.' and board[3 * (row//3) + i//3][3 * (col//3) + i%3] == c: return False board[row][col] = c return True 69. x 的平方根 Sqrt(x)LeetCodeCN 第69题链接 第一种方法：二分查找，题目奇怪要求返回整数 12345678910111213class Solution: def mySqrt(self, x: int) -&gt; int: if x == 1 or x == 0: return x l, r = 1, x while l &lt; r: mid = l + (r - l)//2 if mid*mid &lt;= x &lt; (mid+1)*(mid+1): return mid elif mid*mid &lt; x: l = mid else: r = mid 第二种方法：牛顿迭代法，$X_{n+1} = x_n - \\frac{f(x_n)}{f’(x_n)}$，这里的$f(x_n)$是$x^2 - y_0$，即得迭代公式$x_{n+1} = (x_n + \\frac{y_0}{x_n}) / 2 $ 12345678class Solution: def mySqrt(self, x: int) -&gt; int: if x &lt;= 1: return x r = x while r &gt; x / r: r = (r + x / r)//2 return int(r)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—递归、分治相关题目","slug":"leetcode-recursion-divide-conquer","date":"2019-05-07T02:45:27.000Z","updated":"2021-11-07T12:02:15.279Z","comments":true,"path":"2019-05-07-leetcode-recursion-divide-conquer/","link":"","permalink":"https://paaatrick.com/2019-05-07-leetcode-recursion-divide-conquer/","excerpt":"有关递归与分治的做题笔记，Python实现","text":"有关递归与分治的做题笔记，Python实现 50. Pow(x, n)LeetCodeCN 第50题链接 第一种方法：暴力乘法，时间复杂度O(n)，LeetCode会超时 1234567891011121314151617class Solution: def myPow(self, x: float, n: int) -&gt; float: if n == 1: return x if n == -1: return 1/x if not n: return 1 if n &lt; 0: res = 1/x for i in range(abs(n)-1): res = res*(1/x) else: res = x for i in range(abs(n)-1): res = res*x return res 第二种方法：分治（递归） ，时间复杂度O(logn) 123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) if n % 2: return x * self.myPow(x, n - 1) return self.myPow(x * x, n / 2) 稍微改成下面这样容易理解一些 12345678910class Solution: def myPow(self, x: float, n: int) -&gt; float: if not n: return 1 if n &lt; 0: return 1/self.myPow(x, -n) if n &amp; 1: return self.myPow(x, n - 1) * x res = self.myPow(x, n&gt;&gt;1) return res*res 第二种方法：循环 1234567891011121314class Solution: def myPow(self, x: float, n: int) -&gt; float: if n &lt; 0: x = 1 / x n = -n ans = 1 while n: # n&amp;1 是与运算，用来求奇偶，效果与 n%2 一样 if n &amp; 1: ans *= x x = x * x # n&gt;&gt;=1 是位运算，右移一位，效果与 n//=2 一样 n &gt;&gt;= 1 return ans 169. 求众数 Majority ElementLeetCodeCN 第169题链接 第一种方法：两重循环暴力求解，时间复杂度O(n^2)，LeetCode会超时 123456789class Solution: def majorityElement(self, nums: List[int]) -&gt; int: for i in range(len(nums)): count = 1 for j in range(i+1, len(nums)): if nums[i] == nums[j]: count += 1 if count &gt; len(nums) / 2: return nums[i] 第二种方法：哈希表记录每个元素出现次数，发现出现超过n/2的就是众数，时间复杂度O(n) 12345678910111213class Solution: def majorityElement(self, nums: List[int]) -&gt; int: leng = len(nums) if leng == 1: return nums[0] dic = &#123;&#125; for i in nums: if i in dic: dic[i] += 1 if dic[i] &gt;= leng / 2: return i else: dic[i] = 1 第三种方法：排序后直接返回中间值，因为题目限定条件必然存在众数，时间复杂度O(n*logn) 12def majorityElement(self, nums: List[int]) -&gt; int: return sorted(nums)[len(nums)//2] 第四种方法：用list.count()方法 12345def majorityElement(self, nums: List[int]) -&gt; int: # 此处如果遍历整个nums会超时 for i in nums[len(nums)//2:]: if nums.count(i) &gt; len(nums)//2: return i 第五种方法：分治，时间复杂度O(n*logn) 123456789101112131415161718def majorityElement(self, nums): if not nums: return None if len(nums) == 1: return nums[0] a = self.majorityElement(nums[:len(nums)//2]) b = self.majorityElement(nums[len(nums)//2:]) if a == b: return a return [b, a][nums.count(a) &gt; len(nums)//2] # 这个 return 的写法等同于下面的 if else # 因为若后一个[]里为True即1所以取[b,a][1]=a, False即0取[b,a][0]=b # # if nums.count(a) &gt; len(nums)//2: # return a # else: # return b","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"考察ObjC对象内存结构与isa指针","slug":"ios-object-struct-isa","date":"2019-05-05T05:07:42.000Z","updated":"2021-11-07T12:02:15.278Z","comments":true,"path":"2019-05-05-ios-object-struct-isa/","link":"","permalink":"https://paaatrick.com/2019-05-05-ios-object-struct-isa/","excerpt":"考察ObjC对象内存结构与isa指针 1. 一个 Objective-C 对象的内存结构是怎样的？","text":"考察ObjC对象内存结构与isa指针 1. 一个 Objective-C 对象的内存结构是怎样的？ 如果把类的实例看成一个C语言的结构体（struct），它首先包含的是一个 isa 指针，而类的其它成员变量依次排列在结构体中。排列顺序如下图所示： 为了验证该说法，我们在Xcode中新建一个工程，在main.m中运行如下代码： 1234567891011121314151617181920212223242526#import &lt;UIKit/UIKit.h&gt;@interface Father : NSObject &#123; int _father;&#125;@end@implementation Father@end@interface Child : Father &#123; int _child;&#125;@end@implementation Child@endint main(int argc, char * argv[])&#123; Child * child = [[Child alloc] init]; @autoreleasepool &#123; // ... &#125;&#125; 我们将断点下在 @autoreleasepool 处，然后在Console中输入p *child,则可以看到Xcode输出如下内容，这与我们上面的说法一致。 12345678910(lldb) p *child(Child) $0 = &#123; (Father) Father = &#123; (NSObject) NSObject = &#123; (Class) isa = Child &#125; (int) _father = 0 &#125; (int) _child = 0&#125; 因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。 注：需要特别说明一下，通过 objc_setAssociatedObject和 objc_getAssociatedObject方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。 2. Objective-C 对象内存结构中的 isa 指针是用来做什么的，有什么用？Objective-C 是一门面向对象的编程语言。每一个对象都是一个类的实例。在 Objective-C 语言的内部，每一个对象都有一个名为 isa 的指针，指向该对象的类。每一个类描述了一系列它的实例的特点，包括成员变量的列表，成员函数的列表等。每一个对象都可以接受消息，而对象能够接收的消息列表是保存在它所对应的类中。 在 Xcode 中按Shift + Command + O, 然后输入 NSObject.h 和 objc.h，可以打开 NSObject 的定义头文件，通过头文件我们可以看到，NSObject 就是一个包含 isa 指针的结构体，如下图所示： 按照面向对象语言的设计原则，所有事物都应该是对象（严格来说 Objective-C 并没有完全做到这一点，因为它有象 int, double 这样的简单变量类型，而 Swift 语言，连 int 变量也是对象）。在 Objective-C 语言中，每一个类实际上也是一个对象。每一个类也有一个名为 isa 的指针。每一个类也可以接受消息，例如代码[NSObject alloc]，就是向 NSObject 这个类发送名为alloc消息。 在 Xcode 中按Shift + Command + O, 然后输入 runtime.h，可以打开 Class 的定义头文件，通过头文件我们可以看到，Class 也是一个包含 isa 指针的结构体，如下图所示。（图中除了 isa 外还有其它成员变量，但那是为了兼容非 2.0 版的 Objective-C 的遗留逻辑，大家可以忽略它。） 因为类也是一个对象，那它也必须是另一个类的实例，这个类就是元类 (metaclass)。元类保存了类方法的列表。当一个类方法被调用时，元类会首先查找它本身是否有该类方法的实现，如果没有，则该元类会向它的父类查找该方法，直到一直找到继承链的头。 元类 (metaclass) 也是一个对象，那么元类的 isa 指针又指向哪里呢？为了设计上的完整，所有的元类的 isa 指针都会指向一个根元类 (root metaclass)。根元类 (root metaclass) 本身的 isa 指针指向自己，这样就行成了一个闭环。上面提到，一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中，我们几乎不会遇到向元类发消息的情况，那它的 isa 指针在实际上很少用到。不过这么设计保证了面向对象概念在 Objective-C 语言中的完整，即语言中的所有事物都是对象，都有 isa 指针。 我们再来看看继承关系，由于类方法的定义是保存在元类 (metaclass) 中，而方法调用的规则是，如果该类没有一个方法的实现，则向它的父类继续查找。所以，为了保证父类的类方法可以在子类中可以被调用，所以子类的元类会继承父类的元类，换而言之，类对象和元类对象有着同样的继承关系。 我很想把关系说清楚一些，但是这块儿确实有点绕，我们还是来看图吧，很多时候图象比文字表达起来更为直观。下面这张图或许能够让大家对 isa 和继承的关系清楚一些： 我们可以从图中看出： NSObject 的类中定义了实例方法，例如 -(id)init 方法 和 - (void)dealloc 方法。 NSObject 的元类中定义了类方法，例如 +(id)alloc 方法 和 + (void)load 、+ (void)initialize 方法。 NSObject 的元类继承自 NSObject 类，所以 NSObject 类是所有类的根，因此 NSObject 中定义的实例方法可以被所有对象调用，例如 - (id)init 方法 和 - (void)dealloc 方法。 NSObject 的元类的 isa 指向自己。 isa swizzling 的应用系统提供的 KVO 的实现，就利用了动态地修改 isa 指针的值的技术。在 苹果的文档中可以看到如下描述： 123456789Key-Value Observing Implementation DetailsAutomatic key-value observing is implemented using a technique called isa-swizzling.The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"LeetCode做题笔记—二叉树相关题目","slug":"leetcode-tree","date":"2019-05-04T06:29:10.000Z","updated":"2021-11-07T12:02:15.278Z","comments":true,"path":"2019-05-04-leetcode-tree/","link":"","permalink":"https://paaatrick.com/2019-05-04-leetcode-tree/","excerpt":"有关二叉树的做题笔记，Python实现","text":"有关二叉树的做题笔记，Python实现 二叉树的定义123456# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None 226. 翻转二叉树 Invert Binary TreeLeetCodeCN 第226题链接 第一种方法：递归 12345class Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: if root: root.left, root.right = self.invertTree(root.right), self.invertTree(root.left) return root 第二种方法：遍历 12345678910class Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: stack = [root] while stack: node = stack.pop() if node: node.left, node.right = node.right, node.left stack.append(node.left) stack.append(node.right) return root 98. 验证二叉搜索树 Validate Binary Search TreeLeetCodeCN 第98题链接 第一种方法：中序遍历二叉树存入数组，与直接升序排序去重后的原二叉树对比 123456789class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: inorder = self.inorder(root) return inorder == list(sorted(set(inorder))) def inorder(self, root) -&gt; list: if root is None: return [] return self.inorder(root.left) + [root.val] + self.inorder(root.right) 第二种方法：中序遍历只用比较前一节点的值是否小于当前节点的值即可，不用储存 1234567891011121314class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: self.prev = None return self.helper(root) def helper(self, root): if root is None: return True if not self.helper(root.left): return False if self.prev and self.prev.val &gt;= root.val: return False self.prev = root return self.helper(root.right) 第三种方法：递归验证每个节点左孩子的值是否小于父亲节点的值以及右孩子的值是否大于父亲节点的值 1234567891011class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: mini, maxi = float('-inf'), float('inf') return self.isValid(root, mini, maxi) def isValid(self, root: TreeNode, mini: int, maxi: int) -&gt; bool: if root is None: return True if mini &gt;= root.val or maxi &lt;= root.val: return False return self.isValid(root.left, mini, root.val) and self.isValid(root.right, root.val, maxi) 236. 二叉树的最近公共祖先 Lowest Common Ancestor of a Binary TreeLeetCodeCN 第236题链接 首先如果root为空，返回root，然后如果root就是p或者q，那root就是最近公共祖先。然后分别对左子树和右子树做递归并保存结果，如果两边都能找到，证明本节点就是最近公共祖先，如果一边找得到，一边找不到，则往能找到的那边继续找下去。 1234567891011121314151617class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if root is None: return None if root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left or right: if left is None: return right elif right is None: return left else: return root else: return None 235. 二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search TreeLeetCodeCN 第235题链接 第一种方法：还用上面的方法 第二种方法：利用二叉搜索树的左子树都小于父亲节点，右子树都大于父亲节点的特性，可以把第一种方法简化一下 1234567class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if p.val &lt; root.val and q.val &lt; root.val: return self.lowestCommonAncestor(root.left, p, q) if p.val &gt; root.val and q.val &gt; root.val: return self.lowestCommonAncestor(root.right, p, q) return root 第三种方法：跟方法二的思路一样，把递归改成循环 12345678def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': while root: if p.val &lt; root.val and q.val &lt; root.val: root = root.left elif p.val &gt; root.val and q.val &gt; root.val: root = root.right else: return root 112. 路径总和 Path SumLeetCodeCN 第112题链接 第一种方法：DFS，用一个数组记录每条路线的路径和，最后检查目标值是否在数组内 12345678910111213141516171819class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if not root: return False self.res = [] self.dfs(root, 0) if sum in self.res: return True else: return False def dfs(self, node, tmp): if not node.left and not node.right: self.res.append(tmp+node.val) return if node.left: self.dfs(node.left, tmp+node.val) if node.right: self.dfs(node.right, tmp+node.val) 第二种方法：每次递归时从目标值里扣除自身节点的值，如果到某个叶子节点正好剩余目标值等于叶子节点的值说明存在该路径 12345678class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if not root: return False if not root.left and not root.right and sum == root.val: return True sum -= root.val return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—哈希表相关题目","slug":"leetcode-hashtable","date":"2019-05-01T07:18:53.000Z","updated":"2021-11-07T12:02:15.278Z","comments":true,"path":"2019-05-01-leetcode-hashtable/","link":"","permalink":"https://paaatrick.com/2019-05-01-leetcode-hashtable/","excerpt":"有关哈希表的做题笔记，Python实现","text":"有关哈希表的做题笔记，Python实现 242. 有效的字母异位词 Valid AnagramLeetCodeCN 第242题链接 第一种方法：对两个字符串排序后对比 123class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: return sorted(s) == sorted(t) 第二种方法：用哈希表对字符串内每个字符计数，最后比对哈希表，这里用dict实现 12345678class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: map1, map2 = &#123;&#125;, &#123;&#125; for i in s: map1[i] = map1.get(i, 0) + 1 for j in t: map2[j] = map2.get(j, 0) + 1 return map1 == map2 第三种方法：由于只有26个小写字母元素，可以用数组自己实现一个哈希表，原理与上面一样 12345678class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: map1, map2 = [0]*26, [0]*26 for c in s: map1[ord(c)-ord('a')] += 1 for d in t: map2[ord(d)-ord('a')] += 1 return map1 == map2 1. 两数之和 Two SumLeetCodeCN 第1题链接 第一种方法：用哈希表，时间复杂度是O(n) 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dic = &#123;&#125; for i in range(len(nums)): if nums[i] in dic: return [dic[nums[i]], i] else: dic[target - nums[i]] = i 第二种方法：暴力两重遍历，这样时间复杂度是O(n^2)，在LeetCode里提交会超时 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i] + nums[j] == target: return [i, j] 15. 三数之和 3SumLeetCodeCN 第15题链接 第一种方法：三重遍历，时间复杂度为O(n^3) 第二种方法：两重遍历得到前两个数，然后查询第三个数-(a+b)是否存在。用哈希表set() 1234567891011121314151617181920class Solution(object): def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" if len(nums) &lt; 3: return [] nums.sort() res = set() for i, v in enumerate(nums[:-2]) : if i &gt;= 1 and v == nums[i-1]: continue d = &#123;&#125; for x in nums[i+1:]: if x not in d: d[-(v+x)] = 1 else: res.add((v, -(v+x), x)) return map(list, res) 第三种方法：先升序排序，一遍遍历，然后在后面的新数组里用双指针检查三个数之和是否为0，大于0则右指针向左走，小于0则左指针向右走。 12345678910111213141516171819202122232425class Solution(object): def threeSum(self, nums): if len(nums) &lt; 3: return [] nums.sort() res = [] for i, x in enumerate(nums[:-2]): if i &gt;= 1 and x == nums[i-1]: continue l, r = i+1, len(nums)-1 while l &lt; r: s = nums[i] + nums[l] + nums[r] if s &lt; 0: l += 1 elif s &gt; 0: r -= 1 else: res.append((nums[i], nums[l], nums[r])) while l &lt; r and nums[l] == nums[l+1]: l += 1 while l &lt; r and nums[r] == nums[r-1]: r -= 1 l += 1 r -= 1 return res 146. LRU缓存机制 LRU CacheLeetCodeCN 第146题链接 利用 Python collections 库内的顺序哈希表 OrderedDict() 类可以很方便地实现 一般LRU缓存是通过哈希表配合双向链表实现的。如图所示，哈希表使访问查找的时间复杂度为O(1)，双向链表可以获得前驱节点使删除操作也是O(1) 12345678910111213141516171819202122232425262728from collections import OrderedDictclass LRUCache: def __init__(self, capacity: int): self.dic = OrderedDict() self.remain = capacity def get(self, key: int) -&gt; int: if key not in self.dic: return -1 item = self.dic[key] self.dic.pop(key) self.dic[key] = item return item def put(self, key: int, value: int) -&gt; None: if key in self.dic: self.dic.pop(key) else: if self.remain &gt; 0: self.remain -= 1 else: self.dic.popitem(last=False) self.dic[key] = value# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—栈、堆、队列相关题目","slug":"leetcode-stack-heap-queue","date":"2019-04-29T05:32:28.000Z","updated":"2021-11-07T12:02:15.278Z","comments":true,"path":"2019-04-29-leetcode-stack-heap-queue/","link":"","permalink":"https://paaatrick.com/2019-04-29-leetcode-stack-heap-queue/","excerpt":"有关栈、堆、队列的做题笔记，Python实现","text":"有关栈、堆、队列的做题笔记，Python实现 栈 Stack20. 有效的括号 Valid ParenthesesLeetCodeCN 第20题链接 使用 Stack 栈 来操作，用了一个技巧是先做一个字典，key为右括号，value为左括号。 12345678910class Solution: def isValid(self, s: str) -&gt; bool: stack = [] mapping = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; for c in s: if c not in mapping: stack.append(c) elif not stack or mapping[c] != stack.pop(): return False return not stack 71. 简化路径 Simplify PathLeetCode 第71题链接 使用栈，遍历用/分割后的字符串数组，此时字符串不存在斜杠了，当字符不是空字符或.、..时即正常路径名压入栈中，当遇到空字符或者.时略过，当遇到..时pop一下即返回上级目录。 123456789class Solution: def simplifyPath(self, path: str) -&gt; str: stack = [] for i in path.split('/'): if i not in ['', '.', '..']: stack.append(i) elif i == '..' and stack: stack.pop() return '/' + '/'.join(stack) 堆 Heap703. 数据流中的第K大元素 Kth Largest Element in a StreamLeetCodeCN 第703题链接 第一种方法：直接对整个nums降序排序，然后取第k个元素返回，add时每次都再加入进nums然后排序一次，这样add操作的时间复杂度为O(n*logn)，n是nums的长度 1234567891011121314class KthLargest: def __init__(self, k: int, nums: List[int]): self.nums = nums self.k = k self.nums.sort(reverse = True) while len(self.nums) &gt; k: self.nums.pop() def add(self, val: int) -&gt; int: self.nums.append(val) self.nums.sort(reverse = True) if len(self.nums) &gt; self.k: self.nums.pop() return self.nums[-1] 第二种方法：维护一个长度为k的数组，初始化时赋值为降序排序后的nums的前k个元素，add操作时先看如果数组长度小于k的话就直接加进去然后排序一次，否则就判断如果val大于数组末尾的元素就将末尾元素剔除并加入val然后排序一次，如果val小于等于数组末尾的元素就不操作，这样add操作的时间复杂度为O(k*logk)，k是数组k的长度 1234567891011121314class KthLargest: def __init__(self, k: int, nums: List[int]): self.kl = sorted(nums, reverse=True)[:k] self.k = k def add(self, val: int) -&gt; int: if len(self.kl) &lt; self.k: self.kl.append(val) self.kl.sort(reverse=True) elif val &gt; self.kl[-1]: self.kl.pop() self.kl.append(val) self.kl.sort(reverse=True) return self.kl[-1] 第三种方法：使用小顶堆实现的优先队列，Python 中标准库 heapq 就是小顶堆，首先将nums堆化，然后pop元素直到堆的长度为k，add操作时如果堆中元素不满k个就直接把值push进堆，如果值大于堆顶元素则更新堆，时间复杂度降低为O(logk) 123456789101112131415161718import heapqclass KthLargest: def __init__(self, k: int, nums: List[int]): self.pool, self.k = nums, k heapq.heapify(self.pool) while len(self.pool) &gt; k: heapq.heappop(self.pool) def add(self, val: int) -&gt; int: if len(self.pool) &lt; self.k: heapq.heappush(self.pool, val) elif val &gt; self.pool[0]: heapq.heapreplace(self.pool, val) return self.pool[0]# Your KthLargest object will be instantiated and called as such:# obj = KthLargest(k, nums)# param_1 = obj.add(val) 215. 数组中的第K个最大元素 Kth Largest Element in an ArrayLeetCodeCN 第215题链接 第一种方法：用库函数排序直接返回第k大的元素，时间复杂度O(n*logn) 123class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: return sorted(nums, reverse=True)[k-1] 第二种方法：与上题一样，使用小顶堆实现的优先队列，一般情况下时间复杂度为O(k + (n-k)*logk)，当n极大时，时间复杂度为O(n*logk) 123456789import heapqclass Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: heap = nums[:k] heapq.heapify(heap) for i in nums[k:]: if i &gt; heap[0]: heapq.heapreplace(heap, i) return heap[0] 239. 滑动窗口最大值 Sliding Window MaximumLeetCodeCN 第239题链接 第一种方法：用优先队列：大顶堆 第二种方法：因为窗口大小固定，只需要一个双端队列即可 1234567891011121314class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: if not nums: return [] window, res = [], [] for i, x in enumerate(nums): if i &gt;= k and window[0] &lt;= i - k: window.pop(0) while window and nums[window[-1]] &lt;= x: window.pop() window.append(i) if i &gt;= k - 1: res.append(nums[window[0]]) return res","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"LeetCode做题笔记—链表相关题目","slug":"leetcode-linklist","date":"2019-04-28T08:52:35.000Z","updated":"2021-11-07T12:02:15.278Z","comments":true,"path":"2019-04-28-leetcode-linklist/","link":"","permalink":"https://paaatrick.com/2019-04-28-leetcode-linklist/","excerpt":"有关链表的做题笔记，Python实现","text":"有关链表的做题笔记，Python实现 链表定义12345# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = None 206. 反转链表 Reverse Linked ListLeetCodeCN 第206题链接 遍历链表，迭代前节点prev，缓存当前节点current的下一节点，然后把当前节点的next指针指向前节点prev 12345678910class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: current = head prev = None while current: tmp = current.next current.next = prev prev = current current = tmp return prev 用Python三元交换能同时赋值不需要缓存的特性可以一行完成交换 1234567class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: current = head prev = None while current: current.next, prev, current = prev, current, current.next return prev 24. 两两交换链表中的节点 Swap Nodes in PairsLeetCodeCN 第24题链接 记录当前节点的前一个节点，当当前节点和下一节点都存在时，三元交换三个节点的next指针返回交换完后的首节点 12345678class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: prev, prev.next = self, head while prev.next and prev.next.next: l, r = prev.next, prev.next.next prev.next, l.next, r.next = r, r.next, l prev = l return self.next 看到好多小伙伴在问，我来尝试解释一下“链表交换相邻元素”中 self 是怎么回事。1.首先看到最后 return self.next ，可以看到作者是想把 self 当做链表的头指针使用的（注意：头指针 pHead 与传入的参数 head 是不同的，head 是第一个结点，而 pHead.next == next ）。用头指针有什么好处呢？因为我们让头指针的 next 域（pHead.next）永远指向第一个结点，就是避免最后返回的时候找不到第一个结点了。2.那么作者为什么可以 pre, pre.next = self, head 这样写呢？因为 self 是这个类的一个对象，所以在类定义的时候可以在任何地方，给 self 增加新的属性。相信大家都知道在 init(self, attr) 里面可以定义通过 self.myattr = attr 来定义一个 myattr 属性。其实这个语句写在任意一个类的方法里都可以，所以在原文 swapPairs() 里面当然也可以定义新的属性。所以这行代码应该理解为，pre 指向 self（虽然 self 不是一个 ListNode 类型的对象，但它只要有一个 next 就可以了），同时为 pre（同时也是为 self，它们是一样的现在）增加一个 next 属性，这个 next 属性指向第一个结点 head。3.明白上面之后，这里就好办了。在第一次 while 循环的时候，pre.next 被赋值为 b（也就是原来第二个结点，转换为变成了第一个，也就成为了新链表的第一个结点。如果原来是[1,2,3,4]，那么现在就是[2,1,3,4]，这个 self.next 就是指向 2 这个结点）。所以最后只要返回 self.next 就得到了答案。其实换个写法大家就好理解很多了：pHead = ListNode(None)pre, pre.next = pHead, head也就是说不用 self 也可以，只是原作者秀了一把小技巧而已。 123456789class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: pHead = ListNode(None) prev, prev.next = pHead, head while prev.next and prev.next.next: l, r = prev.next, prev.next.next prev.next, l.next, r.next = r, r.next, l prev = l return pHead.next 141. 环形链表 Linked List CycleLeetCodeCN 第141题链接 三种方法1.硬做，可以设置超时或者固定循环次数，不靠谱2.做记号，使用set来储存遍历过的节点，需要额外内存空间3.快慢指针，慢指针每次前移一个节点，快指针每次前移两个节点，如果链表存在循环那快慢指针肯定会相遇 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution(object): # 1.硬做 def hasCycle1(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" if not head: return False curr = head for i in range(100000): curr = curr.next if not curr: return False return True # 2.set记录 def hasCycle2(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" rec = set() curr = head while curr: if curr in rec: return True rec.add(curr) curr = curr.next return False # 3.快慢指针 def hasCycle3(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" slow = fast = head while slow and fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False 142. 环形链表 II Linked List Cycle IILeetCodeCN 第142题链接 第一种方法还是上面的用哈希表set来记录，占用空间 123456789class Solution(object): def detectCycle(self, head): curr, rec = head, set() while curr: if curr in rec: return curr rec.add(curr) curr = curr.next return None 第二种方法用快慢指针，先如上题一样检测是否有环，有的话设置一个新的检测节点从头(head)开始迭代，同时slow节点也继续迭代，直到二者相遇的点就是环的入口节点。 原理：首先，头结点到入环结点的距离为a，入环结点到相遇结点的距离为b，相遇结点到入环结点的距离为c。然后，当f以s的两倍速度前进并和s相遇时，f走过的距离是s的两倍，即有等式：a+b+c+b = 2(a+b) ，可以得出 a = c ，所以说，让fast和slow分别从相遇结点和头结点同时同步长出发，他们的相遇结点就是入环结点。当快、慢指针同时从入环点出发，那么一定会在入环点相遇。如果快、慢指针同时从入环点前一节点出发，那么快慢、指针则会在入环点的前一节点相遇，以此类推。 1234567891011121314151617class Solution(object): def detectCycle(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" slow = fast = head while slow and fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: detection = head while slow != detection: slow = slow.next detection = detection.next return detection return None 25. k个一组翻转链表 Reverse Nodes in k-GroupLeetCodeCN 第25题链接 第一种方法：利用数组来实现k个一组的翻转，然后重新连接成链表 12345678910111213141516class Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: arr, i = [], 0 if not head: return None while head: arr.append(head) head = head.next while i &lt;= len(arr) - k: arr[i:i+k] = arr[i:i+k][::-1] i += k for j in range(len(arr) - 1): arr[j].next = arr[j+1] if arr: arr[-1].next = None return arr[0] 第二种方法：用栈，我们把 k 个数压入栈中，然后弹出来的顺序就是翻转的。这里要注意几个问题：1.剩下的链表个数够不够 k 个（因为不够 k 个不用翻转）；2.已经翻转的部分要与剩下链表连接起来 12345678910111213141516171819202122232425class Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: dummy = ListNode(0) p = dummy while True: count = k stack = [] tmp = head while count and tmp: stack.append(tmp) tmp = tmp.next count -= 1 # 注意,目前tmp所在k+1位置 # 说明剩下的链表不够k个,跳出循环 if count : p.next = head break # 翻转操作 while stack: p.next = stack.pop() p = p.next #与剩下链表连接起来 p.next = tmp head = tmp return dummy.next 第三种方法：递归，利用206题反转链表的函数稍加改造，添加一个count参数提前结束反转。每次递归主函数时即处理当前k个的反转然后链表尾端接上下一个递归的值，注意其中第12行的head.next，因为经过上一行的反转后，head就成了本次处理k个的末尾节点，prev成了本次的头节点，而new_head为head的下一个节点也即下一个递归的头节点 12345678910111213141516171819202122class Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: if not head: return head p, count = head, k while p and count: p = p.next count -= 1 if count &gt; 0: return head prev, new_head = self.reverse(head, k) head.next = self.reverseKGroup(new_head, k) return prev def reverse(self, node, count): if not node: return node prev, curr = None, node while curr and count: curr.next, prev, curr = prev, curr, curr.next count -= 1 return (prev, curr) 2. 两数相加 Add Two NumbersLeetCodeCN 第2题链接 解法很容易想到，但是代码实现不容易，需要小心处理进位 12345678910111213141516171819class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: dummy = ListNode(0) node = dummy carry = 0 while l1 or l2: x = l1.val if l1 else 0 y = l2.val if l2 else 0 s = carry + x + y carry = s//10 node.next = ListNode(s%10) node = node.next if l1: l1 = l1.next if l2: l2 = l2.next if carry: node.next = ListNode(1) return dummy.next 21. 合并两个有序链表 Merge Two Sorted ListsLeetCodeCN 第21题 第一种方法：迭代，执行逻辑比较直观，由于每个节点仅访问一次，时间复杂度为O(n+m)，n、m分别为两个链表的长度，然后因为仅用到几个辅助变量，空间复杂度为O(1) 123456789101112131415class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if not l1 and not l2: return None p = dummy = ListNode(None) while l1 and l2: if l1.val &lt; l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next p.next = l1 if l1 else l2 return dummy.next 第二种方法：递归，需要递归n+m次，递归调用栈占用空间，空间复杂度为O(n+m)，因为每个节点也只访问一次，时间复杂度O(n+m) 123456789101112class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if not l1: return l2 elif not l2: return l1 if l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 else: l2.next = self.mergeTwoLists(l1, l2.next) return l2 23. 合并K个排序链表 Merge k Sorted ListsLeetCodeCN 第23题链接 第一种方法：分而治之，利用第21题合并两个有序链表的算法，逐个合并k个链表 1234567891011121314151617181920212223242526272829class Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: if not lists: return None self.lists = lists return self.divide(0, len(lists)-1) def divide(self, l, r): if l == r: return self.lists[l] mid = r + (l - r) // 2 l1 = self.divide(l, mid) l2 = self.divide(mid+1, r) return self.mergeTwoLists(l1, l2) def mergeTwoLists(self, l1, l2): if not l1 and not l2: return None p = dummy = ListNode(None) while l1 and l2: if l1.val &lt; l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next p.next = l1 if l1 else l2 return dummy.next 第二种方法：优先级队列（小顶堆），Python3中heapq存储对象二元组会导致不可比较的错误，所以用存储三元组，中间用一个数值隔开 123456789101112131415161718import heapqclass Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: if not lists: return None heap = [] p = dummy = ListNode(None) for i in range(len(lists)): if lists[i]: heapq.heappush(heap, (lists[i].val, i, lists[i])) while heap: node = heapq.heappop(heap) i = node[1] p.next = node[2] p = p.next if p.next: heapq.heappush(heap, (p.next.val, i, p.next)) return dummy.next","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"}]},{"title":"关于 NSUserDefaults setBool 的值取出后if判断不了的问题","slug":"nsuserdefaults-setbool-forkey","date":"2019-04-23T03:30:27.000Z","updated":"2021-11-07T12:02:15.278Z","comments":true,"path":"2019-04-23-nsuserdefaults-setbool-forkey/","link":"","permalink":"https://paaatrick.com/2019-04-23-nsuserdefaults-setbool-forkey/","excerpt":"使用 [[NSUserDefaults standardUserDefaults] setBool:(BOOL)value forKey:(NSString *)defaultName] 设置的值，如果用普通的objectForKey:取出的值是__NSCFBoolean类型，if语句无法判断，即使后加== YES也没用，还会出问题。","text":"使用 [[NSUserDefaults standardUserDefaults] setBool:(BOOL)value forKey:(NSString *)defaultName] 设置的值，如果用普通的objectForKey:取出的值是__NSCFBoolean类型，if语句无法判断，即使后加== YES也没用，还会出问题。 要用 [[NSUserDefaults standardUserDefaults] boolForKey:(NSString *)defaultName] 来取值， 同理： 12345- (void)setInteger:(NSInteger)value forKey:(NSString *)defaultName;- (void)setFloat:(float)value forKey:(NSString *)defaultName;- (void)setDouble:(double)value forKey:(NSString *)defaultName;- (void)setBool:(BOOL)value forKey:(NSString *)defaultName;- (void)setURL:(nullable NSURL *)url forKey:(NSString *)defaultName; 如上所示等入值方法，都用对应配套的取值方法 12345- (NSInteger)integerForKey:(NSString *)defaultName;- (float)floatForKey:(NSString *)defaultName;- (double)doubleForKey:(NSString *)defaultName;- (BOOL)boolForKey:(NSString *)defaultName;- (nullable NSURL *)URLForKey:(NSString *)defaultName;","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"如何面试一个 iOS 工程师","slug":"how-to-interview-an-ios-developer","date":"2019-04-09T10:35:08.000Z","updated":"2021-11-07T12:02:15.278Z","comments":true,"path":"2019-04-09-how-to-interview-an-ios-developer/","link":"","permalink":"https://paaatrick.com/2019-04-09-how-to-interview-an-ios-developer/","excerpt":"推荐序私下和很多朋友交流过这个话题，大部分求职者认为，我能做基本的 iOS 开发工作，就达到公司的要求了，殊不知公司招聘员工，更希望的是这个人能够在关键时候能够发挥一般人做不到的能力。 这篇文章是来自微信读书的 bang ，我完全同意他的观点。除了他的这些面试方法外，我还认为做比说更重要，所以我更喜欢在面试的时候，拿出一张白纸，让求职者写一段富有逻辑性的代码，看看他的思维是否严谨，对于一些常见的数据结构和算法基础有了解。 作者介绍：bang，iOS 开发者，推特中文圈 / JSPatch作者，博客 http://cnbang.net ， 目前就职于广州腾讯。","text":"推荐序私下和很多朋友交流过这个话题，大部分求职者认为，我能做基本的 iOS 开发工作，就达到公司的要求了，殊不知公司招聘员工，更希望的是这个人能够在关键时候能够发挥一般人做不到的能力。 这篇文章是来自微信读书的 bang ，我完全同意他的观点。除了他的这些面试方法外，我还认为做比说更重要，所以我更喜欢在面试的时候，拿出一张白纸，让求职者写一段富有逻辑性的代码，看看他的思维是否严谨，对于一些常见的数据结构和算法基础有了解。 作者介绍：bang，iOS 开发者，推特中文圈 / JSPatch作者，博客 http://cnbang.net ， 目前就职于广州腾讯。 本文转载自唐巧的公众号 正文参加了内部面委会的一个分享，结合我自己的方式，说说怎样面试一个普通的 iOS 工程师。 一般我倾向的考察分两个主要的部分，第一是在简历里提到的项目经历中找挖掘点，第二是基础知识考察。另外也会看情况做一些软实力的考察和性格特征的判断。 项目经历如果顺利的话这第一步占的比例会很大，因为每个程序员都不会方方面面知识都熟悉，但至少他写在简历上的做过的项目是熟悉的，讲自己熟悉的东西容易让他进入状态，展示好的一面。这里主要考察两方面，一是有没有在某些点上有过深入研究。二是对项目整体了解如何。 深入研究在中大型的公司里比较注重工程师有深入研究的能力，如果能把一个功能讲得很清晰是比较好的加分项，这里会问实现的思路，通过追问去了解候选人在这块深入的程度，从思路到方法，从上层 API 调用到框架流程再到底层实现。如果候选人在讲述时有一条逻辑主线，例如讲述业界普遍是怎么做的，自己在业界方案基础上做了什么改进，怎样做到更好，进一步改进的思路是怎样，这是最好的。如果还能把解决问题的方法归纳起来运用在其他地方，能举一反三，包装成通用解决方案，或者做开源贡献，就更好了。 一般会问候选人哪一个项目技术点最能体现自己的技术，然后不停追问技术细节，例如做了一个相册项目，觉得列表优化是最能体现技术点的，会问这里优化的思路是什么，怎样评估，遇到过什么困难，怎么解决的，如果用到图片缓存开源项目，说说它具体做了什么事，缓存策略是什么，从下载到显示的整个流程是怎样的，还有没有更好的方案，追问到一定程度后也会发散去问跟这个话题相关联的问题，例如如果有部分用户反馈图片显示不了，你会怎样排查问题，排查修复后怎样监控，就会过度到一些网络和运营监控方面的内容，也会顺便问到一些基础知识。 整体了解问完自己职责范围内的功能技术点后，还会看看对项目里其他的实现有没有了解，特别是项目的大致架构和核心功能，最好能画出项目大致结构，看情况问问网络层和数据层是怎样实现的，为什么这样实现，项目最核心功能是怎样实现的，例如做读书的至少要知道项目里的排版引擎的大致实现方式，做 QQ 的要知道消息收发的机制，如果不知道，也可以说说如果自己实现会怎么做。这里主要看看有没有技术好奇心，会不会积极主动了解项目里已有的非职责范围内的技术点，主动和好学这两点是很重要的。 基础知识如果项目经历里能问出大部分东西，这部分比例就会比较少了，这是比较好的情况，否则就按套路去多考察一些基础知识，包括 iOS 开发的基础和计算机基础，像内存 / 网络 / 存储 / 线程等，例如 ARC 是怎样做到自动管理内存的，跟 java/js 的垃圾回收的区别，网络 http 协议是怎样的，用过什么数据库框架，db 索引是什么，多线程开发要注意什么，跟 runloop 的关系是什么等等，这类问题在网上都有很多，就不多说了。数据结构和算法在笔试时会涉及，面试会比较少，如果问算法的话只会问问思路，一般我觉得如果项目经历方面不太好，才会考虑考考算法作为辅助判断。 软实力一些通用能力像逻辑思维能力，沟通能力，自我驱动能力等都可以在上面那些问题的交流中表现出来，另外像团队协作能力、抗压能力和性格特征这些也会看情况考察一下，例如问问如果产品让你做个需求，你觉得不靠谱，会怎样做，设计让你做个很难实现的效果，你会怎样评估？或者问个低级问题，故意说个错误的答案，看看他的反应是怎样，是表现出嘲笑和攻击性，还是怀疑自己，还是细心求证。抗压能力的考察有些人比较喜欢，我是觉得面试还是轻松一点好。软实力方面的考察在一面会比较少，或者不会涉及，实际上这方面我也没太多经验，也在摸索中。 其他作为程序员，如果有 GitHub 开源项目是最好的，直接可以看到代码风格，代码质量，处理 issue 和 PR 的方式，如果有技术博客也是很好的，可以提前看到平时的一些技术积累，省了很多事。但如果 GitHub 内容是培训班的那种仿写 APP，博客内容是摘抄文章什么的就是负分了。 以上是正常套路，若候选人有特殊经历或技能，例如牛 X 大学毕业，ACM 冠军，通读 linux 源码，php 源码贡献者之类，会另当别论，针对性进行面试，这不是唯一的标准。另外针对不同的工作年限也有不同的问法和要求，工作年限越高要求越高。 最后其实面试就是想低成本找到合适在团队里一起工作的人，因为如果通过一起工作一段时间去判断是否合适成本太高。这种低成本的代价就是会误判，有些工程师是理论型，有些是实践型，面试的方式会对实践型的人不利，尽管他们如果招进来会是适合的人，而且人会在不同环境下会有不同的表现，只根据过去的经历去判断有时是不准确的。只能尽量采取一些措施去减少误判的概率，例如提高面试官的判断能力，或多几轮面试。一般如果不是急招，策略都会是宁杀错不放过，所以其实就算面试被否了，也不一定代表能力不行。 另外每个面试官可能都有自己摸索出来的一种判断方式，并随着面试经验的丰富不断改进，达到更准的判断概率，这只是我个人在目前有限的经验里的一点小总结，仅供参考。 本文转载自唐巧的公众号","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"}]},{"title":"iOS集成支付宝H5支付实现跳转与回调的解决方案","slug":"ios-alipay-h5-solution","date":"2019-03-22T12:28:36.000Z","updated":"2021-11-07T12:02:15.276Z","comments":true,"path":"2019-03-22-ios-alipay-h5-solution/","link":"","permalink":"https://paaatrick.com/2019-03-22-ios-alipay-h5-solution/","excerpt":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是支付宝H5支付如何从App跳转支付宝以及如何从支付宝跳转回App，微信支付的见这篇： iOS集成H5微信支付实现跳转与回调的解决方案 实现的效果是：App→支付宝→支付(成功失败或取消)→App","text":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是支付宝H5支付如何从App跳转支付宝以及如何从支付宝跳转回App，微信支付的见这篇： iOS集成H5微信支付实现跳转与回调的解决方案 实现的效果是：App→支付宝→支付(成功失败或取消)→App 前置准备本项目使用WKWebView，前置动作是后端小伙伴已经处理好支付宝H5支付下单链接，客户端接收到下单链接后的操作。 下单链接即为支付宝H5支付文档-参数说明-公共参数中构造的https://openapi.alipay.com/gateway.do开头的的链接，构造链接的操作交由后端处理。 操作步骤1. 添加 URL Scheme 并把支付宝加入白名单 添加 URL Scheme。在 xcodeproj 文件 Info 选项卡最下面的 URL Types内设置。 该 URL Scheme 不像微信支付因为要校验必须设置商户后台填的一级域名，支付宝的这个可以任意设置。 把支付宝的 URL Scheme alipay 和 alipays 填入项目的白名单。在 xcodeproj 文件 Info 选项卡内的 Custom iOS Target Properties 的 LSApplicationQueriesSchemes 里添加上述两个字符串，若没有 LSApplicationQueriesSchemes 就手动输入添加，类型为数组 Array。 2. WKWebView加载链接添加协议 WKNavigationDelegate和WKUIDelegate。 创建一个WKWebView，并加载统一下单链接。 123456789- (void)buildWKWebView &#123; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)]; [self.view addSubview:webView]; webView.navigationDelegate = self; webView.UIDelegate = self; NSURL *payURL = [NSURL URLWithString:self.payString]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:payURL]; [webView loadRequest:request];&#125; 此处self.payString就是后台传来的支付宝5支付统一下单链接，格式为： https://openapi.alipay.com/gateway.do?app_id=2015081808011180&amp;biz_content={&quot;body&quot;%3A&quot;支付宝充值&quot;%2C&quot;subject&quot;%3A&quot;10000宝石&quot;%2C&quot;out_trade_no&quot;%3A&quot;30677&quot;%2C&quot;total_amount&quot;%3A&quot;1.00&quot;%2C&quot;seller_id&quot;%3A&quot;2088721584425035&quot;%2C&quot;product_code&quot;%3A&quot;QUICK_WAP_PAY&quot;%2C&quot;goods_type&quot;%3A&quot;1&quot;%2C&quot;passback_params&quot;%3A&quot;20190322083556lkkzmwT2wi0bAaFL1W&quot;%2C&quot;store_id&quot;%3A&quot;company&quot;%2C&quot;timeout_express&quot;%3A&quot;3m&quot;}&amp;charset=UTF-8&amp;format=JSON&amp;method=alipay.trade.wap.pay&amp;notify_url=https%3A%2F%2Fsttv3-api.company.com%2FaliNotify&amp;return_url=https%3A%2F%2Fwww.company.com&amp;sign_type=RSA2&amp;timestamp=2019-03-22+20%3A35%3A56&amp;version=1.0&amp;sign=rmnKUOsZBYi%2BWzDELY%2B5ixnSFn0b0S38K0NR45SRZBAvmzr0qaXm7mnKaXm7OrvmnKUOsZRYiaJ2LNAaFL1K0hvJ3L3hZqH5HifNCIJ0hfTr1OkA5Lgyn1SCx74SrSWVfXdMXqiLurpN0Mj%2B2zs7vDee%2B8vxwzhRG3a5EaZbOHDQFN1%2OrvvVcdv%2F%2FBJCwISBhoXhBelvfZRYiaJ2LNAaFL1KdrJvjlo2lR%2BEzvda0ppMKFzjMLxRZBAvmzr0qNwxyTMfAuxjAT2%2BXAaF3hZqH5Hlo2lRiaJ2LNE 不像微信支付还要加个请求头，支付宝的简单的多，直接访问即可。 3. 实现代理方法拦截链接并跳转支付宝12345678910111213141516171819202122232425262728- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; if ([navigationAction.request.URL.scheme isEqualToString:@\"alipay\"]) &#123; // 1.以？号来切割字符串 NSArray *urlBaseArr = [navigationAction.request.URL.absoluteString componentsSeparatedByString:@\"?\"]; NSString *urlBaseStr = urlBaseArr.firstObject; NSString *urlNeedDecode = urlBaseArr.lastObject; // 2.将截取以后的Str，做一下URLDecode，方便我们处理数据 NSMutableString *afterDecodeStr = [NSMutableString stringWithString:[SmallTools decoderUrlEncodeStr:urlNeedDecode]]; // 3.替换里面的默认Scheme为自己的Scheme NSString *afterHandleStr = [afterDecodeStr stringByReplacingOccurrencesOfString:@\"alipays\" withString:@\"alipayreturn.company.com\"]; // 4.然后把处理后的，和最开始切割的做下拼接，就得到了最终的字符串 NSString *finalStr = [NSString stringWithFormat:@\"%@?%@\",urlBaseStr, [SmallTools urlEncodeStr:afterHandleStr]]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 判断一下，是否安装了支付宝APP（也就是看看能不能打开这个URL） if ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:finalStr]]) &#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:finalStr]]; &#125; else &#123; //未安装支付宝, 自行处理 &#125; &#125;); decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; 顺便附带一下 URL 的 Encode 和 Decode 方法。 12345678910111213//urlEncode编码+ (NSString *)urlEncodeStr:(NSString *)input &#123; NSString *charactersToEscape = @\"?!@#$^&amp;%*+,:;='\\\"`&lt;&gt;()[]&#123;&#125;/\\\\| \"; NSCharacterSet *allowedCharacters = [[NSCharacterSet characterSetWithCharactersInString:charactersToEscape] invertedSet]; NSString *upSign = [input stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters]; return upSign;&#125;//urlEncode解码+ (NSString *)decoderUrlEncodeStr: (NSString *) input &#123; NSMutableString *outputStr = [NSMutableString stringWithString:input]; [outputStr replaceOccurrencesOfString:@\"+\" withString:@\"\" options:NSLiteralSearch range:NSMakeRange(0,[outputStr length])]; return [outputStr stringByRemovingPercentEncoding];&#125; 4. AppDelegate 中接收跳转动作当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。 以下是AppDelegate接收返回动作的示例。 其中支付宝回调的 host 是固定的 safepay，而微信支付的 host 随意定义。 123456789101112131415- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123; //safepay是支付宝H5支付的回调host, if ([url.host isEqualToString:@\"wxpaycallback\"] || [url.host isEqualToString:@\"safepay\"]) &#123; // 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等 UITabBarController *tabBarVC = (UITabBarController *)topRootViewController; UINavigationController *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex]; [navVC popViewControllerAnimated:YES]; NSString *orderId = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayOrderId\"]; NSString *payFee = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayFee\"]; //以及更多参数 NSDictionary *resultDict = @&#123;@\"order_id\":orderId, @\"payFee\":payFee&#125;; [[NSNotificationCenter defaultCenter] postNotificationName:@\"htmlPaymentNotification\" object:self userInfo:resultDict]; &#125;&#125;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS集成H5微信支付实现跳转与回调的解决方案","slug":"ios-wxpay-h5-solution","date":"2019-03-22T10:12:20.000Z","updated":"2021-11-07T12:02:15.278Z","comments":true,"path":"2019-03-22-ios-wxpay-h5-solution/","link":"","permalink":"https://paaatrick.com/2019-03-22-ios-wxpay-h5-solution/","excerpt":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是H5微信支付如何从App跳转微信以及如何从微信跳转回App，支付宝的见这篇： iOS集成支付宝H5支付实现跳转与回调的解决方案 实现的效果是：App→微信→支付(成功失败或取消)→App","text":"前言最近有个需求，不能在iOS客户端内集成支付宝和微信的App支付SDK（为了防苹果审核检测SDK），因此使用H5支付，虽然微信和支付宝的H5支付文档都说不要在App内使用H5支付而是使用App支付，但办法总是有的。 这篇讲的是H5微信支付如何从App跳转微信以及如何从微信跳转回App，支付宝的见这篇： iOS集成支付宝H5支付实现跳转与回调的解决方案 实现的效果是：App→微信→支付(成功失败或取消)→App 前置准备本项目使用WKWebView，前置动作是后端小伙伴已经处理好微信H5支付下单链接，客户端接收到下单链接后的操作。 下单链接即为微信支付文档-统一下单API中返回的 mweb_url，格式为 https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458241。 操作步骤1. 添加 URL Scheme 并把微信加入白名单 添加 URL Scheme。在 xcodeproj 文件 Info 选项卡最下面的 URL Types内设置。 注意此URL的一级域名需要与微信商户后台(微信商户平台-产品中心-开发配置-H5支付)设置的的一级域名一致，比如微信商户里设置的是company.com，那 URL Schemes 可以设为 a1.company.com，此特性使得一套H5支付可以方便得集成到多个App。只有一个App需要H5支付的话也可以直接填与微信后台的一致的 company.com 。 2019年4月10日更新如果像上图那样填的是 www.company.com，那 URL Scheme 只能设为其三级域名如 a2.www.company.com 或同样的 www.company.com 把微信的 URL Scheme weixin 和 wechat 填入项目的白名单。在 xcodeproj 文件 Info 选项卡内的 Custom iOS Target Properties 的 LSApplicationQueriesSchemes 里添加上述两个字符串，若没有 LSApplicationQueriesSchemes 就手动输入添加，类型为数组 Array。 2. WKWebView加载链接添加协议 WKNavigationDelegate和WKUIDelegate。 创建一个WKWebView，并加载统一下单链接。 12345678910- (void)buildWKWebView &#123; WKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, NAV_HEIGHT, SCREEN_WIDTH, SCREEN_HEIGHT - NAV_HEIGHT)]; [self.view addSubview:webView]; webView.navigationDelegate = self; webView.UIDelegate = self; NSURL *payURL = [NSURL URLWithString:self.payString]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:payURL]; [request setValue:@\"a1.company.com://wxpaycallback/\" forHTTPHeaderField:@\"Referer\"]; [webView loadRequest:request];&#125; 此处self.payString就是后台传来的微信H5支付统一下单链接，格式为 https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb?prepay_id=wx2016121516420242444321ca0631331346&amp;package=1405458041。 我们需要做的处理是根据文档给这个请求添加请求头 Referer，关键在于这个 a1.company.com://wxpaycallback/ 既满足了微信检测到有商户后台设置好的一级域名，同时把这个链接做成了 URL Scheme 使得可以在跳转微信客户端后（不管支付成功还是失败）能顺利跳转回自己的App。其中的 host wxpaycallback/ 可以任意设置，方便在 AppDelegate 里处理跳转回来后部署业务逻辑。当然如果你不需要在 AppDelegate 里接收动作而是直接跳回支付界面自行后续处理的话就只用设为前一步在 URL Scheme a1.company.com:// 即可。 2019.4.10 更新 经过测试，对于App内的H5支付而言，实际上是下面步骤里@&quot;https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb&quot;后接的参数 redirect_url 对支付后跳回App起作用，Referer只起到给微信校验的作用。 所以 Referer 只需要设置成微信H5支付登记的域名的子域名即可，如[request setValue:@&quot;a1.company.com&quot; forHTTPHeaderField:@&quot;Referer&quot;]; 3. 实现代理方法拦截链接并跳转微信1234567891011121314151617181920212223242526272829303132333435363738- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; NSURLRequest *request = navigationAction.request; NSString *absoluteString = [navigationAction.request.URL.absoluteString stringByRemovingPercentEncoding]; // 拦截WKWebView加载的微信支付统一下单链接, 将redirect_url参数修改为唤起自己App的URLScheme if ([absoluteString hasPrefix:@\"https://wx.tenpay.com/cgi-bin/mmpayweb-bin/checkmweb\"] &amp;&amp; ![absoluteString hasSuffix:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]) &#123; decisionHandler(WKNavigationActionPolicyCancel); NSString *redirectUrl = nil; if ([absoluteString containsString:@\"redirect_url=\"]) &#123; NSRange redirectRange = [absoluteString rangeOfString:@\"redirect_url\"]; redirectUrl = [[absoluteString substringToIndex:redirectRange.location] stringByAppendingString:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]; &#125; else &#123; redirectUrl = [absoluteString stringByAppendingString:[NSString stringWithFormat:@\"redirect_url=a1.company.com://wxpaycallback/\"]]; &#125; NSMutableURLRequest *newRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:redirectUrl] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30]; newRequest.allHTTPHeaderFields = request.allHTTPHeaderFields; newRequest.URL = [NSURL URLWithString:redirectUrl]; [webView loadRequest:newRequest]; return; &#125; //拦截重定向的跳转微信的 URL Scheme, 打开微信 if ([absoluteString hasPrefix:@\"weixin://\"]) &#123; decisionHandler(WKNavigationActionPolicyAllow); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; if ([[UIApplication sharedApplication] canOpenURL:navigationAction.request.URL]) &#123; [[UIApplication sharedApplication] openURL:navigationAction.request.URL]; &#125; else &#123; //未安装微信, 自行处理 &#125; &#125;); return; &#125; decisionHandler(WKNavigationActionPolicyAllow); return;&#125; 4. AppDelegate 中接收跳转动作当然你也不一定需要在AppDelegate里接收返回动作，也可以直接返回支付界面，自行操作后续逻辑。 以下是AppDelegate接收返回动作的示例。 123456789101112131415- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options&#123; //safepay是支付宝H5支付的回调host if ([url.host isEqualToString:@\"wxpaycallback\"] || [url.host isEqualToString:@\"safepay\"]) &#123; // 自行操作业务逻辑，比如使用通知请求查询订单状态，popView回上级页面等 UITabBarController *tabBarVC = (UITabBarController *)topRootViewController; UINavigationController *navVC = tabBarVC.viewControllers[tabBarVC.selectedIndex]; [navVC popViewControllerAnimated:YES]; NSString *orderId = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayOrderId\"]; NSString *payFee = [[NSUserDefaults standardUserDefaults] objectForKey:@\"PayFee\"]; //以及更多参数 NSDictionary *resultDict = @&#123;@\"order_id\":orderId, @\"payFee\":payFee&#125;; [[NSNotificationCenter defaultCenter] postNotificationName:@\"htmlPaymentNotification\" object:self userInfo:resultDict]; &#125;&#125; 5. 关于微信H5支付域名设置 2019年4月10日更新 这里额外提一下，截止到2019年4月，微信支付设置页面明确说了 添加域名后，其所属的子域名将都有权限 也就是说只需要填一个一级域名比如 company.com ，就可以有无限多个二级域名可供不同App使用，绕过微信H5支付只能添加5个域名的限制。如果填的是二级域名比如 www.company.com，那么只能往下使用三级域名比如 a1.www.company.com 以微信H5支付域名填了 company.com 为例，那可以这样操作 App Alpha Beta-A1 Beta-A2 Gamma 添加的Referer alpha.company.com a1.beta.company.com a2.beta.company.com gamma.company.com 要替换的redirect_url alpha.company.com://optional a1.beta.company.com:// a2.beta.company.com://optional gamma.company.com:// URL Scheme alpha.company.com a1.beta.company.com a2.beta.company.com gamma.company.com 参考博客链接","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"判断一个 NSArray 是否为空","slug":"if-nsarray-null","date":"2019-03-12T07:34:27.000Z","updated":"2021-11-07T12:02:15.276Z","comments":true,"path":"2019-03-12-if-nsarray-null/","link":"","permalink":"https://paaatrick.com/2019-03-12-if-nsarray-null/","excerpt":"","text":"1234if ([array isKindOfClass:[NSArray class]] &amp;&amp; array.count &gt; 0)&#123; NSLog(@\"这是一个非空数组\");&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iPhone屏幕各种尺寸分辨率（更新至XS）","slug":"iphone-pixel-point-size-scale","date":"2019-03-05T07:57:28.000Z","updated":"2021-11-07T12:02:15.276Z","comments":true,"path":"2019-03-05-iphone-pixel-point-size-scale/","link":"","permalink":"https://paaatrick.com/2019-03-05-iphone-pixel-point-size-scale/","excerpt":"","text":"Device Logic Point Logic Pixel Size Scale iPhone 2G 480 × 320 480 × 320 3.5 1x iPhone 3 480 × 320 480 × 320 3.5 1x iPhone 3GS 480 × 320 480 × 320 3.5 1x iPhone 4 480 × 320 960 × 640 3.5 2x iPhone 4S 480 × 320 960 × 640 3.5 2x iPhone 5 568 × 320 1136 × 640 4.0 2x iPhone 5S 568 × 320 1136 × 640 4.0 2x iPhone 5C 568 × 320 1136 × 640 4.0 2x iPhone 6 667 × 375 1334 × 750 4.7 2x iPhone 6 Plus 736 × 414 2208 × 1242 5.5 3x iPhone 6S 667 × 375 1334 × 750 4.7 2x iPhone 6S Plus 736 × 414 2208 × 1242 5.5 3x iPhone SE 568 × 320 1136 × 640 4.0 2x iPhone 7 667 × 375 1334 × 750 4.7 2x iPhone 7 Plus 736 × 414 2208 × 1242 5.5 3x iPhone 8 667 × 375 1334 × 750 4.7 2x iPhone 8 Plus 736 × 414 2208 × 1242 5.5 3x iPhone X 812 × 375 2436 × 1125 5.8 3x iPhone XS 812 × 375 2436 × 1125 5.8 3x iPhone XR 896 × 414 1792 × 828 6.1 2x iPhone XS Max 896 × 414 2688 × 1242 6.5 3x","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"一些iOS面试基础题总结","slug":"ios-interview-thing","date":"2019-03-01T02:06:07.000Z","updated":"2021-11-07T12:02:15.276Z","comments":true,"path":"2019-03-01-ios-interview-thing/","link":"","permalink":"https://paaatrick.com/2019-03-01-ios-interview-thing/","excerpt":"一些iOS面试基础题总结","text":"一些iOS面试基础题总结 目录 多线程 AutoLayout objc_msgSend Runtime 消息转发 Category NSObject 与 objc_class Runloop AutoreleasePool iOS系统架构 App启动过程和优化 UIScrollView 的代理方法 响应链和事件传递 UIView 和 CALayer 的区别和联系 轮播图朴素实现的几种方法 TableView 和 CollectionView 必选的代理方法 UITableView 的优化思路 多线程线程之间同步 原子操作 Atomic 加锁（互斥锁、递归锁、读写锁）NSLock，OSSpinLock 多线程之间通信 performSelectorOnMainThread:withObject:waitUntilDone: 如何保证线程安全 OSSpinLock 自旋锁 dispatch_semaphore NSLock 等各种锁 @synchronized 多线程的坑 常驻线程 常驻线程多了影响CPU效率 AFNetworking2.0因为用的NSURLConnection有缺陷，需要所在线程一直存活，所以保持了个常驻线程，3.0用了NSURLSession，可以指定回调的delegateQueue于是弃用常驻线程。 [runloop run]是常驻线程，[runloop runUntilDate]指定保活时长 并发 GCD本着最大化CPU效率的原则会多创建线程，但如果是IO类操作，需要等待数据的空档会继续创建新线程导致内存失控。类似数据库操作尽量用串行队列避免多线程并发导致问题。因为创建线程需要堆栈内存，切换线程也消耗CPU。 死锁 串行队列（如主队列）同步操作 AutoLayout更新屏幕时，Layout Engine从上到下调用layoutSubviews()通过 Cassowary 算法计算各个子视图的位置，算出来后将子视图的 frame 从 Layout Engine 里拷贝出来，接下来的过程就跟手写frame是一样的了。iOS12优化了性能，以前元素多了会导致性能下降，现正不会了 objc_msgSend 检查这个selector是不是要忽略的 检查target是不是nil 如果有相应处理nil的函数就跳转到该函数 如果没有就自动清理现场并返回，这就是OC中给nil发消息不会崩溃的原因 确定不是给nil发消息后，在该class的缓存中查找方法对应的IMP实现 如果找到就跳转进去 如果没找到就在方法分发表里继续查找，直到找到NSObject为止 如果还没找到就开始消息转发，上述过程就是通过SEL快速查找IMP的过程 RuntimeC语言中，编译期函数的调用就决定调用哪个函数，而OC只有在真正运行时才根据函数名称找到对应函数来调用。需要一个运行时系统来动态地创建类和对象、消息传递和转发 讲一下 OC 的消息机制 OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名） objc_msgSend底层有3大阶段:消息发送（当前类、父类中查找）、动态方法解析、消息转发 当递归地找不到selector时，启动消息转发：resolveInstanceMethod、resolveClassMethod、forwardingTargetForSelector 什么是Runtime？平时项目中有用过么？ OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行 OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动态性相关的函数 平时编写的OC代码，底层都是转换成了Runtime API进行调用 Runtime 的应用（优点）： 实现多继承 Multiple Inheritance Method Swizzling -&gt; 无侵入埋点 -&gt; 使用Category进行 Aspect Oriented Prigramming 面向切面编程AOP -&gt; 如日志、身份验证、缓存等模块 isa Swizzling -&gt; KVO的实现 Associated Object关联对象(给Category添加属性) objc_set(get)AssociatedObject 动态地增加方法 NSCoding 的自动归档和自动解档 字典和模型相互转换！ 异常保护（保护数组越界问题） Runtime 的缺点 Method Swizzling 不是原子操作，放在+load里没问题，放在+initialize里就有问题了 重写方法而不调用super方法可能有问题 Runtime 注意事项 Swizzling应该总在+load中执行 Swizzling应该总在dispatch_once中执行 -&gt; 因为会改变全局状态所以应该只执行一次 +load中执行Swizzling时，不要调用[super load] -&gt; 避免偶数次执行Swizzling SEL其本身是一个Int类型的地址，地址中存放着方法的名字。 Method Swizzling几个常见方法 method_setImplementation 为一个方法名设置IMP(实现) method_exchangeImplementations 交换两个方法名的实现，即执行两次 method_setImplementation class_addMethod 根据官方注释解释，这个方法用于给指定的类增加方法名和IMP(实现)，如果该已经存在这个方法名，不做事，返回NO，如果该类不存在这个方法名（即使父类存在），添加这个方法，返回YES class_replaceMethod 根据官方注释解释，它有两种不同的行为。当类中没有想替换的原方法时，该方法会调用 class_addMethod 来为该类增加一个新方法。若已存在，则等同于 method_setImplementation 为该方法名替换IMP(实现) Swizzling 模板12345678910+ (void)hookClass:(Class)classObject fromSelector:(SEL)fromSelector toSelector:(SEL)toSelector &#123; Class class = classObject; Method fromMethod = class_getInstanceMethod(class, fromSelector); // 得到被交换类的实例方法 Method toMethod = class_getInstanceMethod(class, toSelector); // 得到交换类的实例方法 if(class_addMethod(class, fromSelector, method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) &#123; class_replaceMethod(class, toSelector, method_getImplementation(fromMethod), method_getTypeEncoding(fromMethod)); // 进行方法的交换 &#125; else &#123; method_exchangeImplementations(fromMethod, toMethod); // 交换 IMP 指针 &#125;&#125; 123456789101112131415161718192021222324252627+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class aClass = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(aClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); BOOL didAddMethod = class_addMethod(aClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(aClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125; 消息转发什么时候会报unrecognized selector的异常？ 当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 可以通过“消息转发”进行解决。 objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会： Method resolution objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。 Fast forwarding 如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。 Normal forwarding 这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。 Category通过Runtime给类添加方法，可以把类的实现分开在几个不同的文件，减少单个文件体积、不同功能组织到不同的Category里、可以由多人开发一个类、可以按需加载想要的category、可以把framework的私有方法公开 与extension不同的是，extension需要有类的源码才能添加，所以无法为系统类添加extension。 而category是运行时添加的。所以，extension可以添加实例变量，而category只能添加实例方法、类方法、协议、属性，但是不能添加实例变量。 category并不是完全替换掉原来类的方法，而是附加到方法列表的前面，而runtime寻找方法是顺着找的，找到category覆盖的方法后就执行了 NSObject 与 objc_classNSObject 继承自 objc_classobjc_class 继承自 objc_object objc_object -&gt; objc_class -&gt; NSObject 所以OC中，类也是一个对象。 objc_class中，除了isa，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法链表。 每个类都有单独的元类，所以类的superclass指针递归最后指向NSObject，NSObject没有超类所以指向nil。类的isa指向对应唯一的元类，每个元类的isa都指向rootMetaClass，rootMetaClass的superClass指向NSObject，isa指向自己 元类中保存了创建类对象以及类方法所需的所有信息 Runloop可以先粗看这篇YYKit大神ibireme的文章，大概过一遍，不用纠结源码和看不懂的地方。然后看这个孙源的线下分享会视频，最后再细看一遍那篇文章 介绍运行循环，在程序运行过程中循环做一些事情，如果没有Runloop程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省CPU资源，提高程序性能。简单来说就是让软件一直活着。 结构 一个线程对应一个Runloop，主线程的Runloop默认开启，子线程如果不手动开启就没有。 每个Runloop内有多个Mode，但Runloop同一时间只能执行一个Mode，换Mode需要停下切换。 每个Mode内有任意多个Source、Timer、Observer Timer 即 CFRunloopTimer NSTimer、performSelector:afterDelay:、CADisplayLink都是对RunloopTimer的封装 Source 即 CFRunlopSource，是Runloop的数据源抽象类 Source分Source0和Source1 Source0处理App内部事件、App自己负责管理触发、如UIEvent、CFSocker Source1有Runloop和内核管理，Mach Port驱动，如CFMachPort、CFMessagePort Observer 向外部报告Runloop当前状态的更改 框架中很多机制都由RunLoopObserver触发，如CAAnimation 与 AutoreleasePool 的关系：UIKit通过Observer在RunLoop两个Sleep之间对AutoreleasePool进行Pop和Push，将这次Loop中产生的Autorelease对象释放 CFRunLoopMode 每个Runloop内有多个Mode，但Runloop同一时间只能执行一个Mode，换Mode需要停止当前Loop切换然后重启Loop。 默认Mode：NSDefaultRunLoopMode, 空闲状态、普通事件等 界面追踪Mode：UITrackingRunLoopMode, 滑动时（ScrollView） 私有Mode：UIInitializationRunLoopMode, App刚启动时, 不重要 NSRunLoopCommonModes是一个集合（打标签），默认包含上面的1和2两个Mode，可以自己添加Mode进去 开始滑动时，会从DefaultRunLoopMode切换成UITrackingRunLoopMode，停止滑动时会切换回来 想让NSTimer滑动时也跑，默认是加到DefaultMode的，需要手动加到CommonModes里，使其滑动时也执行，[(NSRunLoop) addTimer:forMode:] RunLoop 与 GCD 的关系 只在用到 main queue 时 GCD 中 dispatch 到 main queue 的 block 被分发到 main RunLoop 中执行 RunLoop 的挂起与唤醒 指定用于唤醒的 mach_port 端口 调用 mach_msg 监听唤醒端口，被唤醒前，系统内核将这个线程挂起，停留在 mach_msg_trap 状态 由另一个线程（或另一个进程中的某个线程）向内核发送该端口的msg后，trap状态被唤醒，RunLoop继续下一轮 作用 保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行，对于子线程可以使用run来常驻线程。 保证NSTimer正常运转 线上监测App卡顿情况 处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等） 节省CPU资源，提高程序性能，程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CUP，现在没有事情做，我要去休息，这时CUP就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情 过程 进入loop do while 保活线程：触发Timer回调、触发Source()回调、执行block 进入休眠 等待mach_port消息（如Timer时间到、Runloop超时、被调用者唤醒） 唤醒，处理消息 判断是否进入下一个loop AFNetworking的RunLoop用法123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@\"AFNetworking\"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125;+ (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; 在子线程开启RunLoop，添加一个不会用到的port作为Source防止RunLoop停止 [runloop run]使子线程常驻，从而接收NSURLConnection的回调 在AF的3.0版本里替换成NSURLSession就不需要常驻线程了 利用RunLoop延时加载图片 当scrollview滑动时加载图片可能导致卡顿 原本做法可以通过delegate处理是否加载 利用RunLoop：把图片加载的方法放在NSDefaultRunLoopMode里，这样当滑动时就切换出了这个Mode，暂停加载 Crash时重启RunLoop 接到 Crash 的 Signal 后手动重启 RunLoop 不适用于 BAD_ACCESS 监测卡顿的方法 创建观察者 把观察者添加到主线程的Runloop的common模式下观察，然后创建一个常驻子线程专门用来监控主线程的Runloop状态 一旦发现runloop进入睡眠前的状态或者唤醒后的状态在设置的时间阈值内没有变化，即可判定为卡顿，用第三方库PLCrashReporter来获取堆栈信息，上报服务器。后续分析。 AutoreleasePool配合runloop的，每次runloop开启时重建自动释放池，休息前释放掉池里的东西如TimerARC下自动创建的在子线程结束后释放，手动创建的在作用域大括号结束后释放底层实现 AutoReleasePoolPage 是一个双向链表，有push release pop操作 iOS系统架构四个层 第一层：用户体验层：SpringBoard 第二层：应用框架层：CocoaTouch 第三层：核心框架层：Metal、图形媒体核心框架 第四层：Darwin层：XNU、内核、驱动 iOS的可执行文件和动态库都是Mach-O格式，加载App实际就是加载Mach-O文件。 App启动过程与优化 main()执行前 加载可执行文件（App的.o文件的集合） 加载动态链接库，进行rebase指针调整和bind符号绑定 Objc Runtime 的初始处理，包括 Objc 相关类的注册、Category注册、selector 唯一性检查 +load()初始化 这个阶段的优化有 1. 减少动态库加载（合并动态库）2. 减少加载启动后不会去用的类和方法 3. 少用+load，或用 +initialize替换，因为runtime 的 Method Swizzling 操作每次4ms main()执行后 指 main() 执行开始到 didFinishLaunchingWithOptions 方法里首屏渲染相关方法完成 配置初始化文件的IO操作 首屏列表大数据的读取 首屏渲染的大量计算 优化方法有把各种与首屏渲染不相干的初始化挪走或子线程处理 首屏渲染完成后 指 didFinishLaunchingWithOptions 作用域内执行首屏渲染之后的所有方法执行完成 非首屏其他业务服务模块的初始化 监听的注册 配置文件的读写 把可能卡住主线程的方法挪走或子线程处理 UIScrollView 的代理方法 滚动完 scrollViewDidScroll 缩放完 scrollViewDidZoom 将要开始拖动 scrollViewWillBeginDragging 将要结束拖动 scrollViewWillEndDragging 滑动将要减速、 滑动减速完成 滚动动画完成 将要开始缩放、已经结束缩放 响应链和事件传递 hitTest方法检测看是否返回 继承UIResponder的类才能响应，如UIApplication、UIView、UIViewController。而CALayer是继承自NSObject的，不能响应 事件首先传递给UIApplication，然后向下分发给UIWindow，然后分发给最下层的UIView，逐步调用hitTest从屏内向外找，当某个UIView返回YES时就递归对其SubView执行hitTest，直到找到最后一个 某UIView不接受事件的情况： alpha &lt; 0.01 userInteractionEnabled = NO hidden = YES UIView 和 CALayer 的区别和联系 UIView能响应，CALayer不能 View的frame(和bounds)是简单返回layer的frame(bound), 而layer的frame由几个参数决定 UIView 是 CALayer 的代理 每个UIView内都有一个CALayer（即有个属性） 轮播图朴素实现的集中方法 UICollectionView, 简单粗暴放100个Cell UIScrollView 首尾各放一个展示 UIScrollView 三个ImageView实现 UIImageView 自己实现layer转场动画 TableView 和 CollectionView 必选的代理方法 delegate都是可选 datasource各有两个必选 table: cellForRowAtIndexPath、numberOfRowsInSection collection: cellForItemAtIndexPath、numberOfItemsInSection UITableView 的优化思路流程 获取数据； 把数据转化成model、存进数组； tableview调用reloadData刷新数据； 在代理方法cellForRowAtIndexPath里，创建自定义的cell，把model赋值给cell； cell在对应的model的set方法里，根据拿到的model，设置图片的image，设置label的text等(控件都以懒加载形式初始化)； 在代理方法heightForRowAtIndexPath里，根据model，算出当前行应该显示多少的高度； 在cell的layoutSubviews方法里，布局子控件。 优化思路 避免主线程阻塞 1/2步里的获取数据、数据处理等耗时操作，应该放入后台线程异步处理，处理好后再通知主线程刷新界面。 避免频繁的对象创建 对象的创建会发送内存分配、属性调整等。所以，首先，尽量用轻量的对象代替重量的对象。比如CALayer代替UIView。接着，多利用缓存思想，对象创建后缓存起来，需要的时候再拿出来用。合理利用内存开销，减少CPU开销。把 Cell setModel里的一些操作放在第二步数据转model里 减少对象的属性赋值操作 尤其是UIView的frame/bounds等属性的赋值操作，会产生比较大的CPU消耗。尽量少让Cell里空间动态变化，有规律的话筛分成多个固定cell 异步绘制 文本渲染、图像绘制都是比较消耗性能的操作，而UILabel等控件都是在主线程进行的文本绘制。这会对性能产生比较大的影响。UIKit和CoreAnimation相关操作必须在主线程中进行，其它的可以在后台线程异步执行 简化视图结构 GPU在绘制图像前，会把重叠的视图进行混合，视图结构越复杂，这个操作就越耗时，如果存在透明视图，混合过程会更加复杂。所以，我们可以： 尽量避免复杂的图层结构 少使用透明的视图 不透明的视图，设置opaque = YES 减少离屏渲染 老生常谈之圆角问题，圆角是开发中经常使用到的美化方式，但一般的设置cornerRadius时会配合masksToBounds属性，这就会造成离屏渲染。关于这种问题的处理，大致有两个思路： 异步绘制一张圆角的图片来显示； 用一个圆角而中空的图来盖住。 tableview需要刷新数据时，使用[tableview beginUpdates]、[tableview insertRowsAtIndexPaths:indexArray withRowAnimation:UITableViewRowAnimationNone]、[tableview endUpdates];而非[tableview reloadData]从而刷新更少的行减少CPU压力 对于固定行高，前一个设置属性比后一个实现代理方法效率高 123456cell.tableview.rowHeight = 50.0;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 50.0;&#125; NSDateFormatter这个对象的相关操作很费时，需要避免频繁的创建和计算 利用RunLoop延时加载图片 利用RunLoop：把图片加载的方法放在NSDefaultRunLoopMode里，这样当滑动时就切换出了这个Mode，暂停加载","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS处理多线程异步Block中的UI操作","slug":"ios-block-and-mainqueue","date":"2019-02-23T04:05:28.000Z","updated":"2021-11-07T12:02:15.276Z","comments":true,"path":"2019-02-23-ios-block-and-mainqueue/","link":"","permalink":"https://paaatrick.com/2019-02-23-ios-block-and-mainqueue/","excerpt":"多线程方法的completionHandlerblock可能运行在非主线程上。两种处理方法：","text":"多线程方法的completionHandlerblock可能运行在非主线程上。两种处理方法： 在block里手动加上dispatch_async(dispatch_get_main_queue(), ^{}); 123456789101112NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];//no delegateQueueNSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0];NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123;/* do UI things */&#125;); //or [self performSelectorOnMainThread:@selector(doUIthings) withObject:nil waitUntilDone:NO];&#125;];[task resume]; 带有delegateQueue等参数的方法，可传入主线程队列，然后blockcompletionHandler便运行在主线程了。 12345678910NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:[NSOperationQueue mainQueue]];//get the mainQueueNSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url] cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0];NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;/* do UI things */&#125;];[task resume];","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS 判断NSString值是否为空或null并转换为空字符串","slug":"transfer-null-to-nsstring","date":"2019-02-12T09:52:26.000Z","updated":"2021-11-07T12:02:15.276Z","comments":true,"path":"2019-02-12-transfer-null-to-nsstring/","link":"","permalink":"https://paaatrick.com/2019-02-12-transfer-null-to-nsstring/","excerpt":"","text":"遇到了一个后台json误将null作为字符串值导致iOS客户端崩溃闪退的问题，解决方法如下：套一层判断，如果是各种情况的null则转换为@””。 1234567+ (NSString *) nullToString:(id)string &#123; if ([string isEqual:@\"NULL\"] || [string isKindOfClass:[NSNull class]] || [string isEqual:[NSNull null]] || [string isEqual:NULL] || [[string class] isSubclassOfClass:[NSNull class]] || string == nil || string == NULL || [string isKindOfClass:[NSNull class]] || [[string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] length]==0 || [string isEqualToString:@\"&lt;null&gt;\"] || [string isEqualToString:@\"(null)\"]) &#123; return @\"\"; &#125; else &#123; return (NSString *)string; &#125;&#125;","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS MJExtension使用方法指南(Objective-C)","slug":"mj-extension-guide","date":"2019-02-03T07:29:04.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2019-02-03-mj-extension-guide/","link":"","permalink":"https://paaatrick.com/2019-02-03-mj-extension-guide/","excerpt":"","text":"MJExtension能做什么？1. MJExtension是一套字典和模型之间互相转换的超轻量级框架2. MJExtension能完成的功能1234字典（JSON） --&gt; 模型（Model）模型（Model） --&gt; 字典（JSON）字典数组（JSON Array） --&gt; 模型数组（Model Array）模型数组（Model Array） --&gt; 字典数组（JSON Array） 详尽用法主要参考 main.m中的各个函数 以及 NSObject+MJKeyValue.h MJExtension和JSONModel、Mantle等框架的区别1. 转换速率：最近一次测试表明：MJExtension &gt; JSONModel &gt; Mantle 各位开发者也可以自行测试 2. 具体用法：1234567891011JSONModel：要求所有模型类必须继承自JSONModel基类Mantle：要求所有模型类必须继承自MTModel基类MJExtension：不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性 如何安装MJExtension方法一：cocoapods导入： 1pod 'MJExtension' 方法二：手动导入： 1234567891011121314151617将MJExtensionExample/MJExtensionExample/MJExtension文件夹中的所有源代码拽入项目中导入主头文件：#import \"MJExtension.h\"MJExtension.hMJConst.hMJConst.mMJFoundation.hMJFoundation.mMJIvar.hMJIvar.mMJType.hMJType.mNSObject+MJCoding.hNSObject+MJCoding.mNSObject+MJIvar.hNSObject+MJIvar.mNSObject+MJKeyValue.hNSObject+MJKeyValue.m 如何使用MJExtension1. 最简单的字典转模型12345678910111213141516171819202122232425typedef enum &#123; SexMale, SexFemale&#125; Sex;@interface User : NSObject@property (copy, nonatomic) NSString *name;@property (copy, nonatomic) NSString *icon;@property (assign, nonatomic) int age;@property (assign, nonatomic) double height;@property (strong, nonatomic) NSNumber *money;@property (assign, nonatomic) Sex sex;@endNSDictionary *dict = @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\", @\"age\" : @20, @\"height\" : @\"1.55\", @\"money\" : @100.9, @\"sex\" : @(SexFemale) &#125;;// 将字典转为User模型User *user = [User objectWithKeyValues:dict];NSLog(@\"name=%@, icon=%@, age=%d, height=%@, money=%@, sex=%d\", user.name, user.icon, user.age, user.height, user.money, user.sex);// name=Jack, icon=lufy.png, age=20, height=1.550000, money=100.9, sex=1 核心代码1：1[User objectWithKeyValues:dict] 2. 模型中嵌套模型12345678910111213141516171819202122232425262728293031323334353637@interface Status : NSObject/** 微博文本内容 */@property (copy, nonatomic) NSString *text;/** 微博作者 */@property (strong, nonatomic) User *user;/** 转发的微博 */@property (strong, nonatomic) Status *retweetedStatus;@endNSDictionary *dict = @&#123; @\"text\" : @\"是啊，今天天气确实不错！\", @\"user\" : @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\" &#125;, @\"retweetedStatus\" : @&#123; @\"text\" : @\"今天天气真不错！\", @\"user\" : @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\" &#125; &#125; &#125;;// 将字典转为Status模型Status *status = [Status objectWithKeyValues:dict];NSString *text = status.text;NSString *name = status.user.name;NSString *icon = status.user.icon;NSLog(@\"text=%@, name=%@, icon=%@\", text, name, icon);// text=是啊，今天天气确实不错！, name=Jack, icon=lufy.pngNSString *text2 = status.retweetedStatus.text;NSString *name2 = status.retweetedStatus.user.name;NSString *icon2 = status.retweetedStatus.user.icon;NSLog(@\"text2=%@, name2=%@, icon2=%@\", text2, name2, icon2);// text2=今天天气真不错！, name2=Rose, icon2=nami.png 核心代码21[Status objectWithKeyValues:dict]` 3. 模型中有个数组属性，数组里面又要装着其它模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@interface Ad : NSObject@property (copy, nonatomic) NSString *image;@property (copy, nonatomic) NSString *url;@end@interface StatusResult : NSObject/** 存放着一堆的微博数据（里面都是Status模型） */@property (strong, nonatomic) NSMutableArray *statuses;/** 存放着一堆的广告数据（里面都是Ad模型） */@property (strong, nonatomic) NSArray *ads;@property (strong, nonatomic) NSNumber *totalNumber;@end@implementation StatusResult// 实现这个方法的目的：告诉MJExtension框架statuses和ads数组里面装的是什么模型/* + (NSDictionary *)objectClassInArray&#123; return @&#123; @\"statuses\" : [Status class], @\"ads\" : [Ad class] &#125;;&#125;+ (Class)objectClassInArray:(NSString *)propertyName&#123; if ([propertyName isEqualToString:@\"statuses\"]) &#123; return [Status class]; &#125; else if ([propertyName isEqualToString:@\"ads\"]) &#123; return [Ad class]; &#125; return nil;&#125;*/// 这个方法对比上面的2个方法更加没有侵入性和污染，因为不需要导入Status和Ad的头文件+ (NSDictionary *)objectClassInArray&#123; return @&#123; @\"statuses\" : @\"Status\", @\"ads\" : @\"Ad\" &#125;;&#125;@endNSDictionary *dict = @&#123; @\"statuses\" : @[ @&#123; @\"text\" : @\"今天天气真不错！\", @\"user\" : @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\" &#125; &#125;, @&#123; @\"text\" : @\"明天去旅游了\", @\"user\" : @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\" &#125; &#125; ], @\"ads\" :@[ @&#123; @\"image\" : @\"ad01.png\", @\"url\" : @\"http://www.ad01.com\" &#125;, @&#123; @\"image\" : @\"ad02.png\", @\"url\" : @\"http://www.ad02.com\" &#125; ], @\"totalNumber\" : @\"2014\" &#125;; // 将字典转为StatusResult模型 StatusResult *result = [StatusResult objectWithKeyValues:dict]; NSLog(@\"totalNumber=%@\", result.totalNumber); // totalNumber=2014 // 打印statuses数组中的模型属性 for (Status *status in result.statuses) &#123; NSString *text = status.text; NSString *name = status.user.name; NSString *icon = status.user.icon; NSLog(@\"text=%@, name=%@, icon=%@\", text, name, icon);&#125; // text=今天天气真不错！, name=Rose, icon=nami.png // text=明天去旅游了, name=Jack, icon=lufy.png // 打印ads数组中的模型属性 for (Ad *ad in result.ads) &#123; NSLog(@\"image=%@, url=%@\", ad.image, ad.url);&#125; // image=ad01.png, url=http://www.ad01.com // image=ad02.png, url=http://www.ad02.com 核心代码3：123在模型内部实现+ (NSDictionary *)objectClassInArray方法[StatusResult objectWithKeyValues:dict] 4. 模型中的属性名和字典中的key不相同(或者需要多级映射)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@interface Bag : NSObject@property (copy, nonatomic) NSString *name;@property (assign, nonatomic) double price;@end@interface Student : NSObject@property (copy, nonatomic) NSString *ID;@property (copy, nonatomic) NSString *desc;@property (copy, nonatomic) NSString *nowName;@property (copy, nonatomic) NSString *oldName;@property (copy, nonatomic) NSString *nameChangedTime;@property (strong, nonatomic) Bag *bag;@end@implementation Student// 实现这个方法的目的：告诉MJExtension框架模型中的属性名对应着字典的哪个key+ (NSDictionary *)replacedKeyFromPropertyName&#123; return @&#123; @\"ID\" : @\"id\", @\"desc\" : @\"desciption\", @\"oldName\" : @\"name.oldName\", @\"nowName\" : @\"name.newName\", @\"nameChangedTime\" : @\"name.info.nameChangedTime\", @\"bag\" : @\"other.bag\" &#125;;&#125;@endNSDictionary *dict = @&#123; @\"id\" : @\"20\", @\"desciption\" : @\"孩子\", @\"name\" : @&#123; @\"newName\" : @\"lufy\", @\"oldName\" : @\"kitty\", @\"info\" : @&#123; @\"nameChangedTime\" : @\"2013-08\" &#125; &#125;, @\"other\" : @&#123; @\"bag\" : @&#123; @\"name\" : @\"小书包\", @\"price\" : @100.7 &#125; &#125; &#125;;// 将字典转为Student模型Student *stu = [Student objectWithKeyValues:dict];// 打印Student模型的属性NSLog(@\"ID=%@, desc=%@, oldName=%@, nowName=%@, nameChangedTime=%@\", stu.ID, stu.desc, stu.oldName, stu.nowName, stu.nameChangedTime);// ID=20, desc=孩子, oldName=kitty, nowName=lufy, nameChangedTime=2013-08NSLog(@\"bagName=%@, bagPrice=%f\", stu.bag.name, stu.bag.price);// bagName=小书包, bagPrice=100.700000 核心代码4：123在模型内部实现+ (NSDictionary *)replacedKeyFromPropertyName方法[Student objectWithKeyValues:dict] 5. 将一个字典数组转成模型数组123456789101112131415161718NSArray *dictArray = @[ @&#123; @\"name\" : @\"Jack\", @\"icon\" : @\"lufy.png\", &#125;, @&#123; @\"name\" : @\"Rose\", @\"icon\" : @\"nami.png\", &#125; ];// 将字典数组转为User模型数组NSArray *userArray = [User objectArrayWithKeyValuesArray:dictArray];// 打印userArray数组中的User模型属性for (User *user in userArray) &#123; NSLog(@\"name=%@, icon=%@\", user.name, user.icon);&#125; // name=Jack, icon=lufy.png // name=Rose, icon=nami.png 核心代码5：1[User objectArrayWithKeyValuesArray:dictArray] 6. 将一个模型转成字典12345678// 新建模型 User *user = [[User alloc] init];user.name = @\"Jack\";user.icon = @\"lufy.png\";Status *status = [[Status alloc] init];status.user = user;status.text = @\"今天的心情不错！\"; ​ 1234567891011121314151617181920212223242526272829303132333435363738394041// 将模型转为字典NSDictionary *statusDict = status.keyValues;NSLog(@\"%@\", statusDict);/*&#123; text = \"今天的心情不错！\"; user = &#123; icon = \"lufy.png\"; name = Jack; &#125;; &#125;*/// 多级映射的模型Student *stu = [[Student alloc] init];stu.ID = @\"123\";stu.oldName = @\"rose\";stu.nowName = @\"jack\";stu.desc = @\"handsome\";stu.nameChangedTime = @\"2018-09-08\";Bag *bag = [[Bag alloc] init];bag.name = @\"小书包\";bag.price = 205;stu.bag = bag;NSDictionary *stuDict = stu.keyValues;NSLog(@\"%@\", stuDict);/*&#123; desciption = handsome; id = 123; name = &#123; info =&#123; nameChangedTime = \"2018-09-08\"; &#125;; newName = jack; oldName = rose; &#125;; other = &#123; bag =&#123; name = \"小书包\"; price = 205; &#125;; &#125;; &#125; */ 核心代码6：1status.keyValues、stu.keyValues 7. 将一个模型数组转成字典数组12345678910111213141516// 新建模型数组 User *user1 = [[User alloc] init];user1.name = @\"Jack\";user1.icon = @\"lufy.png\";User *user2 = [[User alloc] init];user2.name = @\"Rose\";user2.icon = @\"nami.png\";NSArray *userArray = @[user1, user2];// 将模型数组转为字典数组NSArray *dictArray = [User keyValuesArrayWithObjectArray:userArray];NSLog(@\"%@\", dictArray);/*( &#123; icon = \"lufy.png\"; name = Jack; &#125;, &#123; icon = \"nami.png\"; name = Rose; &#125; )*/ 核心代码7：1[User keyValuesArrayWithObjectArray:userArray] 更多用法12参考NSObject+MJKeyValue.h参考NSObject+MJCoding.h","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UIScrollView的代理方法汇总","slug":"ios-uiscrollview-delegate-methods","date":"2019-02-02T03:15:37.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2019-02-02-ios-uiscrollview-delegate-methods/","link":"","permalink":"https://paaatrick.com/2019-02-02-ios-uiscrollview-delegate-methods/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@protocol UIScrollViewDelegate&lt;NSObject&gt;@optional- (void)scrollViewDidScroll:(UIScrollView *)scrollView; // any offset changes 只要scrollView的content 这个方法在任何方式触发 contentOffset // 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 contentOffset // 的变化，并根据当前的 contentOffset 对其他 view 做出随动调整。// called on start of dragging (may require some time and or distance to move)- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView; // 用户开始拖动 scroll view 的时候被调用，可能需要一些时间和距离移动之后才会触发。// called on finger up if the user dragged. velocity is in points/millisecond. // targetContentOffset may be changed to adjust where the scroll view comes to rest- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset NS_AVAILABLE_IOS(5_0);// 在 didEndDragging 前被调用，当 willEndDragging 方法中 velocity 为 CGPointZero//（结束拖动时两个方向都没有速度）时，didEndDragging 中的 decelerate 为 NO，即没有减速过程，//willBeginDecelerating 和 didEndDecelerating 也就不会被调用。反之，// 当 velocity 不为 CGPointZero 时，scroll view 会以 velocity 为初速度，// 减速直到 targetContentOffset。- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;// 在用户结束拖动后被调用，decelerate 为 YES 时，// 结束拖动后会有减速过程。注，在 didEndDragging 之后，如果有减速过程，// scroll view 的 dragging 并不会立即置为 NO，而是要等到减速结束之后，// 所以这个 dragging 属性的实际语义更接近 scrolling。- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; // 减速动画开始前被调用。- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; // 减速动画结束时被调用，这里有一种特殊情况：当一次减速动画尚未结束的时候再次 drag scroll view，// didEndDecelerating 不会被调用，并且这时 scroll view 的 dragging 和 decelerating 属性都是 YES。// 新的 dragging 如果有加速度，那么 willBeginDecelerating 会再一次被调用，然后才是 didEndDecelerating；// 如果没有加速度，虽然 willBeginDecelerating 不会被调用，但前一次留下的 didEndDecelerating 会被调用 - (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; // called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2); // any zoom scale changes view缩放改变的时候调用。- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView; // return a view that will be scaled. if delegate returns nil, nothing happens告诉代理要缩放那个控件。 - (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view NS_AVAILABLE_IOS(3_2); // called before the scroll view begins zooming its content缩放开始的时候调用- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale; // scale between minimum and maximum. called after any 'bounce' animations缩放完毕的时候调用。- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; // return a yes if you want to scroll to the top. if not defined, assumes YES- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; // called when scrolling animation finished. may be called immediately if already at top滚动动画完成时调用。@end","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UILabel的lineBreakMode省略模式设置","slug":"ios-uilabel-linebreakmode-setting","date":"2019-02-01T10:18:21.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2019-02-01-ios-uilabel-linebreakmode-setting/","link":"","permalink":"https://paaatrick.com/2019-02-01-ios-uilabel-linebreakmode-setting/","excerpt":"","text":"123456label.lineBreakMode = NSLineBreakByCharWrapping; //以字符为显示单位显示，后面部分省略不显示。label.lineBreakMode = NSLineBreakByClipping; //剪切与文本宽度相同的内容长度，后半部分被删除。label.lineBreakMode = NSLineBreakByTruncatingHead; //前面部分文字以……方式省略，显示尾部文字内容。label.lineBreakMode = NSLineBreakByTruncatingMiddle; //中间的内容以……方式省略，显示头尾的文字内容。label.lineBreakMode = NSLineBreakByTruncatingTail; //结尾部分的内容以……方式省略，显示头的文字内容。label.lineBreakMode = NSLineBreakByWordWrapping; //以单词为显示单位显示，后面部分省略不显示。","categories":[{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS修改UIImage图片尺寸大小逻辑分辨率","slug":"ios-uiimage-resize","date":"2019-02-01T09:57:12.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2019-02-01-ios-uiimage-resize/","link":"","permalink":"https://paaatrick.com/2019-02-01-ios-uiimage-resize/","excerpt":"之前遇到的问题，给UITabbar item设置图片，然而素材的图片分辨率是87*87，填满了整个tabbar item的区域，很难看，又要考虑适配XS Max的三倍问题。 解决方法如下： 通过设置scale使生成的图片尺寸是逻辑分辨率pt单位，不用操心二倍三倍的问题。","text":"之前遇到的问题，给UITabbar item设置图片，然而素材的图片分辨率是87*87，填满了整个tabbar item的区域，很难看，又要考虑适配XS Max的三倍问题。 解决方法如下： 通过设置scale使生成的图片尺寸是逻辑分辨率pt单位，不用操心二倍三倍的问题。 123456789+ (UIImage *)imageResize:(UIImage*)img andResizeTo:(CGSize)newSize &#123; CGFloat scale = [[UIScreen mainScreen]scale]; //UIGraphicsBeginImageContext(newSize); UIGraphicsBeginImageContextWithOptions(newSize, NO, scale); [img drawInRect:CGRectMake(0,0,newSize.width,newSize.height)]; UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 这样一来就能使tabbar item的图标始终是25pt*25pt，恰到好处。 1childController.tabBarItem.selectedImage = [[SmallTools imageResize:[UIImage imageNamed:selected] andResizeTo:CGSizeMake(25, 25)] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; 另外关于上图中间图标的动画效果实现可参考此文章iOS UITabbar图标点击动画效果实现","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"iOS UITabbar图标点击动画效果实现","slug":"ios-uitabbar-touch-animation","date":"2019-02-01T08:54:57.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2019-02-01-ios-uitabbar-touch-animation/","link":"","permalink":"https://paaatrick.com/2019-02-01-ios-uitabbar-touch-animation/","excerpt":"简介正常情况下，我们点击tabbar都只有一个变色效果，但有时候，如果我们想给它添加一个点击动画，该如何做呢？ 以下是两种方法： 方法一通过tabBar: didSelectItem:代理方法接收每次点击的item，对每个item都绑定动画效果，弊端是获取到的是整个item，图标和标题都会一起动。 方法二是自定一个方法单独获取tabbar item的image和label，可自定只对某个item绑定动画，并且可设定单独image的动画。 效果图 第二种方法：只对image执行动画 1、带重力效果的弹跳","text":"简介正常情况下，我们点击tabbar都只有一个变色效果，但有时候，如果我们想给它添加一个点击动画，该如何做呢？ 以下是两种方法： 方法一通过tabBar: didSelectItem:代理方法接收每次点击的item，对每个item都绑定动画效果，弊端是获取到的是整个item，图标和标题都会一起动。 方法二是自定一个方法单独获取tabbar item的image和label，可自定只对某个item绑定动画，并且可设定单独image的动画。 效果图 第二种方法：只对image执行动画 1、带重力效果的弹跳 后4个是第一种方法 2、先放大，再缩小 3、Z轴旋转 4、Y轴位移 5、放大并保持 代码实现获取要执行动画的Item12345678910111213141516171819202122232425262728293031323334353637383940414243@interface MainTabbarVC ()&lt;UITabBarControllerDelegate&gt;@property (nonatomic,assign) NSInteger indexFlag; //记录上一次点击tabbar，使用时，记得先在init或viewDidLoad里 初始化 = 0@end//第一种方法：通过接收点击事件对每个tabbar item的点击都执行动画-(void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item&#123; NSInteger index = [self.tabBar.items indexOfObject:item]; if (index != self.indexFlag) &#123; //执行动画 NSMutableArray *arry = [NSMutableArray array]; for (UIView *btn in self.tabBar.subviews) &#123; if ([btn isKindOfClass:NSClassFromString(@\"UITabBarButton\")]) &#123; [arry addObject:btn]; &#125; &#125; //添加动画 //---将下面的动画代码块拷贝到此并修改最后一行addAnimation的layer对象即可--- self.indexFlag = index; &#125;&#125;//第二种方法：只想对某一个item的点击执行动画，且只有图片动，文字不动。并且其余图标的点击不带动画- (void)tabBarImageAnimation &#123; for (UIControl *tabBarButton in self.tabBar.subviews) &#123; if ([tabBarButton isKindOfClass:NSClassFromString(@\"UITabBarButton\")]) &#123; for (UIControl *tabBarButtonLabel in tabBarButton.subviews) &#123; if ([tabBarButtonLabel isKindOfClass:NSClassFromString(@\"UITabBarButtonLabel\")]) &#123; UILabel *label = (UILabel *)tabBarButtonLabel; //\"tab1\"到\"tab4\"分别是不打算执行动画的tabbar item的标题名称 if (![label.text isEqualToString:@\"tab1\"] &amp;&amp; ![label.text isEqualToString:@\"tab2\"] &amp;&amp; ![label.text isEqualToString:@\"tab3\"] &amp;&amp; ![label.text isEqualToString:@\"tab4\"]) &#123; for (UIView *imageView in tabBarButton.subviews) &#123; if ([imageView isKindOfClass:NSClassFromString(@\"UITabBarSwappableImageView\")]) &#123; //添加动画 //---将下面的动画代码块拷贝到此并修改最后一行addAnimation的layer对象即可--- &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 第二种方法的用法比较灵活，比如可以在TabbarVC里设上面tabBarImageAnimation方法的通知Observer，在需要执行动画的地方比如打开某VC时在该VC的viewDidAppear里post通知即可。 动画代码1、带重力效果的弹跳 123456CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@\"transform.translation.y\"];//通过初中物理重力公式计算出的位移y值数组animation.values = @[@0.0, @-4.15, @-7.26, @-9.34, @-10.37, @-9.34, @-7.26, @-4.15, @0.0, @2.0, @-2.9, @-4.94, @-6.11, @-6.42, @-5.86, @-4.44, @-2.16, @0.0];animation.duration = 0.8;animation.beginTime = CACurrentMediaTime() + 1;[imageView.layer addAnimation:animation forKey:nil]; 2、先放大，再缩小 12345678910//放大效果，并回到原位CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.autoreverses = YES; //完成动画后会回到执行动画之前的状态animation.fromValue = [NSNumber numberWithFloat:0.7]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:1.3]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 3、Z轴旋转 12345678910//z轴旋转180度CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.rotation.z\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = YES;animation.fromValue = [NSNumber numberWithFloat:0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:M_PI]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 4、Y轴位移 12345678910//向上移动CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.translation.y\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = YES;animation.fromValue = [NSNumber numberWithFloat:0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:-10]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil]; 5、放大并保持 1234567891011121314151617//放大效果CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@\"transform.scale\"];//速度控制函数，控制动画运行的节奏animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.duration = 0.2; //执行时间animation.repeatCount = 1; //执行次数animation.removedOnCompletion = NO;animation.fillMode = kCAFillModeForwards; //保证动画效果延续animation.fromValue = [NSNumber numberWithFloat:1.0]; //初始伸缩倍数animation.toValue = [NSNumber numberWithFloat:1.15]; //结束伸缩倍数[[arry[index] layer] addAnimation:animation forKey:nil];//移除其他tabbar的动画for (int i = 0; i&lt;arry.count; i++) &#123; if (i != index) &#123; [[arry[i] layer] removeAllAnimations]; &#125;&#125; 此外，如果想定制其他动画效果，还可以从下面属性里自己定制动画","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"}]},{"title":"比咪蒙更可怕的，是挖祖坟式举报清算","slug":"raistlin2017","date":"2019-01-31T16:00:50.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2019-02-01-raistlin2017/","link":"","permalink":"https://paaatrick.com/2019-02-01-raistlin2017/","excerpt":"原文始发于微信公众号（为你写一个故事）：比咪蒙更可怕的，是挖祖坟式举报清算 因为旗下账号“才华有限青年”一篇自称“非虚构“的文章，咪蒙又被推上风口浪尖。","text":"原文始发于微信公众号（为你写一个故事）：比咪蒙更可怕的，是挖祖坟式举报清算 因为旗下账号“才华有限青年”一篇自称“非虚构“的文章，咪蒙又被推上风口浪尖。 就事论事的说，才华有限青年其实和咪蒙关系不大，那确实是个相对独立的团队，我也读过他们以前很多文章，很多都挺好看，要说有什么错，最多是有点煽动情绪。 但是做媒体嘛，又有几个不煽动情绪呢，只要不造谣，不引导邪恶的价值观，就没啥问题。 所以我觉得一个好的方式是，你不同意她的一篇文章，就说这篇文章写得不好写得不对，甚至可以说这篇文章写得用心险恶。 但你去挖她的出身，说她以前是咪蒙的实习生，所以一定不是什么好人。 就有点恶毒了。 比如有一位我挺喜欢的媒体人，这样写，我就觉得恶毒了 （而且如果真的翻了照片的话，较真的说这句话是造谣） 还有昨天整个朋友圈轰轰烈烈的”含咪量“测试，很多人号称朋友圈只要有人关注咪蒙了，就要和TA互删。 这我也觉得太过。按照他们的意思，也别管这人是谁，和他们是什么关系，是不是好朋友或者亲戚，也不管这个人关注咪蒙究竟是认同咪蒙的价值观还是就想围观一下或者学习排版，只要关注咪蒙，就要互删。这放在几十年前，我们叫做”划清界限“，流行这种运动的十年，是新中国最混乱的十年。当然我觉得更过的，还是下面这张截图。 咪蒙一边说这话，一边”永远爱国，永远热泪盈眶“恶不恶心？恶心。 咪蒙式毒鸡汤讨不讨厌？ 我也讨厌。但这样挖祖坟式清算举报，尤其是一直翻到2013年的微博，然后把相关机构全都@一遍的行为，让我感到很不舒服。这种不舒服不是反感，而是感到恐怖。而且这样的事情，这些年越来越多了。这样的待遇，陈一发遭遇过： 罗永浩遭遇过： 毕福剑也遭遇过： 普通网友当然也遭遇过： 动不动就呼吁封杀，虎扑和吴亦凡粉丝战斗时，双方都遭遇过。 游戏《阴阳师》遭遇过： 明星骂战的时候使用过这种武器。 社会热点事件就不说了，总是有成千上万人向团团举报。 现在甚至王者荣耀玩得不爽了，也要举报。 在这些举报里，网友们用不知道从哪里学到的词汇，给自己看着不爽的人扣上一个又一个大帽子，套上一个又一个罪名，其手法之纯熟，让我一度以为生活在冯骥才的《一百个人的十年》里。 可惜拿起手机瞧一瞧，发现已经是2019年了。 在我看来这种行为和看到让自己不爽的综艺，歌曲，电影就呼吁封杀是一样的，都是分不清各种权利界限的表现。就像几百年前，被人欺负了，就去衙门一跪，高喊“大人，我冤啊！”，然后期待青天大老爷给自己做主的古代中国人一样，始终没有长大。 他们自己是巨婴，却以为我国居民全都是长不大的巨婴，需要妈妈无微不至地照顾我们，帮我们挑好哪些是我们该看的，哪些是我们不该看的，然后只要他们看到自己不爽的，就会像孩子一样哭喊着叫妈妈来，希望妈妈把“坏东西”都打飞，然后才会重新喜笑颜开。 可惜现代法制社会没有，也不应该有青天大老爷——历史早已经证明了，青天大老爷式的人治，远不如法治来得公平高效，青天大老爷十年一遇，但手握权力，肆意滥用的昏官却遍地都是。 这已经很魔幻了。 但更魔幻的是，这些诉求，有时候还真的会得到回应。 以前我觉得孩子长不大，站不起来，是因为孩子自己笨，不想长大，后来才明白，孩子长不大，多半是有一个什么都替孩子做主，什么都替孩子决定的妈——在这些挖坟举报真的会得到回应的情况下，这样的行为永远不会停止，只会变本加厉。 即使如此，我还是希望你们能少挖坟，少呼吁封杀。 因为“封杀”这个词代表的那个行为，本来就不应该存在于这个世界上，并且当你习惯”封杀“之后，迟早有一天，会降临到你喜欢的那个账号，那个主播或者那个明星身上。 还记得之前整治八卦的时候吗？ 一开始封的很多账号，大家都讨厌，所以一片叫好声。结果之后发展到只要账号中带”八卦“两个字的，都被封号了，包括大家爱看的”毒舌电影“，”严肃八卦“，”金融八卦女“也全部都凉了。 最搞笑的是，我有个朋友，做了个账号叫”财经八卦阵“，那段时间只能改成”财经九卦阵“，终于躲过一劫。 还记得之前讨厌PGONE的人拼命举报PGONE，@了一大堆官方账号，要求对PGONE进行封杀吗？ 那会儿恰好GAI求婚成功，所以当时这些人中，有不少都人是通过捧GAI来踩PGONE的。 我自己也是GAI的粉丝，在一个GAI的粉丝群里，有几个姐们表示太好了，解气。但随即更多人表示这不是好事，因为GAI也有黑历史。 果然过了没多久，GAI被迫从《歌手》中退赛，至今也没在电视上再看过他。 在这样轰轰烈烈的挖坟式举报运动中，暴走漫画凉了，陈一发凉了，卢本伟凉了，毕福剑凉了，很多歌手明星都凉了。 PGONE被封杀你们叫好，GAI被封杀你们喊冤，毕福剑从央视消失你们想念他。你们以为这几件事不一样应该分开，但经历过这么多事情，你们应该明白，这两件事其实根本就是一件事。 封杀的人不会管哪个嘻哈歌手是正能量的，哪个是屡教不改的——既然嘻哈有问题，那就有问题的一起下。 就像现在这些为咪蒙的倒台拍手叫好的自媒体人，你又知道封杀的人分得清你和咪蒙的区别咯？ 况且在我看来，很多账号根本就和咪蒙没区别。 比如某个自媒体，洋洋洒洒写了几千字，细数咪蒙的”七宗罪“。 最后得出的结论是，咪蒙最大的罪就是她在迎合读者，并且标题低俗，危害极大。他把文章发到500人的新媒体群里，希望大家为他鼓掌叫好。 结果翻开他自己的公众号，标题却是这个画风的。 当有人在群里质问他，这是不是在迎合读者，标题低俗，危害极大的时候，他很坦诚的承认”可我的没人看啊。“ 让人心慌。 一个事实是，我们说的法制说的正义，从来不是给我们喜欢的东西准备的，我们喜欢的东西，根本不需要心中的那杆称来保护。 我们说的正义和法制，是你们讨厌的人，也有说话的权利，如果他们没有违法，就不应该不让他们说话。 还有一个事实是，咪蒙的价值观确实有问题，也许能煽动几十万人的情绪，是会让人焦虑，但真要说她改变了多少人三观，我觉得各位是高看文字的力量了。 一方面咪蒙并不产生三观，她一般只迎合大众情绪，另一方面三观这东西是没那么容易改变的，2019年了，文字早就没那么大力量了，现在如果说谁因为一篇文章三观就变了，那说明TA本来就有这样的想法，只是这篇文章正好支持了TA而已。 比起咪蒙，我更害怕那样因为讨厌一个人，就肆无忌惮地爆粗口，就想着要弄死对方，更害怕那样挖祖坟式的举报。 因为这让我觉得自己每时每刻都活在监视中，终日不得安宁。 现在你们觉得应该这样对付咪蒙，谁知道哪天我会不会受到这样的待遇。 而且说一千道一万，当年咪蒙写那几篇文章，疯狂在朋友圈转发刷屏，把咪蒙一度捧成微信第一大号的，还不是网友吗？ 看到某个去年还把咪蒙请为座上宾，一口一个咪蒙老师做分享的机构，昨天他们主编也开始测含咪率了，可能下一步就要表态”互删“了。 看到之前分享过致贱人几篇的人，开始在朋友圈说”想不通为什么这么多人会关注咪蒙“了。 有时候见多了这种昨天还万人追捧，今天就过街老鼠的戏码。真是让人对这个复杂繁复的世界，又害怕了几分呢。 -END-","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[]},{"title":"亲测真正好用的WordPress媒体库图片分类插件","slug":"wp-real-media-library","date":"2019-01-31T10:25:33.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2019-01-31-wp-real-media-library/","link":"","permalink":"https://paaatrick.com/2019-01-31-wp-real-media-library/","excerpt":"WordPress有个很大的问题就是管理上传图片的媒体库很菜，连最基本的文件夹分类功能都没有。 网上找了好一会儿，最开始找到一个 Attachment Taxonomies 看介绍好像还可以","text":"WordPress有个很大的问题就是管理上传图片的媒体库很菜，连最基本的文件夹分类功能都没有。 网上找了好一会儿，最开始找到一个 Attachment Taxonomies 看介绍好像还可以 然而实际使用起来极不方便，上传图片时不能选择上传到哪个分类，现有的图片也不能多选设置分类，需要点开每一张图片再勾选分类。 然后找到一个 WP Real Media Library 度娘盘找到了资源，下载后在WordPress插件界面上传使用。 使用起来非常顺手。 下载链接V4.0.10 度盘链接","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"https://paaatrick.com/tags/WordPress/"}]},{"title":"云服务器使用WordPress搭建个人博客并绑定域名全记录","slug":"build-wordpress-blog","date":"2019-01-29T10:38:32.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2019-01-29-build-wordpress-blog/","link":"","permalink":"https://paaatrick.com/2019-01-29-build-wordpress-blog/","excerpt":"一直在续费云服务器，索性充分利用资源，复古一下，鼓捣个小博客记录些东西。 现在大致已经搭好博客了，那就先把这折腾了一整天的建站过程给记录下。 关于服务器前几年购入的Vultr的ECS，东京的相对性价比高一些，延迟和网速都很稳，现在（2019.1）还有3.5刀一个月的，非常实惠。","text":"一直在续费云服务器，索性充分利用资源，复古一下，鼓捣个小博客记录些东西。 现在大致已经搭好博客了，那就先把这折腾了一整天的建站过程给记录下。 关于服务器前几年购入的Vultr的ECS，东京的相对性价比高一些，延迟和网速都很稳，现在（2019.1）还有3.5刀一个月的，非常实惠。 安装 Apache2、MySQL、PHP12sudo apt-get install apache2sudo apt-get install mysql-server mysql-client 测试一下Apache2是否成功安装：浏览器访问云服务器的IP，安装成功的话会显示Apache2的默认页面，It works。 安装php7.0，并安装apache的php扩展，再安装整合mysql和php的工具 123sudo apt-get install php7.0sudo apt-get install libapache2-mod-php7.0sudo apt-get install php7.0-mysql 重启一下Apache2和MySQL 12sudo service apache2 restartsudo service mysql restart 安装 phpmyadmin 这是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具。 1sudo apt-get install phpmyadmin 开启 apache 的 mod_rewrite，再重启一次apache 12sudo a2enmod rewritesudo service apache2 restart 先登录mysql mysql -u root -p ，输入密码 首先创建名为“wordpressdb”数据库，然后查看创建的数据库是否成功。 12create database wordpressdb;show databases; 看到图中出现自己创建的数据库。 给用户服务权限，下面的wordpressuser改为安装mysql时自己输入的用户名。 GRANT ALL PRIVILEGES ON wordpressdb.* TO wordpressuser@localhost;FLUSH PRIVILEGES; 输入 exit;退出mysql，并再次重启服务。 12sudo service apache2 restartsudo service mysql restart 下载并配置WordPress用wget从WordPress官方网站下载安装包，放在 /var/www/html/ 目录，然后解压。 （最新版下载链接在 https://cn.wordpress.org/download/ 里面有） 123cd /var/www/html/sudo wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.zipsudo tar zxf wordpress-4.9.4.tar.gz 在 /var/www/html/wordpress/wp-content/ 下创建uploads。 然后更改上传目录权限，不然之后博客上传不了图片。 1234sudo mkdir uploadssudo chown -R www-data /var/www/html/wordpresssudo chmod -R 755 /var/www/html/wordpresssudo chown -R :www-data /var/www/html/wordpress/wp-content/uploads 配置wp-config-sample.php ，该文件在/var/www/html/wordpress/下 1sudo vi wp-config-sample.php 修改方法如下图所示： 浏览器访问 http://服务器IP地址/wordpress ，如果安装正常则进入wordpress的安装界面。 安装好后的效果如图： 到此建站完成。接下来申请域名并绑定服务器。 申请域名并配置DNS通过比价网站可以先大致看一下想要的域名价格 https://www.domcomp.com/ 看了一下知乎，大家推荐的域名供应商有 NameSilo 、Namecheap、Porkbun、GoDaddy等，亲测了一遍，发现 NameSilo 用户界面太丑；Namecheap 实际并不 cheap；最多人说的 GoDaddy 也偏贵但是支持支付宝，Porkbun 性价比高而且界面友好。 因为有境外支付的信用卡就不考虑 GoDaddy 了，直接在 Porkbun 上下单了一个 .com 域名，首年不到 7刀，续费 8.7刀。 值得一提的是支付时好几张卡支付失败，建行、农行都不行，换了广发的万事达才支付成功，有点迷。 付款后主页可以看到自己域名的各种详情，然后要设置的是 DNS RECORDS 点击Edit，添加两个A记录，分别是带www和不带的域名，ANSWER填自己的主机地址。 两个NS填DNS提供商的，这里因为Vultr自带了免费的DNS服务，直接填上去即可，具体的DNS地址可在Vultr的设置页里找。 下图就是设置页，可以看到底下有两条DNS地址，填到 Porkbun 里，然后还要在 Vultr 里 Add Domain，绑定服务器到域名。 两边都操作完成后，静候几分钟，然后访问一下自己的域名，应该就出来了。 常见问题在仪表盘的设置中不小心更改了wordpress地址后回不到后台在建站过程中，如果改动了 wordpress地址或站点地址，就回不到后台了。 解决方法：网站首页在wordpress目录下的index.php中的require这行的内容。 下图是wordpress下index.php的require所在行的内容。 最开始wordpress url是： 主机ip/wordpress。 它会自动去找index.php，然后就通过index.php里面的内容加载wordpress环境，更改了url后，就不能自动去找index.php了。此时后台也无法登录。解决这个问题，直接进数据库修改相关数据即可。操作如下。 1234567mysql -u root -p //然后输入密码show databases; //显示所有数据库use wordpressdb; //选中你自己网站对应的数据库。show tables; //显示该数据库所有表格。select * from wp_options where 1=1 limit 10; //查看数据库前10条记录update wp\\_options set option\\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;siteurl&apos;;//（如果home也改了就也改回来）update wp\\_options set option\\_value=&apos;http://服务器ip（或域名）/wordpress&apos; where option_name=&apos;home&apos;; 其实就是改变了wordpress url ，则wp_options表中的siteurl的值变化了，只要把它在修改过来就行。 使用服务器IP（或域名）根地址直接访问网站首页此文章的建站方法是把所有东西都放在wordpress目录下，因此建完后，访问网站的网址为：主机IP/wordpresss。 通常情况下，我们会买一个域名与云主机IP绑定，输入IP地址只能访问根目录。 即/var/www/html，但是无法访问其下面的子目录。 以下将给出解决方案。如果使主机IP直接定位到网站首页。 第一种解决方式是把wordpress的内容直接都弄到根目录中，这是不提倡的，会使根目录变得杂乱。通常推荐第二种方案。 第二种方案操作如下： 登录后台，打开 设置→常规，修改站点地址。 WordPress地址是本体存放的地址，按本文安装的话就不用改动了。 站点地址是浏览器访问的地址，改为 “http://服务器IP（或域名）” 的形式，如下图即可。 同时，打开 设置→固定链接，把固定链接修改成如下形式：（去掉中间的/wordpress/） 至于文章后缀名，网上有关WordPress永久链接设置的介绍众多，普遍认为 /%postname%.html 是最佳的自定义永久链接形式。 这种形式将显示为:http://你的域名/日志标题.html，简单明了，有利于SEO。但当你的日志标题是中文时，文章标题以中文形式出现，看上去很不符合标准，或者可能会出现如:%64%b3%e8%ae%ar%e6%ba%a7%e5%9.html 类似乱码的显示。因此需要在编辑文章时，标题下面固定链接项，点击编辑，用拼音或英文输入文章标题。 然后把wordpress目录下的index.php 和 .htaccess文件复制一份到根目录下，.htaccess 是隐藏文件，可以使用ls -all。将其显示出来。注意是复制文件，原来目录下还存在。 123cd /var/www/html/wordpress/cp index.php /var/www/html/cp .htaccess /var/www/html/ 然后使用vim修改.htaccess文件的内容为下图所示。（默认文件如果就是如此则跳过该步骤） 修改index.php文件，因为index.php文件是wordpress下index.php的复制品，因此文件内部的require那一行的值当对于当前目录，是不正确的。同样使用vim编辑该文件，把require那一行路径，修改成下图那样。 此时再输入IP，看到还是It works界面，那是因为安装apache时，我们看到的It works界面其实是根目录下的index.html。当index.html 和 index.php同时存在时，默认还是打开index.html，所以应该把index.html移出该目录。我们把它移出到其他目录就行。 然后可能会产生下一个问题，设置固定链接后，文章页会404解决方法如下： 1sudo vi /etc/apache2/apache2.conf 把 AllowOverride None 改为 AllowOverride ALL 注意有两处要改，然后操作一下 12sudo a2enmod rewritesudo /etc/init.d/apache2 restar 刷新一下应该就能正常打开文章了。 主页样式修改 页尾和功能模块里的链接如果觉得碍眼，可以去除。 删除页尾“自豪地使用WordPress”字样 如果是通过函数生成页尾的主题，一般在模板函数那里修改，查找 “Proudly powered by” 的字样删掉就ok。 1&lt;a href=“&lt;?php echo esc\\_url( \\_\\_( ‘http://wordpress.org/’, ‘twentyeleven’ )); ?&gt;” title=“&lt;?php esc\\_attr\\_e(‘SemanticPersonalPublishing Platform’, ‘twentyeleven’ ); ?&gt;” rel=“generator”&gt;&lt;?php printf( __( ‘Proudly powered by%s’,‘twentyeleven’ ), ‘WordPress’ ); ?&gt;&lt;/a&gt; 删除功能小工具里的“文章RSS”、“评论RSS”、“WordPress.org”打开组件文件夹：wp-include/widgets/class-wp-widget-meta.php 找到代码段删除即可。 1234&lt;!\\-\\- 屏蔽 RSS 功能&lt;li&gt;&lt;a href=\"&lt;?php echo esc\\_url( get\\_bloginfo( 'rss2\\_url' )); ?&gt;\"&gt;&lt;?php \\_e('Entries &lt;abbr title=\"Really Simple Syndication\"&gt;RSS&lt;/abbr&gt;'); ?&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"&lt;?php echo esc\\_url( get\\_bloginfo( 'comments\\_rss2\\_url' )); ?&gt;\"&gt;&lt;?php _e('Comments &lt;abbr title=\"Really Simple Syndication\"&gt;RSS&lt;/abbr&gt;'); ?&gt;&lt;/a&gt;&lt;/li&gt;--&gt;","categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"https://paaatrick.com/tags/WordPress/"}]},{"title":"性冷淡商务风：深圳龙华希尔顿逸林酒店","slug":"doubletree-longhua","date":"2017-05-16T16:00:50.000Z","updated":"2021-11-07T12:02:15.275Z","comments":true,"path":"2017-05-17-doubletree-longhua/","link":"","permalink":"https://paaatrick.com/2017-05-17-doubletree-longhua/","excerpt":"龙华年初新开了间 DoubleTree，从此深圳也有CAT2的希尔顿了。可惜的是积分房常年不放10000分的基础房型，还好连续两日及以上还能订到基础房，配合 Hilton Q1 促销每晚送2000分活动，非常适合保级刷房。 酒店在粤商中心大厦1-15层，坐落于龙华文化广场旁，隔壁是龙华星河ICO，距离地铁清湖站较近，周围还算繁华，据说是龙华新区首家五星级国际酒店。粤商中心这栋楼全玻璃覆盖显得比较商务，符合 DoubleTree 品牌的定位。","text":"龙华年初新开了间 DoubleTree，从此深圳也有CAT2的希尔顿了。可惜的是积分房常年不放10000分的基础房型，还好连续两日及以上还能订到基础房，配合 Hilton Q1 促销每晚送2000分活动，非常适合保级刷房。 酒店在粤商中心大厦1-15层，坐落于龙华文化广场旁，隔壁是龙华星河ICO，距离地铁清湖站较近，周围还算繁华，据说是龙华新区首家五星级国际酒店。粤商中心这栋楼全玻璃覆盖显得比较商务，符合 DoubleTree 品牌的定位。 一进大堂就是典型的 DoubleTree 性冷淡风格，米白色大理石为主的装修风格使原本较小的大堂显得大气，前台人手不够，客人多时要排队 CI/CO，上酒廊 Check-in 就更是要等很久了。 酒店被设计在这栋楼底部十几层，上半部分是写字楼，似乎业主不太重视酒店。 这次入住时房态紧张，只给升一级到12楼的园景房，虽然没升级到行政房不过也给了行政待遇。 DoubleTree 标志性的热曲奇饼，每位顾客入住时都给两份，很好吃，路过前台时可以再要几块。 因为是新开业的酒店，硬件水准在同品牌中数一数二，客房面积48平方起步也没什么问题，套房楼层据说被某剧组包了几个月，因此没能升级套房挺可惜的。 逸林标配单人浴缸，卫生间干湿分离，瑰珀翠（Crabtree &amp; Evelyn）的备品味道一般，还是更喜欢彼得罗夫（Peter Thomas Roth）的热情果味。 窗外正对龙华文化广场，也是新建的，晚上有大批广场舞大妈，幸好玻璃隔音性能不错，问题是晚上有治安的单车持续闪烁红蓝灯光，穿透力极强，不拉上遮光窗帘要被闪瞎眼。 床头音响支持直接插 iPhone 播放，插座自带USB也是这几年新开酒店的标配了。欢迎水果略显小气，进门的柜子另有玄机，水壶茶杯和小冰箱都藏在里面。 行政酒廊的 Happy Hour 从17点到19点，菜品十分丰富，热菜、甜品很多，当作晚餐完全没有问题。 酒店健身房还没装修好，把酒廊对面的一间套房改造成了一个临时健身房，所以面积很小，设备也不够多，来几个老外就占满了。室外泳池也要到17年5月底才开放。 回到房间发现已经开好了夜床，可能是看到一下子把两瓶水喝完了，于是又补充了六瓶😂而且很贴心地在床上放了张明日天气预报。 酒店的主餐厅名为 『OPEN | “開”全日餐厅』，然而晚上只营业到22点，并没有通宵开放😑 早餐看似丰富，实际出品一般，蛋卷和鸡肉肠还没有希尔顿花园的好吃。不过餐厅环境确实不错，适合平时晚上来吃自助餐。 这间 DoubleTree 最近几个月都不放基础房了，可能确实是商务客比较多吧， 10000分入住虽然没有华东一堆5000分 DoubleTree 那么白菜价，但毕竟地处深圳龙华腹地，性价比非常高，实属希尔顿保级优选。 原文始发于微信公众号（派大星星星星）：性冷淡商务风：深圳龙华希尔顿逸林酒店","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Hotel","slug":"Hotel","permalink":"https://paaatrick.com/tags/Hotel/"}]},{"title":"宜家 | 一个顺便卖卖家具的饭堂","slug":"ikea-canteen","date":"2015-12-16T16:00:50.000Z","updated":"2021-11-07T12:02:15.274Z","comments":true,"path":"2015-12-17-ikea-canteen/","link":"","permalink":"https://paaatrick.com/2015-12-17-ikea-canteen/","excerpt":"相信很多人印象中的宜家只是个卖家具的地方 跟自己关系不大 去那里干嘛","text":"相信很多人印象中的宜家只是个卖家具的地方 跟自己关系不大 去那里干嘛 然而事实上并不是这样的 宜家不只是卖家具 也卖非常多零碎玩意 很适合买来充实宿舍 但更重要的是它的餐厅 一个室友说 “宜家就是个顺便卖家具的食堂” 这话不假 这个餐厅不只是周末人满为患 即便是工作日也要找座位找很久 这还是宜家坐落在没有地铁经过的郊区的前提下 显得更为难得 ▲餐厅门口菜单 餐厅不算太大 菜单也很简单 主菜也就瑞典肉圆 蔬菜丸 肉酱面 三文鱼 西冷牛扒 牛肉饭等 最赞的就是瑞典肉圆了 不同于汕头牛肉丸爽口 弹性 有嚼劲 宜家的瑞典肉圆口感细腻 用料丰富 以猪肉和牛肉混合搅碎 加入牛奶 面包糠 切碎的洋葱 马铃薯粉或燕麦片 然后再加上白胡椒 盐 五香粉或肉桂等香料调味 搓匀后捏成球形 食用时配以肉酱 土豆泥 果酱以及一枚瑞典国旗 令人食指大动 西冷牛扒出品还算可以 虽然跟专门做牛扒的餐厅相比差距不小 但考虑到三十多的售价也能理解 还是值这个价的 烤三文鱼配通心粉 份量十足 不到三十块 价格感人 奥尔良鸡腿 表皮烤的焦焦的 肉质多汁嫩滑 跟肉丸一样也是必点 冷盘菜 香草三文鱼 酸黄瓜酱不会掩盖三文鱼的鲜美 反而相得益彰美味可口 宜家物价让人有种回到十年前的感觉 在深圳物价飞涨都快赶上香港的年代 还有这么个出品优良又便宜的餐厅实属不易 如果不是因为路途遥远交通不便利真的就成饭堂了 ▲取菜窗口超像饭堂 说是饭堂的另一个原因 顾客吃完后需要自己把餐盘放进回收车里 大大减少清洁阿姨工作量 ▲会员卡颜值颇高 记得办一张宜家的会员卡 在入口和收银台前都有免费申请的电脑 填完资料直接就吐卡出来了 工作日凭会员卡可以在餐厅免费喝咖啡 无限续杯的喔 而且很多单品都有会员优惠 比如这个两块九的杯子 新会员可以一块钱购买 值得一提的是毛巾和门垫 毛巾质量很好 不会掉毛 门垫价格感人 可以屯多几张在宿舍 脏了直接换一个 在收银台出来的地方还有一个小食档 五块钱的热狗套餐可以无限续杯 最近饮料都换成了相比可乐含糖量减半的北欧风味果味饮料 不过感觉还是以前的蔓越莓果汁好喝 还有就是十块三串的墨鱼丸 真心赞赞赞赞赞 外焦里嫩弹牙可口 墨鱼味十足 买买买后吃上一份墨鱼丸真是酸爽 还有同样十块三串的烤肠 味道跟乐凯撒的烤肠差不多 因为量不多 晚上七八点后可能就卖完了 同样强力推荐 见到了赶紧买三串 小食档旁边还有专门卖瑞典特产的超市 如果肉丸或者三文鱼吃的不过瘾还能买冷冻的回去自己煮 阻挡宜家成为饭堂的最大因素还是地理位置不好 公交非常不便利 只能自驾或者打车前往 不过不塞车的话从桂庙过去十分钟就能到 所以闲暇之余还是可以去吃餐饭的 原文始发于微信公众号（派大星星星星）：宜家 | 一个顺便卖卖家具的饭堂","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Food","slug":"Food","permalink":"https://paaatrick.com/tags/Food/"}]},{"title":"一蘭拉面","slug":"ichiran-ramen","date":"2015-11-17T16:00:50.000Z","updated":"2021-11-07T12:02:15.274Z","comments":true,"path":"2015-11-18-ichiran-ramen/","link":"","permalink":"https://paaatrick.com/2015-11-18-ichiran-ramen/","excerpt":"一蘭拉面 ▲铜锣湾店门口 一蘭拉面的特点在于座位是隔间并且24小时运营，很适合深夜下班后一个人来吃，不会尴尬。","text":"一蘭拉面 ▲铜锣湾店门口 一蘭拉面的特点在于座位是隔间并且24小时运营，很适合深夜下班后一个人来吃，不会尴尬。 ▲座位都是一个个隔间 年初的时候，一兰除了日本本土外就只有铜锣湾一家分店，港岛线铜锣湾站C出口走5分钟谢斐道440号门面便是。店铺不算大，目测只能容纳50人，天黑了之后一直到凌晨三四点都要排队，22点左右高峰期甚至要排一个钟的队，不过为了吃上一碗一兰拉面，排队久一点也值得。 ▲铜锣湾店排队排出了店面 ▲空余座位展示，每个绿色格子代表一个座位 ▲只有一款面的菜单 排队快到的时候店员会给单你让你圈出偏好，我除了硬度喜欢偏硬一些外其他都是普通。偏硬是因为咬起来有口感。一碗89块港币的拉面，精华在于汤底，浓香而不腻，实打实用豚骨熬制，不加味精。吃完面后如果不喝汤就太浪费了。 ▲1/2倍辣 因为还是学生，钱不多，所以很少追加面底、温泉蛋、叉烧或者波子汽水。不过温泉蛋是真心好吃，建议尾巴们去的话一定要点一份。 秘制酱汁确实挺辣的，有一次被怂恿写了5倍辣，吃完整个人都不好了，当晚睡觉都睡不好。当然主要是因为我不太能吃辣，无辣不欢的尾巴可以试试20倍辣，很酸爽[doge] ▲5倍辣 店面是单人隔间，每个位置都有冷水水龙头，就算再冷的天也是冷水。网上的解释是 冰水的作用在於吃拉面时缓和浓厚的味道，同时有助口腔降温加快吃面速度，因为面太热而吃得慢，面浸汤糊烂的情况只会越来越严重。 冰水是多年来日式拉面的传统，春夏秋冬也不改。博主曾在下雪日子在拉面店外排队，店员会为等待的人送上热茶，但去到店内还是冰水。 希望大家不要因為气温10度时拉面店内送上冰水就破口大骂或上网劣评，人家日本人下雪时都未投诉。理解这原因后仍想要热水的话，向店员礼貌地要求就是了。 ▲每个座位上都有首次来店顾客指南，中英日各一份 今年年中的时候，一兰在尖沙咀棉登径8号负一楼开了第二家分店。不知道什么原因，很多地图上都还没有标记出来，尖沙咀N4出口出来就是了。 ▲高德地图 ▲尖沙咀店入口，店铺在负一楼 可能是因为在铜锣湾的第一家海外分店尝到了甜头，这家新分店面积很大，而且出现了一兰屋台，就是普通餐厅的座椅区，但我还是喜欢隔间多一点，毕竟隔间是一兰的特色，坐屋台的话没有感觉。 ▲尖沙咀店一兰屋台 ▲一兰方便面 一兰方便面，四五月份刚推出的时候有买单满200HKD送一个的活动，回来宿舍泡了一下发现挺一般的，跟店里吃的差距太大，不知道是方便面的问题还是我泡面方法不当[摊手]原价是198HKD五包，据说买一套的话里面会有特殊配料 ▲泡出来的效果，凭良心讲确实比合味道之类的好吃一些，但还不至于太好吃，不值那个价。 ▲方便面海报 ▲收银台 ▲收银台后面的展柜 月初去吃的时候发现账单多了一项额外10%的服务费，以前都没见过，不知道是最近才开始收的还是因为尖沙咀店比较大要额外收费。付款支持现金、八达通和银联卡，我预计不用太久，支付宝就会来插一脚，进一步方便大陆游客在香港游玩。 ▲尖沙咀店内海报 还没读大学的时候在广州住，每次去正佳和中华基本上都是吃博多一幸舍。博多刚进驻广州第一次吃的时候震惊了，怎么会有这么好吃的面，从此再也没吃过味千公仔面。 然而上大学后，某次安利别人博多时被反安利了一兰，这才发觉山外有山。 ▲铜锣湾店门面 一兰没有博多一幸舍的喧闹环境，店员们不会热血地齐声用日语喊欢迎光临，只会在隔间后面端面上来时说一声慢用（不会日语，猜的）然后落下帘子。店里如果没有小孩的话一般都挺安静。 另外不同于博多丰富的菜单，一兰只有一款面（好像最近新推出了一款沾面，不太记得了）。 ▲基友吃得正欢 在我有限的经历中，一兰拉面在我吃过的日本拉面中算是最好吃的了，一兰以其独特的隔间设计，只做一款面的坚持，极致浓香的汤底，口感细腻的面底赢得了大众的喜爱。有时候我嘴馋了也不怕劳累，专门从深圳湾过关搭巴士到天水围转港铁到尖沙咀来吃个面，也算是一兰真粉了。 大家如果去一兰，一定要预留多一些时间用来排队，以免耽误行程。[doge] 原文始发于微信公众号（派大星星星星）：一蘭拉面 2019.01更新 — 日本的一蘭拉面 2018年夏天去大阪和东京晃悠了一圈，路过不少一兰。 大阪 ▲大阪也超多人 ▲自助机器先付后食，这种机器是真的🐂🍺 ▲自助机出的票 ▲出品稳定，跟香港的几乎没区别 东京▲还是自助机，依然人多得一批 ▲还是一样的味道 ▲一样的抹茶豆腐","categories":[{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Food","slug":"Food","permalink":"https://paaatrick.com/tags/Food/"}]}],"categories":[{"name":"Tech","slug":"Tech","permalink":"https://paaatrick.com/categories/Tech/"},{"name":"Note","slug":"Note","permalink":"https://paaatrick.com/categories/Note/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/categories/Algorithm/"},{"name":"Life","slug":"Life","permalink":"https://paaatrick.com/categories/Life/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://paaatrick.com/tags/Windows/"},{"name":"GN","slug":"GN","permalink":"https://paaatrick.com/tags/GN/"},{"name":"Ninja","slug":"Ninja","permalink":"https://paaatrick.com/tags/Ninja/"},{"name":"CMake","slug":"CMake","permalink":"https://paaatrick.com/tags/CMake/"},{"name":"iOS","slug":"iOS","permalink":"https://paaatrick.com/tags/iOS/"},{"name":"Flutter","slug":"Flutter","permalink":"https://paaatrick.com/tags/Flutter/"},{"name":"Android","slug":"Android","permalink":"https://paaatrick.com/tags/Android/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://paaatrick.com/tags/CocoaPods/"},{"name":"macOS","slug":"macOS","permalink":"https://paaatrick.com/tags/macOS/"},{"name":"QuickLook","slug":"QuickLook","permalink":"https://paaatrick.com/tags/QuickLook/"},{"name":"Swift","slug":"Swift","permalink":"https://paaatrick.com/tags/Swift/"},{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://paaatrick.com/tags/SwiftUI/"},{"name":"Audio/Video","slug":"Audio-Video","permalink":"https://paaatrick.com/tags/Audio-Video/"},{"name":"NetworkProtocol","slug":"NetworkProtocol","permalink":"https://paaatrick.com/tags/NetworkProtocol/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://paaatrick.com/tags/Objective-C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://paaatrick.com/tags/LeetCode/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://paaatrick.com/tags/Algorithm/"},{"name":"Python","slug":"Python","permalink":"https://paaatrick.com/tags/Python/"},{"name":"WordPress","slug":"WordPress","permalink":"https://paaatrick.com/tags/WordPress/"},{"name":"Hotel","slug":"Hotel","permalink":"https://paaatrick.com/tags/Hotel/"},{"name":"Food","slug":"Food","permalink":"https://paaatrick.com/tags/Food/"}]}